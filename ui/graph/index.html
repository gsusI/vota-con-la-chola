<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Vota Con La Chola | Graph Explorer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&family=IBM+Plex+Mono:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
    <style>
      :root {
        --bg-a: #faf7f1;
        --bg-b: #dae8ff;
        --ink: #1e1d19;
        --ink-soft: #54524a;
        --card: rgba(255, 255, 255, 0.78);
        --accent: #ff6b35;
        --accent-2: #0b5fff;
        --source: #ff6b35;
        --person: #111111;
        --party: #2f8f54;
        --inst: #275db3;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        color: var(--ink);
        font-family: "Space Grotesk", sans-serif;
        background:
          radial-gradient(1000px 420px at 18% 8%, #fff2d9 0%, transparent 70%),
          radial-gradient(1000px 500px at 95% 100%, #dce8ff 0%, transparent 74%),
          linear-gradient(120deg, var(--bg-a), var(--bg-b));
      }

      .page {
        display: grid;
        grid-template-columns: 320px minmax(0, 1fr);
        grid-template-rows: auto minmax(0, 1fr);
        grid-template-areas:
          "top top"
          "side main";
        gap: 14px;
        height: 100%;
        padding: 14px;
      }

      .card {
        border: 1px solid rgba(255, 255, 255, 0.85);
        border-radius: 16px;
        background: var(--card);
        backdrop-filter: blur(7px);
        box-shadow: 0 16px 32px rgba(0, 0, 0, 0.08);
      }

      .sidebar {
        grid-area: side;
        padding: 14px;
        overflow: auto;
      }

      h1 {
        margin: 0 0 4px 0;
        font-size: 1.12rem;
      }

      .view-links {
        display: inline-flex;
        gap: 8px;
        margin: 0 0 8px 0;
      }

      .view-links a {
        text-decoration: none;
        border-radius: 999px;
        padding: 5px 10px;
        border: 1px solid #d7deea;
        color: #182338;
        font-size: 0.75rem;
      }

      .view-links a.active {
        background: linear-gradient(135deg, var(--accent), #ff9d57);
        border-color: transparent;
        font-weight: 700;
      }

      .superheader {
        grid-area: top;
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 8px;
        flex-wrap: wrap;
        position: sticky;
        top: 8px;
        z-index: 2147483647;
        isolation: isolate;
      }

      .superlink {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border: 1px solid #d0def8;
        background: #eff6ff;
        border-radius: 999px;
        padding: 6px 10px;
        color: #102a5c;
        text-decoration: none;
        font-size: 0.82rem;
        font-weight: 700;
      }

      .superlink svg {
        width: 16px;
        height: 16px;
        fill: currentColor;
        flex: 0 0 auto;
      }

      .subtitle {
        margin: 0 0 14px 0;
        color: var(--ink-soft);
        font-size: 0.88rem;
      }

      .controls {
        display: grid;
        gap: 8px;
      }

      .control-group {
        margin-top: 8px;
        border-top: 1px solid #ececec;
        padding-top: 10px;
      }

      .group-title {
        margin: 0 0 4px 0;
        font-size: 0.82rem;
        font-weight: 700;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        color: #3f3d36;
      }

      label {
        font-size: 0.83rem;
        color: var(--ink-soft);
      }

      input,
      select,
      button {
        width: 100%;
        border-radius: 10px;
        border: 1px solid #d8d8d8;
        padding: 9px 10px;
        font: inherit;
      }

      button {
        border: 0;
        background: linear-gradient(135deg, var(--accent), #ff9d57);
        color: #111;
        font-weight: 700;
        cursor: pointer;
      }

      button.secondary {
        background: #eef2fa;
      }

      .inline {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .inline input[type="checkbox"] {
        width: auto;
      }

      .inline.depth-line input[type="range"] {
        flex: 1;
      }

      .inline.depth-line output {
        width: 32px;
        text-align: right;
        font-family: "IBM Plex Mono", monospace;
        font-size: 0.84rem;
      }

      .tiny {
        font-size: 0.76rem;
      }

      .trail,
      .hops {
        margin-top: 4px;
        font-size: 0.76rem;
        line-height: 1.35;
      }

      .stats {
        margin-top: 12px;
        border-top: 1px solid #ececec;
        padding-top: 10px;
        font-family: "IBM Plex Mono", monospace;
        font-size: 0.8rem;
        line-height: 1.45;
        color: #2a2a2a;
      }

      .legend {
        margin-top: 10px;
        display: grid;
        gap: 6px;
        font-size: 0.8rem;
      }

      .chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
      }

      #cyWrap {
        grid-area: main;
        position: relative;
        overflow: hidden;
      }

      #cy {
        width: 100%;
        height: 100%;
      }

      #detail {
        position: absolute;
        right: 14px;
        top: 14px;
        width: min(380px, calc(100% - 28px));
        max-height: calc(100% - 28px);
        overflow: auto;
        padding: 11px;
        background: rgba(255, 255, 255, 0.93);
        border: 1px solid rgba(212, 212, 212, 0.9);
        border-radius: 12px;
        box-shadow: 0 10px 18px rgba(0, 0, 0, 0.12);
        font-size: 0.84rem;
      }

      #detail h3 {
        margin: 0 0 6px 0;
      }

      #detail pre {
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
        font-family: "IBM Plex Mono", monospace;
        font-size: 0.75rem;
      }

      .muted {
        color: var(--ink-soft);
      }

      @media (max-width: 940px) {
        .page {
          grid-template-columns: 1fr;
          grid-template-rows: auto auto minmax(0, 1fr);
          grid-template-areas:
            "top"
            "side"
            "main";
          height: auto;
          min-height: 100%;
        }
        #cyWrap {
          min-height: 74vh;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <div class="superheader">
        <a class="superlink" href="/">← Índice</a>
        <a
          class="superlink"
          href="https://github.com/gsusI/vota-con-la-chola"
          target="_blank"
          rel="noopener noreferrer"
          aria-label="Ver el código en GitHub"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/>
          </svg>
          Ver el código
        </a>
      </div>
      <aside class="sidebar card">
        <h1>Graph Explorer</h1>
        <p class="subtitle">Politicos, instituciones, partidos y fuentes</p>
        <div class="view-links">
          <a class="active" href="/graph">Graph</a>
          <a href="/explorer">Explorer</a>
          <a href="/explorer-politico">Radar Político</a>
          <a href="/explorer-sources">Fuentes</a>
        </div>

        <div class="controls">
          <p class="group-title">Carga</p>
          <label for="source">Fuente</label>
          <select id="source">
            <option value="">Todas</option>
          </select>

          <label for="search">Buscar persona</label>
          <input id="search" type="text" placeholder="apellido, nombre..." />

          <label for="limit">Limite de mandatos</label>
          <input id="limit" type="number" min="20" max="2000" value="350" />

          <label class="inline">
            <input id="inactive" type="checkbox" />
            Incluir inactivos
          </label>

          <div class="inline">
            <button id="load">Cargar grafo</button>
            <button id="fit" class="secondary">Reset vista</button>
          </div>

          <div class="control-group">
            <p class="group-title">Navegacion multifaceta</p>

            <label for="lens">Lente</label>
            <select id="lens">
              <option value="all">Integral</option>
              <option value="institutional">Institucional</option>
              <option value="party">Partidos</option>
              <option value="provenance">Fuentes</option>
            </select>

            <label for="depth">Profundidad (saltos)</label>
            <div class="inline depth-line">
              <input id="depth" type="range" min="1" max="5" value="2" />
              <output id="depthValue" for="depth">2</output>
            </div>

            <div class="inline">
              <button id="focus">Enfocar nodo</button>
              <button id="overview" class="secondary">Vista global</button>
            </div>

            <button id="back" class="secondary">Subir nivel</button>

            <div id="selection" class="muted tiny">Nodo activo: ninguno</div>
            <div id="trail" class="trail muted">Ruta: global</div>
            <div id="hops" class="hops muted">Profundidad disponible tras seleccionar un nodo.</div>
          </div>
        </div>

        <div id="stats" class="stats">Cargando...</div>

        <div class="legend">
          <span class="chip"><span class="dot" style="background: var(--source)"></span> Fuente</span>
          <span class="chip"><span class="dot" style="background: var(--person)"></span> Persona</span>
          <span class="chip"><span class="dot" style="background: var(--party)"></span> Partido</span>
          <span class="chip"><span class="dot" style="background: var(--inst)"></span> Institucion</span>
        </div>
      </aside>

      <main id="cyWrap" class="card">
        <div id="cy"></div>
        <section id="detail">
          <h3>Nodo</h3>
          <pre class="muted">Haz click sobre un nodo para ver detalles.</pre>
        </section>
      </main>
    </div>

    <script>
      const state = {
        cy: null,
        sourceOptionsInitialized: false,
        allNodesById: new Map(),
        allEdges: [],
        neighborsById: new Map(),
        meta: {},
        selectedNodeId: null,
        focusNodeId: null,
        focusHistory: [],
        viewMode: "overview",
      };

      const els = {
        source: document.getElementById("source"),
        search: document.getElementById("search"),
        limit: document.getElementById("limit"),
        inactive: document.getElementById("inactive"),
        load: document.getElementById("load"),
        fit: document.getElementById("fit"),
        stats: document.getElementById("stats"),
        detail: document.getElementById("detail"),
        lens: document.getElementById("lens"),
        depth: document.getElementById("depth"),
        depthValue: document.getElementById("depthValue"),
        focus: document.getElementById("focus"),
        overview: document.getElementById("overview"),
        back: document.getElementById("back"),
        selection: document.getElementById("selection"),
        trail: document.getElementById("trail"),
        hops: document.getElementById("hops"),
      };

      function setDetail(title, body, muted = false) {
        els.detail.textContent = "";
        const h3 = document.createElement("h3");
        h3.textContent = title;
        const pre = document.createElement("pre");
        if (muted) pre.className = "muted";
        pre.textContent = body;
        els.detail.appendChild(h3);
        els.detail.appendChild(pre);
      }

      function fillSourceOptions(sources) {
        if (state.sourceOptionsInitialized) return;
        for (const src of sources || []) {
          const option = document.createElement("option");
          option.value = src.source_id;
          option.textContent = `${src.source_id} - ${src.name}`;
          els.source.appendChild(option);
        }
        state.sourceOptionsInitialized = true;
      }

      function lensAllowedTypes() {
        if (els.lens.value === "institutional") return new Set(["person", "institution"]);
        if (els.lens.value === "party") return new Set(["person", "party"]);
        if (els.lens.value === "provenance") return new Set(["person", "source"]);
        return new Set(["source", "person", "party", "institution"]);
      }

      function indexGraph(nodes, edges) {
        const nodesById = new Map();
        const neighbors = new Map();
        for (const node of nodes) {
          const id = node?.data?.id;
          if (!id) continue;
          nodesById.set(id, node);
          neighbors.set(id, new Set());
        }
        for (const edge of edges) {
          const src = edge?.data?.source;
          const dst = edge?.data?.target;
          if (!src || !dst) continue;
          if (!neighbors.has(src)) neighbors.set(src, new Set());
          if (!neighbors.has(dst)) neighbors.set(dst, new Set());
          neighbors.get(src).add(dst);
          neighbors.get(dst).add(src);
        }
        state.allNodesById = nodesById;
        state.allEdges = edges;
        state.neighborsById = neighbors;
      }

      function computeDepthMap(rootId, maxDepth) {
        const depths = new Map();
        if (!rootId || !state.neighborsById.has(rootId)) return depths;

        const queue = [rootId];
        depths.set(rootId, 0);
        for (let i = 0; i < queue.length; i += 1) {
          const nodeId = queue[i];
          const currentDepth = depths.get(nodeId) || 0;
          if (currentDepth >= maxDepth) continue;
          const neighbors = state.neighborsById.get(nodeId) || new Set();
          for (const nextId of neighbors) {
            if (depths.has(nextId)) continue;
            depths.set(nextId, currentDepth + 1);
            queue.push(nextId);
          }
        }
        return depths;
      }

      function getSubgraphElements() {
        const allowedTypes = lensAllowedTypes();
        const nodeIds = new Set(state.allNodesById.keys());
        let depthMap = new Map();

        if (state.viewMode === "focus" && state.focusNodeId) {
          const depth = Number(els.depth.value || 2);
          depthMap = computeDepthMap(state.focusNodeId, depth);
          nodeIds.clear();
          for (const id of depthMap.keys()) nodeIds.add(id);
        }

        const visibleNodeIds = new Set();
        for (const nodeId of nodeIds) {
          const node = state.allNodesById.get(nodeId);
          if (!node) continue;
          const isFocus = nodeId === state.focusNodeId;
          const type = node.data?.type || "";
          if (allowedTypes.has(type) || isFocus) {
            visibleNodeIds.add(nodeId);
          }
        }

        const edges = [];
        const degreeByNode = new Map();
        for (const edge of state.allEdges) {
          const src = edge?.data?.source;
          const dst = edge?.data?.target;
          if (!src || !dst) continue;
          if (!visibleNodeIds.has(src) || !visibleNodeIds.has(dst)) continue;
          edges.push({ data: { ...edge.data } });
          degreeByNode.set(src, (degreeByNode.get(src) || 0) + 1);
          degreeByNode.set(dst, (degreeByNode.get(dst) || 0) + 1);
        }

        const nodes = [];
        for (const nodeId of visibleNodeIds) {
          const node = state.allNodesById.get(nodeId);
          if (!node) continue;
          nodes.push({
            data: {
              ...node.data,
              degree: degreeByNode.get(nodeId) || 0,
              is_focus: nodeId === state.focusNodeId ? 1 : 0,
              ring: depthMap.get(nodeId) ?? 0,
            },
          });
        }

        return { nodes, edges, depthMap };
      }

      function buildStats(visibleNodes, visibleEdges) {
        const c = state.meta.node_counts || {};
        return [
          `db: ${state.meta.db_path || "-"}`,
          `rows: ${state.meta.rows || 0} | visible nodes: ${visibleNodes} | visible edges: ${visibleEdges}`,
          `total source=${c.source || 0} person=${c.person || 0} party=${c.party || 0} institution=${c.institution || 0}`,
          `mode: ${state.viewMode} | lens: ${els.lens.value} | depth: ${els.depth.value}`,
          `search: ${state.meta.search || "-"} | source: ${state.meta.source_filter || "all"} | limit: ${state.meta.limit || "-"}`,
        ].join("\n");
      }

      function renderTrail() {
        if (state.viewMode !== "focus" || !state.focusNodeId) {
          els.trail.textContent = "Ruta: global";
          return;
        }
        const labels = [];
        for (const nodeId of state.focusHistory) {
          const label = state.allNodesById.get(nodeId)?.data?.label || nodeId;
          labels.push(label);
        }
        const currentLabel = state.allNodesById.get(state.focusNodeId)?.data?.label || state.focusNodeId;
        labels.push(currentLabel);
        els.trail.textContent = `Ruta: ${labels.join(" -> ")}`;
      }

      function renderHopSummary(depthMap) {
        if (state.viewMode !== "focus" || !state.focusNodeId || depthMap.size === 0) {
          els.hops.textContent = "Profundidad disponible tras seleccionar un nodo.";
          return;
        }

        const byDepth = {};
        for (const depth of depthMap.values()) {
          const key = String(depth);
          byDepth[key] = (byDepth[key] || 0) + 1;
        }
        const parts = Object.keys(byDepth)
          .sort((a, b) => Number(a) - Number(b))
          .map((d) => `salto ${d}: ${byDepth[d]} nodos`);
        els.hops.textContent = parts.join(" | ");
      }

      function graphLayout() {
        if (state.viewMode === "focus" && state.focusNodeId) {
          return {
            name: "concentric",
            animate: true,
            animationDuration: 320,
            fit: true,
            padding: 36,
            minNodeSpacing: 20,
            levelWidth: () => 1,
            concentric: (node) => 200 - (node.data("ring") || 0),
          };
        }
        return {
          name: "cose",
          animate: true,
          animationDuration: 450,
          fit: true,
          padding: 40,
          idealEdgeLength: 100,
          nodeRepulsion: 450000,
          gravity: 60,
        };
      }

      async function onNodeTap(evt) {
        const data = evt.target.data();
        state.selectedNodeId = data.id || null;
        els.selection.textContent = `Nodo activo: ${data.label || data.id || "?"}`;

        if (data.type === "person" && data.person_id) {
          const personResp = await fetch(`/api/person/${data.person_id}`);
          const personPayload = await personResp.json();
          setDetail(data.label || "Persona", JSON.stringify(personPayload, null, 2));
          return;
        }
        setDetail(data.label || "Nodo", JSON.stringify(data, null, 2));
      }

      function renderGraph(elements) {
        if (state.cy) state.cy.destroy();
        state.cy = cytoscape({
          container: document.getElementById("cy"),
          elements: [...elements.nodes, ...elements.edges],
          style: [
            {
              selector: "node",
              style: {
                label: "data(label)",
                "font-family": "Space Grotesk",
                color: "#101010",
                "text-wrap": "wrap",
                "text-max-width": 130,
                "font-size": 10,
                "text-outline-width": 2,
                "text-outline-color": "#ffffff",
              },
            },
            {
              selector: 'node[type="person"]',
              style: {
                width: "mapData(degree, 0, 30, 14, 26)",
                height: "mapData(degree, 0, 30, 14, 26)",
                "background-color": "#111111",
                shape: "ellipse",
              },
            },
            {
              selector: 'node[type="source"]',
              style: {
                width: "mapData(degree, 0, 30, 20, 34)",
                height: "mapData(degree, 0, 30, 20, 34)",
                "background-color": "#ff6b35",
                shape: "diamond",
              },
            },
            {
              selector: 'node[type="party"]',
              style: {
                width: "mapData(degree, 0, 30, 18, 30)",
                height: "mapData(degree, 0, 30, 18, 30)",
                "background-color": "#2f8f54",
                shape: "round-rectangle",
              },
            },
            {
              selector: 'node[type="institution"]',
              style: {
                width: "mapData(degree, 0, 30, 20, 32)",
                height: "mapData(degree, 0, 30, 20, 32)",
                "background-color": "#275db3",
                shape: "hexagon",
              },
            },
            {
              selector: 'node[is_focus = 1]',
              style: {
                "border-width": 3,
                "border-color": "#ffbe0b",
                "text-outline-color": "#fff7df",
              },
            },
            {
              selector: "edge",
              style: {
                width: 1.2,
                opacity: 0.72,
                "line-color": "#b1b1b1",
                "curve-style": "bezier",
              },
            },
            {
              selector: 'edge[type="mandate"]',
              style: {
                "line-color": "#0b5fff",
              },
            },
            {
              selector: 'edge[type="source_person"]',
              style: {
                "line-color": "#ff6b35",
                "line-style": "dashed",
              },
            },
            {
              selector: 'edge[type="party_affiliation"]',
              style: {
                "line-color": "#2f8f54",
              },
            },
          ],
          layout: graphLayout(),
        });

        state.cy.on("tap", "node", (evt) => onNodeTap(evt).catch((err) => setDetail("Error", String(err))));
        state.cy.on("dbltap", "node", (evt) => {
          const nodeId = evt.target?.id();
          if (!nodeId) return;
          state.selectedNodeId = nodeId;
          focusOnSelected();
        });
      }

      function renderCurrentView() {
        const elements = getSubgraphElements();
        renderGraph(elements);
        els.stats.textContent = buildStats(elements.nodes.length, elements.edges.length);
        renderTrail();
        renderHopSummary(elements.depthMap);
      }

      function focusOnSelected() {
        if (!state.selectedNodeId) {
          setDetail("Navegacion", "Selecciona un nodo y pulsa \"Enfocar nodo\".", true);
          return;
        }
        if (state.focusNodeId && state.focusNodeId !== state.selectedNodeId) {
          state.focusHistory.push(state.focusNodeId);
        }
        state.focusNodeId = state.selectedNodeId;
        state.viewMode = "focus";
        renderCurrentView();
      }

      function moveFocusUp() {
        if (state.focusHistory.length === 0) {
          state.focusNodeId = null;
          state.viewMode = "overview";
          renderCurrentView();
          return;
        }
        state.focusNodeId = state.focusHistory.pop() || null;
        state.viewMode = state.focusNodeId ? "focus" : "overview";
        renderCurrentView();
      }

      function resetToOverview() {
        state.viewMode = "overview";
        state.focusNodeId = null;
        state.focusHistory = [];
        renderCurrentView();
      }

      async function loadGraph() {
        const params = new URLSearchParams();
        if (els.source.value) params.set("source_id", els.source.value);
        if (els.search.value.trim()) params.set("q", els.search.value.trim());
        params.set("limit", String(els.limit.value || 350));
        params.set("include_inactive", els.inactive.checked ? "1" : "0");
        params.set("depth", String(els.depth.value || 2));
        if (els.lens && els.lens.value) params.set("lens", String(els.lens.value));

        // Keep the page refreshable and shareable: current graph controls -> URL.
        history.replaceState({}, "", location.pathname + `?${params.toString()}`);

        setDetail("Cargando", "Consultando API...", true);
        const resp = await fetch(`/api/graph?${params.toString()}`);
        const payload = await resp.json();
        const nodes = payload.nodes || [];
        const edges = payload.edges || [];
        const meta = payload.meta || {};

        fillSourceOptions(meta.sources || []);
        state.meta = meta;
        state.selectedNodeId = null;
        state.focusNodeId = null;
        state.focusHistory = [];
        state.viewMode = "overview";
        els.selection.textContent = "Nodo activo: ninguno";

        if (meta.error) {
          setDetail("Error", meta.error);
        } else {
          setDetail("Nodo", "Click para detalle. Doble click para enfocar por profundidad.", true);
        }

        indexGraph(nodes, edges);
        renderCurrentView();
      }

      els.load.addEventListener("click", () => loadGraph().catch((err) => setDetail("Error", String(err))));
      els.fit.addEventListener("click", () => state.cy && state.cy.fit(undefined, 40));
      els.focus.addEventListener("click", () => focusOnSelected());
      els.overview.addEventListener("click", () => resetToOverview());
      els.back.addEventListener("click", () => moveFocusUp());
      els.depth.addEventListener("input", () => {
        els.depthValue.textContent = els.depth.value;
        const params = new URLSearchParams(location.search || "");
        params.set("depth", String(els.depth.value || 2));
        history.replaceState({}, "", location.pathname + `?${params.toString()}`);
        if (state.viewMode === "focus") renderCurrentView();
      });
      els.lens.addEventListener("change", () => {
        const params = new URLSearchParams(location.search || "");
        if (els.lens.value) params.set("lens", String(els.lens.value));
        history.replaceState({}, "", location.pathname + `?${params.toString()}`);
        renderCurrentView();
      });
      els.search.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter") {
          ev.preventDefault();
          loadGraph().catch((err) => setDetail("Error", String(err)));
        }
      });

      // URL -> controls so refresh/share keeps the same view parameters.
      (function applyUrlParamsToControls() {
        const params = new URLSearchParams(location.search || "");
        const sourceId = params.get("source_id");
        const q = params.get("q");
        const limit = params.get("limit");
        const includeInactive = params.get("include_inactive");
        const depth = params.get("depth");
        const lens = params.get("lens");

        if (sourceId !== null) {
          // If options haven't been populated yet, ensure the URL-provided value is selectable
          // so the initial API request can still be filtered by source_id.
          const exists = [...els.source.options].some((opt) => opt.value === sourceId);
          if (!exists) {
            const opt = document.createElement("option");
            opt.value = sourceId;
            opt.textContent = `${sourceId} (from URL)`;
            els.source.appendChild(opt);
          }
          els.source.value = sourceId;
        }
        if (q !== null) els.search.value = q;
        if (limit !== null) els.limit.value = limit;
        if (includeInactive !== null) els.inactive.checked = includeInactive === "1";
        if (depth !== null) {
          els.depth.value = depth;
          els.depthValue.textContent = depth;
        }
        if (lens !== null && els.lens) els.lens.value = lens;
      })();

      loadGraph().catch((err) => setDetail("Error", String(err)));
    </script>
  </body>
</html>
