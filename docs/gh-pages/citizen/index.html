<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Vota Con La Chola | Ciudadania</title>
    <link rel="icon" href="data:," />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,600;9..144,700&family=Manrope:wght@400;600;700;800&family=IBM+Plex+Mono:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;

        --ink: #0b1020;
        --ink-2: #24324a;
        --muted: #5b6b85;
        --muted-2: #7b8ba8;
        --panel: rgba(255, 255, 255, 0.92);
        --panel-2: rgba(255, 255, 255, 0.78);
        --line: rgba(15, 23, 42, 0.12);
        --shadow: 0 18px 52px rgba(15, 23, 42, 0.12);

        --accent: #1d4ed8;
        --accent-2: #0891b2;

        --ok: #059669;
        --warn: #d97706;
        --bad: #dc2626;

        --chip: rgba(248, 250, 252, 0.86);

        --sans: "Space Grotesk", system-ui, -apple-system, "Segoe UI", sans-serif;
        --mono: "IBM Plex Mono", ui-monospace, "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", monospace;

        --radius: 18px;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        font-family: var(--sans);
        color: var(--ink);
        background:
          radial-gradient(980px 520px at 10% -10%, #dbeafe 0%, transparent 62%),
          radial-gradient(980px 520px at 92% 12%, #cffafe 0%, transparent 58%),
          radial-gradient(980px 520px at 80% 110%, #fef3c7 0%, transparent 62%),
          linear-gradient(130deg, #f6f8ff, #ffffff);
        line-height: 1.45;
        font-size: 16px;
      }

      a {
        color: inherit;
      }

      .skipLink {
        position: absolute;
        left: -9999px;
        top: 8px;
        z-index: 20;
        border-radius: 999px;
        border: 1px solid rgba(29, 78, 216, 0.38);
        background: rgba(219, 234, 254, 0.98);
        color: #0b1b3a;
        padding: 8px 12px;
        font-size: 0.8rem;
        font-weight: 900;
        text-decoration: none;
      }

      .skipLink:focus {
        left: 12px;
        outline: none;
        box-shadow: 0 0 0 3px rgba(29, 78, 216, 0.18);
      }

      .app {
        min-height: 100%;
        padding: 14px;
        display: grid;
        grid-template-rows: auto minmax(0, 1fr) auto;
        gap: 12px;
        width: min(1560px, calc(100% - 28px));
        margin: 0 auto;
      }

      .card {
        border: 1px solid var(--line);
        border-radius: var(--radius);
        background: var(--panel);
        box-shadow: var(--shadow);
        backdrop-filter: blur(8px);
        min-width: 0;
      }

      .top {
        padding: 14px;
        position: relative;
        overflow: hidden;
      }

      .top::before {
        content: "";
        position: absolute;
        inset: -120px -200px auto auto;
        width: 520px;
        height: 520px;
        background:
          radial-gradient(circle at 30% 30%, rgba(29, 78, 216, 0.22), transparent 56%),
          radial-gradient(circle at 55% 55%, rgba(8, 145, 178, 0.18), transparent 62%),
          radial-gradient(circle at 75% 25%, rgba(217, 119, 6, 0.16), transparent 62%);
        transform: rotate(12deg);
        pointer-events: none;
      }

      .nav {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border: 1px solid rgba(29, 78, 216, 0.22);
        background: rgba(219, 234, 254, 0.58);
        border-radius: 999px;
        padding: 6px 10px;
        text-decoration: none;
        color: #0b1b3a;
        font-weight: 800;
        font-size: 0.82rem;
      }

      .pill.secondary {
        border-color: rgba(8, 145, 178, 0.22);
        background: rgba(207, 250, 254, 0.45);
      }

      .pill.neutral {
        border-color: rgba(15, 23, 42, 0.14);
        background: rgba(248, 250, 252, 0.82);
      }

      .pill:focus,
      .pill:hover {
        outline: none;
        box-shadow: 0 0 0 3px rgba(29, 78, 216, 0.18);
      }

      .hero {
        margin-top: 12px;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 12px;
        flex-wrap: wrap;
        position: relative;
        z-index: 1;
      }

      .eyebrow {
        margin: 0;
        font-size: 0.72rem;
        letter-spacing: 0.13em;
        text-transform: uppercase;
        color: var(--accent);
        font-weight: 800;
      }

      h1 {
        margin: 6px 0 4px;
        font-size: 1.9rem;
        line-height: 1.05;
      }

      .sub {
        margin: 0;
        color: var(--ink-2);
        max-width: 76ch;
      }

      .mono {
        font-family: var(--mono);
      }

      .status {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: flex-end;
      }

      .chip {
        border: 1px solid rgba(15, 23, 42, 0.14);
        background: var(--chip);
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 0.78rem;
        color: var(--ink-2);
        display: inline-flex;
        align-items: center;
        gap: 8px;
        white-space: nowrap;
      }

      .dot {
        width: 9px;
        height: 9px;
        border-radius: 999px;
        background: rgba(100, 116, 139, 0.55);
        flex: 0 0 auto;
      }

      .dot.ok {
        background: rgba(5, 150, 105, 0.9);
      }

      .dot.warn {
        background: rgba(217, 119, 6, 0.9);
      }

      .dot.bad {
        background: rgba(220, 38, 38, 0.9);
      }

      .banner {
        margin-top: 10px;
        border: 1px dashed rgba(15, 23, 42, 0.22);
        border-radius: 14px;
        padding: 10px 12px;
        background: rgba(255, 255, 255, 0.55);
        color: var(--muted);
        display: none;
        position: relative;
        z-index: 1;
      }

      .onboard {
        margin-top: 10px;
        border: 1px solid rgba(29, 78, 216, 0.24);
        border-radius: 14px;
        padding: 10px 12px;
        background:
          linear-gradient(135deg, rgba(219, 234, 254, 0.55), rgba(207, 250, 254, 0.38)),
          rgba(255, 255, 255, 0.92);
        display: none;
        position: relative;
        z-index: 1;
      }

      .onboardHead {
        display: flex;
        gap: 8px;
        align-items: flex-start;
        justify-content: space-between;
        flex-wrap: wrap;
      }

      .onboardTitle {
        margin: 0;
        font-size: 0.9rem;
        font-weight: 900;
        color: #0b1b3a;
      }

      .onboardHint {
        margin: 4px 0 0;
        color: var(--ink-2);
        font-size: 0.82rem;
      }

      .onboardSteps {
        margin-top: 8px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      .onboardActions {
        margin-top: 10px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      .layout {
        min-height: 0;
        display: grid;
        gap: 12px;
        grid-template-columns: 320px 420px minmax(0, 1fr);
      }

      @media (max-width: 1180px) {
        .layout {
          grid-template-columns: 1fr;
          grid-template-rows: auto auto minmax(0, 1fr);
        }
      }

      .panel {
        min-height: 0;
        display: flex;
        flex-direction: column;
      }

      .panel .head {
        padding: 14px 14px 8px;
      }

      .panel h2 {
        margin: 0;
        font-size: 1.02rem;
      }

      .panel .hint {
        margin: 4px 0 0;
        color: var(--muted);
        font-size: 0.84rem;
        line-height: 1.45;
      }

      .controls {
        padding: 0 14px 12px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      input[type="text"],
      select {
        border: 1px solid rgba(15, 23, 42, 0.16);
        border-radius: 12px;
        padding: 9px 10px;
        font: inherit;
        background: rgba(255, 255, 255, 0.92);
        min-width: 0;
      }

      input[type="text"]:focus-visible,
      select:focus-visible {
        outline: none;
        border-color: rgba(29, 78, 216, 0.35);
        box-shadow: 0 0 0 3px rgba(29, 78, 216, 0.16);
      }

      input[type="text"] {
        flex: 1 1 200px;
      }

      .btn {
        border: 1px solid rgba(15, 23, 42, 0.14);
        border-radius: 12px;
        padding: 9px 11px;
        font-weight: 800;
        background: rgba(248, 250, 252, 0.88);
        color: var(--ink);
        cursor: pointer;
      }

      .btn:hover,
      .btn:focus {
        outline: none;
        box-shadow: 0 0 0 3px rgba(8, 145, 178, 0.16);
      }

      .list {
        min-height: 0;
        flex: 1 1 auto;
        overflow: auto;
        padding: 0 10px 12px;
      }

      .row {
        border: 1px solid rgba(15, 23, 42, 0.1);
        background: rgba(255, 255, 255, 0.7);
        border-radius: 14px;
        padding: 12px;
        margin: 10px 4px;
        display: grid;
        gap: 8px;
        cursor: pointer;
        transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease;
        transform: translateY(0);
        opacity: 1;
        content-visibility: auto;
        contain-intrinsic-size: 84px;
      }

      .row:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.10);
        border-color: rgba(29, 78, 216, 0.18);
      }

      .row:focus-visible {
        outline: none;
        border-color: rgba(8, 145, 178, 0.42);
        box-shadow: 0 0 0 3px rgba(8, 145, 178, 0.16);
      }

      .row.active {
        border-color: rgba(29, 78, 216, 0.35);
        background: rgba(219, 234, 254, 0.32);
      }

      .rowTitle {
        display: flex;
        gap: 10px;
        align-items: flex-start;
        justify-content: space-between;
      }

      .rowTitle strong {
        font-size: 0.95rem;
      }

      .tags {
        display: inline-flex;
        gap: 6px;
        flex-wrap: wrap;
        align-items: center;
      }

      .tag {
        border: 1px solid rgba(15, 23, 42, 0.14);
        background: rgba(248, 250, 252, 0.86);
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 0.74rem;
        color: var(--muted);
        white-space: nowrap;
      }

      .tagbtn {
        cursor: pointer;
        font: inherit;
      }

      .tagbtn:hover,
      .tagbtn:focus {
        outline: none;
        box-shadow: 0 0 0 3px rgba(29, 78, 216, 0.14);
      }

      .tagbtn.active {
        border-color: rgba(29, 78, 216, 0.32);
        background: rgba(219, 234, 254, 0.52);
        color: #0b1b3a;
        font-weight: 800;
      }

      .tag.hot {
        border-color: rgba(217, 119, 6, 0.25);
        background: rgba(254, 243, 199, 0.75);
        color: #92400e;
        font-weight: 800;
      }

      .tag.good {
        border-color: rgba(5, 150, 105, 0.25);
        background: rgba(236, 253, 245, 0.95);
        color: #065f46;
        font-weight: 900;
      }

      .tag.bad {
        border-color: rgba(220, 38, 38, 0.22);
        background: rgba(254, 242, 242, 0.95);
        color: #7f1d1d;
        font-weight: 900;
      }

      .rowMeta {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
        color: var(--muted);
        font-size: 0.78rem;
      }

      .smallLink {
        color: var(--accent);
        text-decoration: none;
        font-weight: 800;
      }

      .smallLink:hover {
        text-decoration: underline;
      }

      .smallLink:focus-visible {
        outline: none;
        border-radius: 8px;
        box-shadow: 0 0 0 3px rgba(29, 78, 216, 0.16);
      }

      .compare {
        padding: 0 14px 14px;
        min-height: 0;
        flex: 1 1 auto;
        overflow: auto;
      }

      .empty {
        padding: 14px;
        color: var(--muted);
        border: 1px dashed rgba(15, 23, 42, 0.18);
        background: rgba(255, 255, 255, 0.55);
        border-radius: 14px;
      }

      .summaryGrid {
        display: grid;
        grid-template-columns: repeat(5, minmax(0, 1fr));
        gap: 10px;
        margin-bottom: 12px;
      }

      @media (max-width: 760px) {
        .summaryGrid {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }

        .app {
          padding: 10px;
          width: min(1560px, calc(100% - 20px));
          gap: 10px;
        }

        .top,
        .panel .head,
        .foot {
          padding: 12px;
        }

        .controls,
        .compare {
          padding-left: 12px;
          padding-right: 12px;
          gap: 6px;
        }

        input[type="text"],
        select,
        .btn {
          min-height: 42px;
          font-size: 16px;
        }

        .row {
          margin: 8px 2px;
          padding: 10px;
        }

        .partyCard {
          padding: 10px;
        }
      }

      .kpi {
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 14px;
        background: rgba(248, 250, 252, 0.82);
        padding: 10px;
      }

      .kpi .k {
        font-size: 0.74rem;
        color: var(--muted);
        font-weight: 800;
        letter-spacing: 0.06em;
        text-transform: uppercase;
      }

      .kpi .v {
        margin-top: 4px;
        font-size: 1.05rem;
        font-weight: 900;
        color: var(--ink);
      }

      .partyCard {
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.72);
        padding: 12px;
        display: grid;
        gap: 10px;
        margin: 10px 0;
        content-visibility: auto;
        contain-intrinsic-size: 168px;
      }

      .partyCard.focused {
        border-color: rgba(8, 145, 178, 0.32);
        background: rgba(207, 250, 254, 0.22);
      }

      .partyHead {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .partyName {
        font-weight: 900;
      }

      .stanceChip {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border-radius: 999px;
        padding: 6px 10px;
        border: 1px solid rgba(15, 23, 42, 0.12);
        background: rgba(248, 250, 252, 0.86);
        font-size: 0.78rem;
        font-weight: 900;
        color: var(--ink-2);
        white-space: nowrap;
      }

      button.stanceChip {
        cursor: pointer;
      }

      button.stanceChip:hover,
      button.stanceChip:focus {
        outline: none;
        box-shadow: 0 0 0 3px rgba(29, 78, 216, 0.14);
      }

      .stanceChip.mini {
        padding: 4px 8px;
        font-size: 0.74rem;
      }

      .stanceChip.support {
        border-color: rgba(5, 150, 105, 0.25);
        background: rgba(236, 253, 245, 0.95);
        color: #065f46;
      }

      .stanceChip.oppose {
        border-color: rgba(220, 38, 38, 0.22);
        background: rgba(254, 242, 242, 0.95);
        color: #7f1d1d;
      }

      .stanceChip.mixed {
        border-color: rgba(217, 119, 6, 0.22);
        background: rgba(255, 251, 235, 0.95);
        color: #92400e;
      }

      .stanceChip.unclear,
      .stanceChip.no_signal {
        border-color: rgba(100, 116, 139, 0.2);
        background: rgba(248, 250, 252, 0.86);
        color: var(--muted);
      }

      .barWrap {
        display: grid;
        gap: 6px;
      }

      .barLabel {
        display: flex;
        justify-content: space-between;
        color: var(--muted);
        font-size: 0.78rem;
      }

      .bar {
        height: 10px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.08);
        overflow: hidden;
      }

      .bar > div {
        height: 100%;
        border-radius: 999px;
        background: linear-gradient(90deg, rgba(29, 78, 216, 0.75), rgba(8, 145, 178, 0.75));
        width: 0;
        transition: width 0.35s ease;
      }

      .partyMeta {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        color: var(--muted);
        font-size: 0.78rem;
      }

      .partyNarrative {
        margin: 8px 0 0;
        color: #6d5347;
        font-size: 0.84rem;
        line-height: 1.45;
      }

      .mismatchPanel {
        margin-top: 12px;
        border: 1px solid #e7cdbc;
        border-radius: 16px;
        background:
          linear-gradient(180deg, rgba(255, 249, 245, 0.98), rgba(255, 241, 234, 0.94)),
          #fff;
        padding: 11px 12px;
      }

      .mismatchList {
        margin: 8px 0 0;
        padding-left: 18px;
        color: #5f453a;
        font-size: 0.84rem;
      }

      .mismatchList li {
        margin: 6px 0;
      }

      .explainGlossary {
        margin-top: 8px;
        border: 1px dashed rgba(15, 23, 42, 0.2);
        border-radius: 12px;
        padding: 8px 10px;
        background: rgba(248, 250, 252, 0.72);
      }

      .explainGlossary summary {
        cursor: pointer;
        font-size: 0.8rem;
        font-weight: 800;
        color: var(--ink-2);
      }

      .explainGlossary summary:focus-visible {
        outline: none;
        border-radius: 8px;
        box-shadow: 0 0 0 3px rgba(29, 78, 216, 0.16);
      }

      .explainGlossaryList {
        margin: 8px 0 0;
        padding-left: 18px;
        color: var(--muted);
        font-size: 0.8rem;
        line-height: 1.42;
      }

      .explainGlossaryList li {
        margin: 4px 0;
      }

      .foot {
        padding: 14px;
        color: var(--muted);
        font-size: 0.9rem;
        line-height: 1.5;
      }

      .foot strong {
        color: var(--ink-2);
      }

      .fadeIn {
        animation: fadeInUp 0.35s ease both;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(6px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .fadeIn {
          animation: none;
        }

        .row,
        .bar > div {
          transition: none;
        }
      }
    </style>
    <link rel="stylesheet" href="./tailwind_md3.generated.css" />
    <style id="joe-gebbia-refresh">
      :root {
        color-scheme: light;
        --ink: #2e1f1a;
        --ink-2: #4a342d;
        --muted: #6f5a52;
        --muted-2: #8c7468;
        --panel: #fffefc;
        --panel-2: #fff8f3;
        --line: #ecd9ce;
        --line-strong: #dcbfb0;
        --shadow: 0 24px 60px rgba(78, 46, 33, 0.12);

        --accent: #ff5a5f;
        --accent-2: #de3151;
        --accent-soft: #ffe9e5;
        --accent-ink: #74231f;

        --ok: #2f7d5b;
        --warn: #cb7a18;
        --bad: #b8383b;
        --chip: #fff7f2;

        --sans: "Manrope", "Space Grotesk", system-ui, -apple-system, "Segoe UI", sans-serif;
        --display: "Fraunces", Georgia, "Times New Roman", serif;
        --mono: "IBM Plex Mono", ui-monospace, "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      }

      body {
        color: var(--ink);
        font-family: var(--sans);
        line-height: 1.55;
        background:
          radial-gradient(920px 540px at 8% -16%, #ffe8df 0%, transparent 64%),
          radial-gradient(920px 540px at 92% 8%, #ffe6dd 0%, transparent 60%),
          linear-gradient(140deg, #fffaf6, #fffefc);
        font-size: 16px;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 0;
        background-image:
          linear-gradient(transparent 23px, rgba(120, 86, 72, 0.035) 24px),
          linear-gradient(90deg, transparent 23px, rgba(120, 86, 72, 0.03) 24px);
        background-size: 24px 24px, 24px 24px;
        mask-image: radial-gradient(circle at 50% 40%, black 22%, transparent 86%);
      }

      .app {
        width: min(1520px, calc(100% - 40px));
        padding: 20px 0 24px;
        gap: 16px;
        position: relative;
        z-index: 1;
      }

      .card,
      .md3-card {
        border: 1px solid var(--line);
        border-radius: 24px;
        background:
          linear-gradient(180deg, rgba(255, 255, 255, 0.98), rgba(255, 247, 241, 0.95)),
          var(--panel);
        box-shadow: var(--shadow);
        backdrop-filter: none;
      }

      .skipLink {
        border-color: rgba(222, 49, 81, 0.36);
        background: #fff6f3;
        color: var(--accent-ink);
        font-weight: 800;
      }

      .skipLink:focus {
        box-shadow: 0 0 0 3px rgba(255, 90, 95, 0.18);
      }

      .top {
        padding: 24px;
        overflow: hidden;
        background:
          linear-gradient(160deg, rgba(255, 255, 255, 0.97), rgba(255, 244, 236, 0.95)),
          var(--panel);
      }

      .top::before {
        inset: -190px -140px auto auto;
        width: 560px;
        height: 560px;
        transform: rotate(10deg);
        background:
          radial-gradient(circle at 28% 30%, rgba(255, 90, 95, 0.3), transparent 56%),
          radial-gradient(circle at 55% 58%, rgba(222, 49, 81, 0.22), transparent 64%),
          radial-gradient(circle at 72% 24%, rgba(255, 180, 136, 0.2), transparent 62%);
      }

      .nav {
        gap: 10px;
      }

      .pill {
        border: 1px solid var(--line);
        background: #fff;
        color: var(--ink-2);
        border-radius: 999px;
        padding: 7px 12px;
        font-size: 0.78rem;
        font-weight: 800;
        letter-spacing: 0.01em;
        transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
      }

      .pill.secondary {
        border-color: #f0cabc;
        background: #fff4ee;
      }

      .pill.neutral {
        border-color: var(--line);
        background: #fffaf7;
      }

      .pill:hover,
      .pill:focus-visible {
        border-color: rgba(255, 90, 95, 0.45);
        box-shadow: 0 0 0 3px rgba(255, 90, 95, 0.16);
        transform: translateY(-1px);
      }

      .hero {
        margin-top: 14px;
        gap: 16px;
        align-items: flex-end;
      }

      .eyebrow {
        font-family: var(--mono);
        font-size: 0.67rem;
        font-weight: 600;
        letter-spacing: 0.18em;
        color: var(--accent-2);
      }

      h1 {
        margin: 8px 0 6px;
        font-family: var(--display);
        font-size: clamp(2rem, 2.5vw, 2.85rem);
        line-height: 1.04;
        letter-spacing: -0.01em;
        color: #2d1f1a;
      }

      .sub {
        max-width: 74ch;
        color: var(--muted);
        font-size: 1rem;
      }

      .status {
        gap: 10px;
      }

      .modeSwitch {
        margin-top: 10px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px;
        border: 1px solid #ecd5c9;
        border-radius: 999px;
        background: #fff8f3;
      }

      .modeBtn {
        border: 1px solid transparent;
        border-radius: 999px;
        background: transparent;
        color: #6b5145;
        font: inherit;
        font-size: 0.76rem;
        font-weight: 800;
        letter-spacing: 0.01em;
        padding: 6px 10px;
        cursor: pointer;
      }

      .modeBtn.is-active {
        border-color: #efc2b2;
        background: #fff;
        color: #3c261f;
        box-shadow: 0 8px 18px rgba(90, 60, 49, 0.08);
      }

      .modeBtn:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px rgba(255, 90, 95, 0.16);
      }

      .modeHint {
        margin: 8px 0 0;
        color: #6f594f;
        font-size: 0.8rem;
      }

      .chip,
      .md3-chip {
        border-color: #edd5c8;
        background: var(--chip);
        color: #5f4b43;
        font-size: 0.74rem;
        font-weight: 700;
        padding: 6px 10px;
      }

      .dot {
        width: 8px;
        height: 8px;
      }

      .dot.ok {
        background: var(--ok);
      }

      .dot.warn {
        background: var(--warn);
      }

      .dot.bad {
        background: var(--bad);
      }

      .banner {
        border: 1px solid #efc8b6;
        border-radius: 14px;
        background: #fff8f3;
        color: var(--ink-2);
      }

      .onboard {
        border: 1px solid #efc8b6;
        border-radius: 16px;
        background:
          linear-gradient(135deg, rgba(255, 233, 224, 0.7), rgba(255, 245, 238, 0.85)),
          #fffaf6;
        padding: 12px 14px;
      }

      .onboardTitle {
        color: #4a2f27;
        font-weight: 800;
      }

      .onboardHint {
        color: var(--muted);
      }

      .layout {
        grid-template-columns: minmax(320px, 0.9fr) minmax(380px, 1.1fr);
        grid-template-areas:
          "concern items"
          "compare compare";
        gap: 16px;
      }

      .panelConcern {
        grid-area: concern;
      }

      .panelItems {
        grid-area: items;
      }

      .panelCompare {
        grid-area: compare;
      }

      .experience {
        padding: 20px;
        position: relative;
        overflow: hidden;
        background:
          linear-gradient(150deg, rgba(255, 255, 255, 0.98), rgba(255, 243, 235, 0.95)),
          var(--panel);
      }

      .experience::before {
        content: "";
        position: absolute;
        inset: auto -120px -180px auto;
        width: 420px;
        height: 420px;
        pointer-events: none;
        background:
          radial-gradient(circle at 40% 40%, rgba(255, 90, 95, 0.18), transparent 64%),
          radial-gradient(circle at 60% 60%, rgba(222, 49, 81, 0.14), transparent 62%);
      }

      .experienceRail {
        display: grid;
        grid-template-columns: minmax(320px, 1.35fr) minmax(280px, 1fr) minmax(260px, 1fr);
        gap: 14px;
        align-items: stretch;
        position: relative;
        z-index: 1;
      }

      .journeyIntro {
        border: 1px solid #edd7cb;
        border-radius: 18px;
        background: #fffdfa;
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .journeyTitle {
        margin: 0;
        font-family: var(--display);
        font-size: clamp(1.22rem, 1.8vw, 1.58rem);
        line-height: 1.12;
        color: #321f18;
      }

      .journeyNarrative {
        margin: 0;
        color: var(--muted);
        font-size: 0.92rem;
      }

      .journeyProgressWrap {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      .journeyProgressBar {
        flex: 1 1 180px;
        min-width: 150px;
        height: 8px;
        border-radius: 999px;
        background: #f4e7df;
        overflow: hidden;
      }

      .journeyProgressBar > div {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #ff7a59, #de3151);
        transition: width 0.22s ease;
      }

      .journeyProgressText {
        font-size: 0.78rem;
        font-weight: 800;
        color: #5b3d32;
      }

      .journeyDecision {
        border: 1px solid #efd7cc;
        border-radius: 16px;
        padding: 12px;
        background: #fff7f2;
      }

      .journeyDecisionHead {
        margin: 0 0 6px;
        font-size: 0.72rem;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: #b14e43;
        font-weight: 800;
      }

      .journeyDecisionTitle {
        margin: 0;
        color: #37241d;
        font-size: 1rem;
        font-weight: 800;
      }

      .journeyDecisionBody {
        margin: 6px 0 0;
        color: #6b5348;
        font-size: 0.86rem;
      }

      .journeyDecisionTags {
        margin-top: 10px;
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }

      .journeyDecisionLinks {
        margin-top: 9px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .journeySteps {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
      }

      .journeyStep {
        border: 1px solid #ecd8cd;
        border-radius: 16px;
        background: #fffdfa;
        padding: 10px 12px;
        display: flex;
        align-items: flex-start;
        gap: 9px;
        transition: border-color 0.16s ease, box-shadow 0.16s ease, transform 0.16s ease;
      }

      .journeyStepNum {
        flex: 0 0 auto;
        width: 24px;
        height: 24px;
        border-radius: 999px;
        border: 1px solid #e6c8b9;
        background: #fff5ef;
        color: #8f4036;
        font-size: 0.75rem;
        font-weight: 800;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .journeyStepText strong {
        display: block;
        color: #3b261e;
        font-size: 0.88rem;
      }

      .journeyStepText span {
        display: block;
        margin-top: 2px;
        font-size: 0.76rem;
        color: #7d6559;
      }

      .journeyStep.is-active {
        border-color: rgba(255, 90, 95, 0.5);
        box-shadow: 0 0 0 3px rgba(255, 90, 95, 0.13);
        transform: translateY(-1px);
      }

      .journeyStep.is-done {
        border-color: #b8dbc8;
        background: #f2fbf6;
      }

      .journeyStep.is-done .journeyStepNum {
        border-color: #b8dbc8;
        background: #e8f7ef;
        color: #1f6647;
      }

      .journeyActions {
        border: 1px solid #ebd5c8;
        border-radius: 18px;
        background: #fffdfa;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .journeyActions .hint {
        margin: 0;
        font-size: 0.78rem;
      }

      .advancedControls {
        margin: 0 18px 12px;
        border: 1px dashed #e8cdbf;
        border-radius: 14px;
        background: #fffaf6;
        padding: 8px 10px;
      }

      .advancedControls summary {
        cursor: pointer;
        font-weight: 800;
        color: #5f4034;
        font-size: 0.8rem;
      }

      .advancedControls[open] summary {
        margin-bottom: 6px;
      }

      .panel .head {
        padding: 18px 18px 10px;
        border-bottom: 1px solid rgba(236, 217, 206, 0.75);
      }

      .panel h2 {
        font-size: 1.06rem;
        color: #3b251e;
      }

      .panel .hint {
        color: var(--muted);
      }

      .controls {
        padding: 12px 18px;
        gap: 9px;
      }

      input[type="text"],
      input[type="search"],
      select {
        border: 1px solid var(--line-strong);
        border-radius: 14px;
        background: #fff;
        color: #3f2922;
        padding: 10px 12px;
        font: inherit;
      }

      input[type="text"]:focus-visible,
      input[type="search"]:focus-visible,
      select:focus-visible,
      .md3-tab:focus-visible {
        border-color: rgba(255, 90, 95, 0.6);
        box-shadow: 0 0 0 3px rgba(255, 90, 95, 0.16);
      }

      .btn,
      .md3-button {
        border: 1px solid var(--line-strong);
        border-radius: 14px;
        background: #fff;
        color: #422b23;
        padding: 9px 12px;
        font-weight: 800;
        letter-spacing: 0.01em;
        transition: transform 0.14s ease, box-shadow 0.14s ease, border-color 0.14s ease;
      }

      .btn:hover,
      .btn:focus-visible,
      .md3-button:hover,
      .md3-button:focus-visible {
        border-color: rgba(255, 90, 95, 0.5);
        box-shadow: 0 0 0 3px rgba(255, 90, 95, 0.16);
        transform: translateY(-1px);
      }

      .btn:disabled,
      .md3-button:disabled {
        opacity: 0.52;
        cursor: not-allowed;
        transform: none;
      }

      .list {
        padding: 8px 14px 16px;
      }

      .list::-webkit-scrollbar,
      .compare::-webkit-scrollbar {
        width: 10px;
      }

      .list::-webkit-scrollbar-thumb,
      .compare::-webkit-scrollbar-thumb {
        background: #e8d4c8;
        border-radius: 999px;
      }

      .row {
        border: 1px solid #ecd9cf;
        border-radius: 18px;
        background: #fff;
        box-shadow: 0 12px 26px rgba(82, 56, 45, 0.08);
        padding: 13px;
        margin: 10px 3px;
      }

      .row:hover {
        border-color: rgba(255, 90, 95, 0.36);
        box-shadow: 0 18px 34px rgba(82, 56, 45, 0.11);
      }

      .row:focus-visible {
        border-color: rgba(255, 90, 95, 0.52);
        box-shadow: 0 0 0 3px rgba(255, 90, 95, 0.16);
      }

      .row.active {
        border-color: rgba(255, 90, 95, 0.52);
        background:
          linear-gradient(180deg, #fff4ee, #fffdfb),
          #fff;
      }

      .rowTitle strong {
        font-weight: 800;
        color: #2e2019;
      }

      .topicRow .rowTitle strong {
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .consumerAnswer {
        margin-bottom: 12px;
        border: 1px solid #edd5c7;
        border-radius: 18px;
        background:
          linear-gradient(180deg, rgba(255, 255, 255, 0.96), rgba(255, 245, 238, 0.92)),
          #fff;
        padding: 12px 14px;
      }

      .consumerAnswer h3 {
        margin: 0;
        font-size: 1.02rem;
        color: #37231b;
      }

      .consumerAnswer p {
        margin: 8px 0 0;
        color: #664f44;
        font-size: 0.88rem;
      }

      .consumerAnswerActions {
        margin-top: 10px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .consumerDecision {
        margin-bottom: 12px;
        border: 1px solid #e8c9b8;
        border-radius: 18px;
        background:
          radial-gradient(circle at 100% 0, rgba(255, 203, 173, 0.34), transparent 52%),
          linear-gradient(180deg, #fff9f4, #fff4ec);
        padding: 13px 14px;
      }

      .consumerDecision h3 {
        margin: 2px 0 0;
        font-size: 1.04rem;
        color: #341d14;
      }

      .consumerDecision p {
        margin: 8px 0 0;
        color: #6a5044;
        font-size: 0.89rem;
      }

      .consumerDecisionHint {
        margin-top: 8px;
        color: #7b5948;
        font-size: 0.84rem;
      }

      .consumerDecisionActions {
        margin-top: 10px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      .tag {
        border: 1px solid #ebd8cd;
        background: #fff8f2;
        color: #6e564b;
        font-size: 0.72rem;
        font-weight: 700;
        padding: 3px 8px;
      }

      .tagbtn.active {
        border-color: rgba(255, 90, 95, 0.5);
        background: #ffeae5;
        color: #7a2623;
      }

      .tag.hot {
        border-color: #f0cc9a;
        background: #fff3de;
        color: #9a5f12;
      }

      .tag.good {
        border-color: #bcdcc8;
        background: #eef9f2;
        color: #206445;
      }

      .tag.bad {
        border-color: #efc0c0;
        background: #fff1f1;
        color: #8f2828;
      }

      .rowMeta {
        color: var(--muted);
      }

      .smallLink {
        color: #c03f49;
        font-weight: 800;
      }

      .smallLink:hover {
        color: #9c2732;
      }

      .smallLink:focus-visible {
        box-shadow: 0 0 0 3px rgba(255, 90, 95, 0.16);
      }

      .compare {
        padding: 8px 18px 18px;
      }

      .empty {
        border: 1px dashed #e8cdbf;
        background: #fff8f2;
        color: #6d5348;
        border-radius: 16px;
      }

      .summaryGrid {
        gap: 12px;
      }

      .kpi {
        border: 1px solid #ebd8ce;
        border-radius: 16px;
        background: #fff;
        box-shadow: 0 10px 20px rgba(70, 48, 39, 0.07);
      }

      .kpi .k {
        color: #7f6458;
      }

      .kpi .v {
        color: #2e2018;
      }

      .partyCard {
        border: 1px solid #ecd8ce;
        border-radius: 18px;
        background: #fff;
        box-shadow: 0 14px 28px rgba(77, 53, 43, 0.08);
      }

      .partyCard.focused {
        border-color: rgba(255, 90, 95, 0.5);
        background:
          linear-gradient(180deg, #fff4ee, #fffdfb),
          #fff;
      }

      .partyName {
        color: #30211a;
        font-weight: 800;
      }

      .stanceChip {
        border-color: #ead7cd;
        background: #fff9f5;
        color: #614b40;
        font-weight: 800;
      }

      .stanceChip.support {
        border-color: #b9dbc7;
        background: #ebf9f1;
        color: #1f6647;
      }

      .stanceChip.oppose {
        border-color: #edc4c4;
        background: #fff0f0;
        color: #8d2d2f;
      }

      .stanceChip.mixed {
        border-color: #efcfac;
        background: #fff6e6;
        color: #9c6318;
      }

      .bar {
        background: #f4e5db;
      }

      .bar > div {
        background: linear-gradient(90deg, #ff7a59, #de3151);
      }

      .topicCompareCard {
        border-color: #ebd3c6;
        background:
          linear-gradient(180deg, rgba(255, 255, 255, 0.98), rgba(255, 249, 244, 0.9)),
          #fff;
      }

      .topicCompareCard .partyHead {
        align-items: flex-start;
      }

      .topicCompareCard .partyName {
        font-size: 1rem;
        letter-spacing: 0.01em;
      }

      .topicScales {
        display: grid;
        gap: 10px;
      }

      .topicScale {
        display: grid;
        gap: 6px;
      }

      .topicScaleHead {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 10px;
        font-size: 0.77rem;
        color: #6a5247;
      }

      .topicScaleHead strong {
        color: #4c3228;
        font-weight: 800;
      }

      .topicScaleTrack {
        width: 100%;
        height: 12px;
        border-radius: 999px;
        overflow: hidden;
        background: #f3e4db;
        display: flex;
      }

      .topicScaleSignal {
        height: 100%;
        transition: width 0.26s ease;
      }

      .topicScaleSignal.support {
        background: linear-gradient(90deg, #3ba776, #2f8f64);
      }

      .topicScaleSignal.oppose {
        background: linear-gradient(90deg, #e77a7e, #d64b55);
      }

      .topicScaleSignal.mixed {
        background: linear-gradient(90deg, #efc56f, #e39b38);
      }

      .topicScaleSignal.unclear,
      .topicScaleSignal.no_signal {
        background: linear-gradient(90deg, #b9a79c, #9f8d82);
      }

      .topicScaleUnknown {
        height: 100%;
        background: #e9ddd5;
      }

      .topicScaleWeightTrack {
        width: 100%;
        height: 10px;
        border-radius: 999px;
        overflow: hidden;
        background: #efe3db;
      }

      .topicScaleWeightFill {
        height: 100%;
        border-radius: inherit;
        background: linear-gradient(90deg, #ff7a59, #de3151);
        transition: width 0.26s ease;
      }

      .topicScaleHint {
        font-size: 0.73rem;
        color: #7a6258;
      }

      .partyMeta {
        color: #6f574d;
      }

      .explainGlossary {
        border: 1px dashed #e8cbbd;
        background: #fff9f4;
      }

      .explainGlossary summary {
        color: #58392f;
      }

      .explainGlossaryList {
        color: #6f584d;
      }

      .foot {
        padding: 18px 20px;
        border-radius: 20px;
        color: #715c52;
        background:
          linear-gradient(180deg, rgba(255, 255, 255, 0.96), rgba(255, 245, 238, 0.92)),
          #fff;
      }

      .foot strong {
        color: #51362c;
      }

      .fadeIn {
        animation: gebbiaFadeIn 0.34s ease both;
      }

      @keyframes gebbiaFadeIn {
        from {
          opacity: 0;
          transform: translateY(8px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 1280px) {
        .layout {
          grid-template-columns: 1fr;
          grid-template-areas:
            "concern"
            "items"
            "compare";
          grid-template-rows: auto auto minmax(0, 1fr);
        }

        .experienceRail {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 860px) {
        .app {
          width: calc(100% - 22px);
          padding: 12px 0 18px;
          gap: 12px;
        }

        .top,
        .panel .head,
        .foot {
          padding: 14px;
        }

        .controls,
        .compare {
          padding-left: 14px;
          padding-right: 14px;
        }

        h1 {
          font-size: clamp(1.6rem, 7.3vw, 2.15rem);
        }

        .summaryGrid {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }

        .experience {
          padding: 14px;
        }

        .journeyActions .btn {
          width: 100%;
          justify-content: center;
        }

        .advancedControls {
          margin-left: 14px;
          margin-right: 14px;
        }
      }
    </style>
  </head>
  <body class="tw-font-sans">
    <div class="app tw-gap-3">
      <a class="skipLink" href="#citizenMain">Saltar al contenido principal</a>
      <header class="top card fadeIn md3-card">
        <div class="nav">
          <a class="pill" href="../">Exploradores</a>
          <a class="pill secondary" href="../explorer-temas/">Temas</a>
          <a class="pill neutral" href="../explorer/">Explorer SQL</a>
          <a class="pill neutral" href="../explorer-sources/">Fuentes</a>
          <a class="pill neutral" href="leaderboards.html">Leaderboards</a>
        </div>

        <div class="hero">
          <div>
            <p class="eyebrow">Ciudadania</p>
            <h1>Que hicieron sobre lo que te importa</h1>
            <p class="sub">
              Elige una preocupacion. Veras items concretos (hoy: iniciativas/votaciones) y un resumen por partido.
              Cada tarjeta enlaza a evidencia para auditar.
              <strong>No hay ranking magico</strong>.
            </p>
          </div>
          <div class="status" id="statusChips" role="status" aria-live="polite" aria-atomic="true">
            <span class="chip md3-chip"><span class="dot warn"></span><span class="mono">cargando datos…</span></span>
          </div>
        </div>

        <div class="modeSwitch" id="experienceModeSwitch" role="group" aria-label="Modo de experiencia">
          <button class="modeBtn is-active" type="button" data-experience-mode="consumer">Modo ciudadano</button>
          <button class="modeBtn" type="button" data-experience-mode="audit">Modo auditoria</button>
        </div>
        <p class="modeHint" id="experienceModeHint">
          Modo ciudadano: primero respuesta util, luego detalle. Cambia a auditoria para ver telemetria y tablas completas.
        </p>

        <div class="banner" id="banner" role="status" aria-live="polite" aria-atomic="true"></div>
        <div class="onboard" id="onboard" role="region" aria-label="Guia de inicio"></div>
      </header>

      <section class="experience card md3-card fadeIn" id="experienceFlow" style="animation-delay: 0.05s" aria-label="Ruta guiada">
        <div class="experienceRail">
          <div class="journeyIntro">
            <p class="eyebrow">Flujo guiado</p>
            <h2 class="journeyTitle">Del problema ciudadano a una decision auditable</h2>
            <p class="journeyNarrative" id="journeyNarrative">
              Empieza con una preocupacion, abre un caso concreto y contrasta partidos con evidencia verificable.
            </p>
            <div class="journeyProgressWrap">
              <div class="journeyProgressBar"><div id="journeyProgressFill"></div></div>
              <span class="journeyProgressText mono" id="journeyProgressText">0/4</span>
            </div>
            <div class="journeyDecision" id="journeyDecisionCard">
              <p class="journeyDecisionHead">Lectura actual</p>
              <p class="journeyDecisionTitle" id="journeyDecisionTitle">Selecciona una preocupacion para empezar.</p>
              <p class="journeyDecisionBody" id="journeyDecisionBody">
                Esta capa abstrae la data a decisiones: prioridad, caso, postura personal y comparacion de partidos.
              </p>
              <div class="journeyDecisionTags" id="journeyDecisionTags"></div>
              <div class="journeyDecisionLinks" id="journeyDecisionLinks"></div>
            </div>
          </div>

          <ol class="journeySteps" id="journeySteps" aria-label="Pasos del recorrido">
            <li class="journeyStep" id="journeyStepConcern" data-step="1">
              <span class="journeyStepNum">1</span>
              <div class="journeyStepText">
                <strong>Define prioridad</strong>
                <span data-step-status>Elige la preocupacion principal.</span>
              </div>
            </li>
            <li class="journeyStep" id="journeyStepTopic" data-step="2">
              <span class="journeyStepNum">2</span>
              <div class="journeyStepText">
                <strong>Abre un caso</strong>
                <span data-step-status>Escoge un item concreto para evitar ruido.</span>
              </div>
            </li>
            <li class="journeyStep" id="journeyStepPreference" data-step="3">
              <span class="journeyStepNum">3</span>
              <div class="journeyStepText">
                <strong>Marca tu postura</strong>
                <span data-step-status>Activa match/mismatch segun tu criterio.</span>
              </div>
            </li>
            <li class="journeyStep" id="journeyStepCompare" data-step="4">
              <span class="journeyStepNum">4</span>
              <div class="journeyStepText">
                <strong>Compara y audita</strong>
                <span data-step-status>Contrasta partidos y abre evidencia.</span>
              </div>
            </li>
          </ol>

          <div class="journeyActions">
            <p class="hint">Atajos de experiencia</p>
            <button class="btn md3-button" id="journeyNextAction" type="button" data-journey-action="next_step">Siguiente paso</button>
            <button class="btn md3-button" id="journeyFirstAnswerAction" type="button" data-journey-action="first_answer">
              Aplicar respuesta rapida
            </button>
            <button class="btn md3-button" type="button" data-journey-scroll="#concernSectionHeading">Ir a prioridades</button>
            <button class="btn md3-button" type="button" data-journey-scroll="#itemsSectionHeading">Ir a casos</button>
            <button class="btn md3-button" type="button" data-journey-scroll="#compareSectionHeading">Ir a comparacion</button>
            <button class="btn md3-button" type="button" data-journey-action="share_preset">Compartir preset</button>
          </div>
        </div>
      </section>

      <main class="layout fadeIn" style="animation-delay: 0.08s" id="citizenMain" tabindex="-1" aria-label="Panel principal de comparacion">
        <section class="panel panelConcern card md3-card" id="stepConcern" aria-labelledby="concernSectionHeading">
          <div class="head">
            <h2 id="concernSectionHeading">1) Preocupacion</h2>
            <p class="hint">Define primero el problema ciudadano. Luego todo el flujo se filtra y simplifica alrededor de esa prioridad.</p>
          </div>
          <div class="controls" style="align-items: flex-start">
            <div style="flex: 1 1 240px; min-width: 0">
              <div class="hint" style="margin: 0 0 6px">Mis preocupaciones (dashboard)</div>
              <div class="tags" id="selectedConcernTags"></div>
            </div>
            <button class="btn md3-button" id="btnResetSelected" type="button">Reset</button>
          </div>
          <div class="controls" style="padding-top: 0">
            <div style="flex: 1 1 100%; min-width: 0">
              <div class="hint" style="margin: 0 0 6px">Packs rapidos (multi-concern)</div>
              <div class="tags" id="concernPackTags"></div>
              <div class="hint" id="concernPackHint" style="margin: 6px 0 0"></div>
            </div>
          </div>
          <div class="controls">
            <input id="concernSearch" type="text" aria-label="Buscar preocupaciones" placeholder="Filtra preocupaciones…" />
            <button class="btn md3-button" id="btnClear" type="button">Limpiar</button>
          </div>
          <div class="list" id="concernList" role="list" aria-label="Lista de preocupaciones"></div>
        </section>

        <section class="panel panelItems card md3-card" id="stepItems" aria-labelledby="itemsSectionHeading">
          <div class="head">
            <h2 id="itemsSectionHeading">2) Items</h2>
            <p class="hint">Trabaja sobre un caso concreto: evita promedios abstractos y prioriza casos auditables.</p>
          </div>
          <div class="controls">
            <input id="topicSearch" type="text" aria-label="Buscar items por titulo" placeholder="Busca en el titulo…" />
            <select class="md3-tab" id="topicLimit" aria-label="Limite de items">
              <option value="20" selected>20</option>
              <option value="40">40</option>
              <option value="60">60</option>
            </select>
            <button class="btn md3-button" id="btnPartyFocusClear" type="button" style="display: none">
              Salir foco partido
            </button>
            <span class="chip md3-chip" id="partyFocusChip" style="display: none">
              <span class="dot ok"></span><span>foco</span><span class="mono" id="partyFocusName"></span>
            </span>
          </div>
          <div class="list" id="topicList" role="list" aria-label="Lista de items"></div>
        </section>

        <section class="panel panelCompare card md3-card" id="stepCompare" aria-labelledby="compareSectionHeading">
          <div class="head">
            <h2 id="compareSectionHeading">3) Comparar por partido</h2>
            <p class="hint">
              Aqui conviertes la data en decision: compara postura, cobertura y confianza, y luego abre evidencia cuando haya duda.
            </p>
            <details class="explainGlossary" data-explainability-glossary="1" aria-label="Glosario rapido para leer resultados">
              <summary data-explainability-copy="1">Glosario rapido: primero mira cobertura y luego abre evidencia.</summary>
              <div class="rowMeta" data-explainability-glossary-tags="1">
                <span
                  class="tag"
                  data-explainability-term="unknown"
                  data-explainability-tooltip="1"
                  data-term-definition="Unknown significa incierto mas sin senal."
                  title="Unknown significa incierto mas sin senal."
                  >unknown</span
                >
                <span
                  class="tag"
                  data-explainability-term="cobertura"
                  data-explainability-tooltip="1"
                  data-term-definition="Cobertura es cuantos casos tienen postura clara."
                  title="Cobertura es cuantos casos tienen postura clara."
                  >cobertura</span
                >
                <span
                  class="tag"
                  data-explainability-term="confianza"
                  data-explainability-tooltip="1"
                  data-term-definition="Confianza indica cuanta evidencia respalda el resumen."
                  title="Confianza indica cuanta evidencia respalda el resumen."
                  >confianza</span
                >
                <span
                  class="tag"
                  data-explainability-term="evidencia"
                  data-explainability-tooltip="1"
                  data-term-definition="Evidencia abre la fuente original para auditoria."
                  title="Evidencia abre la fuente original para auditoria."
                  >evidencia</span
                >
              </div>
              <ul class="explainGlossaryList" data-explainability-glossary-list="1">
                <li data-explainability-copy="1">Unknown: incierto mas sin senal. No implica apoyo ni rechazo.</li>
                <li data-explainability-copy="1">Cobertura alta reduce dudas. Cobertura baja exige revisar links.</li>
                <li data-explainability-copy="1">Confianza alta no reemplaza auditoria. Siempre puedes abrir evidencia.</li>
              </ul>
            </details>
          </div>
          <div class="controls">
            <select class="md3-tab" id="viewMode" aria-label="Vista">
              <option value="detail" selected>Vista: detalle</option>
              <option value="dashboard">Vista: mi dashboard</option>
              <option value="alignment">Vista: alineamiento</option>
              <option value="coherence">Vista: coherencia</option>
            </select>
            <select class="md3-tab" id="methodSelect" aria-label="Metodo">
              <option value="combined" selected>Metodo: combinado (prioriza votos)</option>
              <option value="votes">Metodo: hechos (votos)</option>
              <option value="declared">Metodo: dichos (intervenciones)</option>
            </select>
          </div>
          <details class="advancedControls">
            <summary>Opciones avanzadas</summary>
            <div class="controls" style="padding: 0">
              <select class="md3-tab" id="stanceFilter" aria-label="Filtro por stance">
                <option value="all" selected>Todos</option>
                <option value="support">A favor</option>
                <option value="oppose">En contra</option>
                <option value="mixed">Mixto</option>
                <option value="unclear">Incierto</option>
                <option value="no_signal">Sin senal</option>
              </select>
              <select class="md3-tab" id="partySort" aria-label="Orden de partidos">
                <option value="name" selected>Orden: nombre</option>
                <option value="coverage">Orden: cobertura</option>
                <option value="confidence">Orden: confianza</option>
              </select>
            </div>
          </details>
          <div class="compare" id="compare" role="region" aria-label="Resultados por partido"></div>
        </section>
      </main>

      <footer class="foot card fadeIn" style="animation-delay: 0.14s">
        <strong>Como leer esto:</strong> “A favor / En contra / Mixto” viene de agregar posiciones de diputados del partido.
        Si la cobertura es baja, mostramos <strong>Incierto</strong>. Si no hay datos, mostramos <strong>Sin senal</strong>.
        En <strong>combinado</strong> priorizamos <strong>votos</strong>; si no hay votos, usamos <strong>dichos</strong>.
        “Programa” viene de textos (promesas) y es mas incierto por defecto. Usa los links de auditoria para ver filas y evidencia.
      </footer>
    </div>

    <script src="./preset_codec.js"></script>
    <script src="./onboarding_funnel.js"></script>
    <script src="./first_answer_accelerator.js"></script>
    <script src="./unknown_explainability.js"></script>
    <script src="./cross_method_stability.js"></script>
    <script src="./evidence_trust_panel.js"></script>
    <script>
      "use strict";

      const qs = (sel) => document.querySelector(sel);
      const esc = (s) =>
        String(s || "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      const SEARCH_INPUT_DEBOUNCE_MS = 120;
      const RENDER_COMPARE_SCHEDULE = "raf";
      const MOBILE_LATENCY_OBS_VERSION = "v1";
      const MOBILE_LATENCY_STORAGE_KEY = "vclc_mobile_latency_samples_v1";
      const MOBILE_LATENCY_MAX_SAMPLES = 500;
      const CONCERN_PACK_OUTCOME_TELEMETRY_VERSION = "v1";
      const CONCERN_PACK_OUTCOME_STORAGE_KEY = "vclc_concern_pack_outcome_events_v1";
      const CONCERN_PACK_OUTCOME_MAX_EVENTS = 1200;
      const CONCERN_PACK_OUTCOME_SESSION_ID = `${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
      const EXPLAINABILITY_OUTCOME_TELEMETRY_VERSION = "v1";
      const EXPLAINABILITY_OUTCOME_STORAGE_KEY = "vclc_explainability_outcome_events_v1";
      const EXPLAINABILITY_OUTCOME_MAX_EVENTS = 1200;
      const EXPLAINABILITY_OUTCOME_SESSION_ID = `${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
      const TRUST_ACTION_NUDGE_TELEMETRY_VERSION = "v1";
      const TRUST_ACTION_NUDGE_STORAGE_KEY = "vclc_trust_action_nudge_events_v1";
      const TRUST_ACTION_NUDGE_MAX_EVENTS = 1200;
      const TRUST_ACTION_NUDGE_SESSION_ID = `${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;

      const mobileLatencyObs = {
        pending: null,
        samples: [],
      };
      const concernPackOutcomeTelemetry = {
        events: [],
      };
      const explainabilityOutcomeTelemetry = {
        events: [],
        dedupeKeys: new Set(),
      };
      const trustActionNudgeTelemetry = {
        events: [],
        shownNudgeKeys: new Set(),
      };

      function nowIsoUtc() {
        return new Date().toISOString();
      }

      function perfNowMs() {
        if (typeof performance === "object" && performance && typeof performance.now === "function") {
          return performance.now();
        }
        return Date.now();
      }

      function readMobileLatencySamples() {
        try {
          const raw = localStorage.getItem(MOBILE_LATENCY_STORAGE_KEY);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          return parsed.filter((row) => row && typeof row === "object");
        } catch (_err) {
          return [];
        }
      }

      function writeMobileLatencySamples() {
        try {
          localStorage.setItem(MOBILE_LATENCY_STORAGE_KEY, JSON.stringify(mobileLatencyObs.samples));
        } catch (_err) {}
      }

      function percentile(values, q) {
        const xs = (Array.isArray(values) ? values : [])
          .map((x) => Number(x))
          .filter((x) => Number.isFinite(x))
          .sort((a, b) => a - b);
        if (!xs.length) return null;
        if (xs.length === 1) return xs[0];
        const qq = Number.isFinite(Number(q)) ? Math.min(1, Math.max(0, Number(q))) : 0;
        const rank = qq * (xs.length - 1);
        const lo = Math.floor(rank);
        const hi = Math.min(xs.length - 1, lo + 1);
        if (hi === lo) return xs[lo];
        const frac = rank - lo;
        return xs[lo] + (xs[hi] - xs[lo]) * frac;
      }

      function summarizeMobileLatencySamples() {
        const values = mobileLatencyObs.samples
          .map((row) => Number((row || {}).value_ms))
          .filter((x) => Number.isFinite(x) && x >= 0);
        return {
          sample_count: values.length,
          input_to_render_p50_ms: percentile(values, 0.5),
          input_to_render_p90_ms: percentile(values, 0.9),
          input_to_render_p95_ms: percentile(values, 0.95),
        };
      }

      function recordMobileLatencySample(row) {
        if (!row || typeof row !== "object") return;
        mobileLatencyObs.samples.push(row);
        if (mobileLatencyObs.samples.length > MOBILE_LATENCY_MAX_SAMPLES) {
          mobileLatencyObs.samples = mobileLatencyObs.samples.slice(-MOBILE_LATENCY_MAX_SAMPLES);
        }
        writeMobileLatencySamples();
      }

      function markInputLatencySampleStart(source) {
        mobileLatencyObs.pending = {
          source: String(source || "unknown"),
          start_perf_ms: perfNowMs(),
          started_at: nowIsoUtc(),
        };
      }

      function commitInputLatencySample(trigger) {
        const pending = mobileLatencyObs.pending;
        if (!pending) return;
        mobileLatencyObs.pending = null;
        const elapsedMs = perfNowMs() - Number(pending.start_perf_ms || 0);
        if (!Number.isFinite(elapsedMs) || elapsedMs < 0) return;
        const safeValue = Math.round(elapsedMs * 1000) / 1000;
        recordMobileLatencySample({
          obs_version: MOBILE_LATENCY_OBS_VERSION,
          metric: "input_to_render_ms",
          value_ms: safeValue,
          source: String(pending.source || "unknown"),
          trigger: String(trigger || "render"),
          ts: nowIsoUtc(),
        });
      }

      function installMobileLatencyDebugApi() {
        const attach = (name, fn) => {
          try {
            Object.defineProperty(window, name, { configurable: true, writable: false, value: fn });
          } catch (_err) {
            window[name] = fn;
          }
        };

        attach("__vclcMobileLatencySummary", function vclcMobileLatencySummary() {
          return {
            obs_version: MOBILE_LATENCY_OBS_VERSION,
            generated_at: nowIsoUtc(),
            ...summarizeMobileLatencySamples(),
          };
        });

        attach("__vclcMobileLatencyExport", function vclcMobileLatencyExport() {
          return {
            obs_version: MOBILE_LATENCY_OBS_VERSION,
            generated_at: nowIsoUtc(),
            ...summarizeMobileLatencySamples(),
            samples: mobileLatencyObs.samples.slice(),
          };
        });

        attach("__vclcMobileLatencyClear", function vclcMobileLatencyClear() {
          mobileLatencyObs.pending = null;
          mobileLatencyObs.samples = [];
          writeMobileLatencySamples();
          return { ok: true, sample_count: 0 };
        });
      }

      mobileLatencyObs.samples = readMobileLatencySamples();
      if (mobileLatencyObs.samples.length > MOBILE_LATENCY_MAX_SAMPLES) {
        mobileLatencyObs.samples = mobileLatencyObs.samples.slice(-MOBILE_LATENCY_MAX_SAMPLES);
      }
      installMobileLatencyDebugApi();

      function readConcernPackOutcomeEvents() {
        try {
          const raw = localStorage.getItem(CONCERN_PACK_OUTCOME_STORAGE_KEY);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          return parsed.filter((row) => row && typeof row === "object");
        } catch (_err) {
          return [];
        }
      }

      function writeConcernPackOutcomeEvents() {
        try {
          localStorage.setItem(CONCERN_PACK_OUTCOME_STORAGE_KEY, JSON.stringify(concernPackOutcomeTelemetry.events));
        } catch (_err) {}
      }

      function resolveConcernPackWeak(packId, fallbackWeak) {
        if (typeof fallbackWeak === "boolean") return fallbackWeak;
        const token = String(packId || "").trim();
        if (!token) return null;
        if (typeof concernPackQualityForPack === "function") {
          const quality = concernPackQualityForPack(token);
          if (quality && typeof quality.weak === "boolean") return Boolean(quality.weak);
        }
        return null;
      }

      function recordConcernPackOutcomeEvent(eventType, payload) {
        const et = String(eventType || "").trim().toLowerCase();
        if (!et) return;
        const p = payload && typeof payload === "object" ? payload : {};
        const rawPackId = String(p.pack_id || (state && state.activeConcernPackId) || "").trim();
        const packId = typeof normalizeConcernPackId === "function" ? normalizeConcernPackId(rawPackId) : rawPackId;
        const packWeak = resolveConcernPackWeak(packId, p.pack_weak);

        const row = {
          telemetry_version: CONCERN_PACK_OUTCOME_TELEMETRY_VERSION,
          event_type: et,
          ts: nowIsoUtc(),
          session_id: String(p.session_id || CONCERN_PACK_OUTCOME_SESSION_ID),
          source: String(p.source || "unknown"),
          view_mode: String((state && state.viewMode) || ""),
          pack_id: packId || "",
          pack_weak: packWeak === null ? null : Boolean(packWeak),
          topic_id: Number.isFinite(Number(p.topic_id || 0)) && Number(p.topic_id || 0) > 0 ? Number(p.topic_id || 0) : null,
          concern_ids_count:
            Number.isFinite(Number(p.concern_ids_count || 0)) && Number(p.concern_ids_count || 0) > 0
              ? Number(p.concern_ids_count || 0)
              : null,
        };

        concernPackOutcomeTelemetry.events.push(row);
        if (concernPackOutcomeTelemetry.events.length > CONCERN_PACK_OUTCOME_MAX_EVENTS) {
          concernPackOutcomeTelemetry.events = concernPackOutcomeTelemetry.events.slice(-CONCERN_PACK_OUTCOME_MAX_EVENTS);
        }
        writeConcernPackOutcomeEvents();
      }

      function summarizeConcernPackOutcomeEvents() {
        const events = Array.isArray(concernPackOutcomeTelemetry.events) ? concernPackOutcomeTelemetry.events : [];
        const packSelected = events.filter((row) => String((row || {}).event_type || "") === "pack_selected");
        const topicOpenWithPack = events.filter((row) => String((row || {}).event_type || "") === "topic_open_with_pack");

        const weakPackSelected = packSelected.filter((row) => row && row.pack_weak === true);
        const weakPackFollowthrough = topicOpenWithPack.filter((row) => row && row.pack_weak === true);
        const unknownPackSelected = packSelected.filter((row) => row && row.pack_weak === null);

        const selectedPackIds = new Set();
        for (const row of packSelected) {
          const pid = String((row || {}).pack_id || "").trim();
          if (!pid) continue;
          selectedPackIds.add(pid);
        }

        const sessions = new Map();
        const ensureSession = (sid) => {
          const token = String(sid || "global");
          if (sessions.has(token)) return sessions.get(token);
          const next = { pack_selected: false, weak_selected: false, weak_followthrough: false };
          sessions.set(token, next);
          return next;
        };

        for (const row of packSelected) {
          const st = ensureSession(row && row.session_id);
          st.pack_selected = true;
          if (row && row.pack_weak === true) st.weak_selected = true;
        }
        for (const row of topicOpenWithPack) {
          const st = ensureSession(row && row.session_id);
          if (row && row.pack_weak === true) st.weak_followthrough = true;
        }

        let packSelectedSessions = 0;
        let weakSelectedSessions = 0;
        let weakFollowthroughSessions = 0;
        for (const st of sessions.values()) {
          if (st.pack_selected) packSelectedSessions += 1;
          if (st.weak_selected) weakSelectedSessions += 1;
          if (st.weak_followthrough) weakFollowthroughSessions += 1;
        }

        const weakPackFollowthroughRate =
          weakSelectedSessions > 0 ? weakFollowthroughSessions / weakSelectedSessions : null;
        const unknownPackSelectShare =
          packSelected.length > 0 ? unknownPackSelected.length / packSelected.length : null;

        return {
          telemetry_version: CONCERN_PACK_OUTCOME_TELEMETRY_VERSION,
          generated_at: nowIsoUtc(),
          events_total: events.length,
          pack_selected_events_total: packSelected.length,
          topic_open_with_pack_events_total: topicOpenWithPack.length,
          weak_pack_selected_events_total: weakPackSelected.length,
          weak_pack_followthrough_events_total: weakPackFollowthrough.length,
          unknown_pack_selected_events_total: unknownPackSelected.length,
          pack_selected_sessions_total: packSelectedSessions,
          weak_pack_selected_sessions_total: weakSelectedSessions,
          weak_pack_followthrough_sessions_total: weakFollowthroughSessions,
          weak_pack_followthrough_rate: weakPackFollowthroughRate,
          unknown_pack_select_share: unknownPackSelectShare,
          selected_pack_ids_total: selectedPackIds.size,
        };
      }

      function installConcernPackOutcomeDebugApi() {
        const attach = (name, fn) => {
          try {
            Object.defineProperty(window, name, { configurable: true, writable: false, value: fn });
          } catch (_err) {
            window[name] = fn;
          }
        };

        attach("__vclcConcernPackOutcomeSummary", function vclcConcernPackOutcomeSummary() {
          return summarizeConcernPackOutcomeEvents();
        });

        attach("__vclcConcernPackOutcomeExport", function vclcConcernPackOutcomeExport() {
          return {
            ...summarizeConcernPackOutcomeEvents(),
            events: concernPackOutcomeTelemetry.events.slice(),
          };
        });

        attach("__vclcConcernPackOutcomeClear", function vclcConcernPackOutcomeClear() {
          concernPackOutcomeTelemetry.events = [];
          writeConcernPackOutcomeEvents();
          return { ok: true, events_total: 0 };
        });
      }

      concernPackOutcomeTelemetry.events = readConcernPackOutcomeEvents();
      if (concernPackOutcomeTelemetry.events.length > CONCERN_PACK_OUTCOME_MAX_EVENTS) {
        concernPackOutcomeTelemetry.events = concernPackOutcomeTelemetry.events.slice(-CONCERN_PACK_OUTCOME_MAX_EVENTS);
      }
      installConcernPackOutcomeDebugApi();

      function readExplainabilityOutcomeEvents() {
        try {
          const raw = localStorage.getItem(EXPLAINABILITY_OUTCOME_STORAGE_KEY);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          return parsed.filter((row) => row && typeof row === "object");
        } catch (_err) {
          return [];
        }
      }

      function writeExplainabilityOutcomeEvents() {
        try {
          localStorage.setItem(EXPLAINABILITY_OUTCOME_STORAGE_KEY, JSON.stringify(explainabilityOutcomeTelemetry.events));
        } catch (_err) {}
      }

      function rebuildExplainabilityOutcomeDedupe() {
        explainabilityOutcomeTelemetry.dedupeKeys = new Set();
        for (const row of explainabilityOutcomeTelemetry.events) {
          if (!row || typeof row !== "object") continue;
          const sid = String(row.session_id || "global");
          const et = String(row.event_type || "").trim().toLowerCase();
          const src = String(row.source || "unknown").trim().toLowerCase();
          const term = String(row.term || "").trim().toLowerCase();
          const scope = String(row.copy_scope || "").trim().toLowerCase();
          if (!et) continue;
          explainabilityOutcomeTelemetry.dedupeKeys.add(`${sid}:${et}:${src}:${term}:${scope}`);
        }
      }

      function resolveExplainabilityViewMode(fallback) {
        const token = String(fallback || "").trim();
        if (token) return token;
        const sel = qs("#viewMode");
        return String((sel && sel.value) || "unknown").trim() || "unknown";
      }

      function recordExplainabilityOutcomeEvent(eventType, payload) {
        const et = String(eventType || "").trim().toLowerCase();
        if (!et) return;
        const p = payload && typeof payload === "object" ? payload : {};
        const row = {
          telemetry_version: EXPLAINABILITY_OUTCOME_TELEMETRY_VERSION,
          event_type: et,
          ts: nowIsoUtc(),
          session_id: String(p.session_id || EXPLAINABILITY_OUTCOME_SESSION_ID),
          source: String(p.source || "unknown").trim().toLowerCase() || "unknown",
          source_view: resolveExplainabilityViewMode(p.source_view),
          term: String(p.term || "").trim().toLowerCase() || null,
          copy_scope: String(p.copy_scope || "").trim().toLowerCase() || null,
        };
        const dedupeKey = `${row.session_id}:${row.event_type}:${row.source}:${String(row.term || "")}:${String(
          row.copy_scope || ""
        )}`;
        if (explainabilityOutcomeTelemetry.dedupeKeys.has(dedupeKey)) return;
        explainabilityOutcomeTelemetry.dedupeKeys.add(dedupeKey);
        explainabilityOutcomeTelemetry.events.push(row);
        if (explainabilityOutcomeTelemetry.events.length > EXPLAINABILITY_OUTCOME_MAX_EVENTS) {
          explainabilityOutcomeTelemetry.events = explainabilityOutcomeTelemetry.events.slice(-EXPLAINABILITY_OUTCOME_MAX_EVENTS);
          rebuildExplainabilityOutcomeDedupe();
        }
        writeExplainabilityOutcomeEvents();
      }

      function summarizeExplainabilityOutcomeEvents() {
        const events = Array.isArray(explainabilityOutcomeTelemetry.events) ? explainabilityOutcomeTelemetry.events : [];
        const glossaryOpened = events.filter((row) => String((row || {}).event_type || "") === "explainability_glossary_opened");
        const glossaryTermInteracted = events.filter(
          (row) => String((row || {}).event_type || "") === "explainability_glossary_term_interacted"
        );
        const helpCopyInteracted = events.filter(
          (row) => String((row || {}).event_type || "") === "explainability_help_copy_interacted"
        );

        const sessions = new Map();
        const ensureSession = (sid) => {
          const token = String(sid || "global");
          if (sessions.has(token)) return sessions.get(token);
          const next = { glossary: false, help_copy: false };
          sessions.set(token, next);
          return next;
        };

        for (const row of glossaryOpened) {
          const st = ensureSession(row && row.session_id);
          st.glossary = true;
        }
        for (const row of glossaryTermInteracted) {
          const st = ensureSession(row && row.session_id);
          st.glossary = true;
        }
        for (const row of helpCopyInteracted) {
          const st = ensureSession(row && row.session_id);
          st.help_copy = true;
        }

        let adoptionSessions = 0;
        let completeAdoptionSessions = 0;
        for (const st of sessions.values()) {
          const hasAny = Boolean(st.glossary || st.help_copy);
          const complete = Boolean(st.glossary && st.help_copy);
          if (hasAny) adoptionSessions += 1;
          if (complete) completeAdoptionSessions += 1;
        }

        const termSet = new Set();
        for (const row of glossaryTermInteracted) {
          const token = String((row || {}).term || "").trim().toLowerCase();
          if (token) termSet.add(token);
        }

        const adoptionCompletenessRate =
          adoptionSessions > 0 ? completeAdoptionSessions / Math.max(1, adoptionSessions) : null;

        return {
          telemetry_version: EXPLAINABILITY_OUTCOME_TELEMETRY_VERSION,
          generated_at: nowIsoUtc(),
          events_total: events.length,
          glossary_opened_events_total: glossaryOpened.length,
          glossary_term_interaction_events_total: glossaryTermInteracted.length,
          glossary_interaction_events_total: glossaryOpened.length + glossaryTermInteracted.length,
          help_copy_interaction_events_total: helpCopyInteracted.length,
          sessions_total: sessions.size,
          adoption_sessions_total: adoptionSessions,
          complete_adoption_sessions_total: completeAdoptionSessions,
          adoption_completeness_rate: adoptionCompletenessRate,
          interacted_terms_total: termSet.size,
        };
      }

      function installExplainabilityOutcomeDebugApi() {
        const attach = (name, fn) => {
          try {
            Object.defineProperty(window, name, { configurable: true, writable: false, value: fn });
          } catch (_err) {
            window[name] = fn;
          }
        };

        attach("__vclcExplainabilityOutcomeSummary", function vclcExplainabilityOutcomeSummary() {
          return summarizeExplainabilityOutcomeEvents();
        });

        attach("__vclcExplainabilityOutcomeExport", function vclcExplainabilityOutcomeExport() {
          return {
            ...summarizeExplainabilityOutcomeEvents(),
            events: explainabilityOutcomeTelemetry.events.slice(),
          };
        });

        attach("__vclcExplainabilityOutcomeClear", function vclcExplainabilityOutcomeClear() {
          explainabilityOutcomeTelemetry.events = [];
          explainabilityOutcomeTelemetry.dedupeKeys = new Set();
          writeExplainabilityOutcomeEvents();
          return { ok: true, events_total: 0 };
        });
      }

      function installExplainabilityOutcomeTelemetry() {
        const root = qs("[data-explainability-glossary='1']");
        if (!root) return;

        root.addEventListener("toggle", () => {
          if (!root.open) return;
          recordExplainabilityOutcomeEvent("explainability_glossary_opened", {
            source: "glossary",
            copy_scope: "summary",
          });
        });

        for (const node of root.querySelectorAll("[data-explainability-term]")) {
          const emitTerm = () => {
            recordExplainabilityOutcomeEvent("explainability_glossary_term_interacted", {
              source: "glossary_term",
              term: String(node.getAttribute("data-explainability-term") || "").trim().toLowerCase(),
            });
          };
          node.addEventListener("focus", emitTerm);
          node.addEventListener("pointerenter", emitTerm);
          node.addEventListener("click", emitTerm);
        }

        for (const node of root.querySelectorAll("[data-explainability-copy='1']")) {
          const scope = node.matches("summary") ? "summary" : "list";
          const emitCopy = () => {
            recordExplainabilityOutcomeEvent("explainability_help_copy_interacted", {
              source: "help_copy",
              copy_scope: scope,
            });
          };
          node.addEventListener("focus", emitCopy);
          node.addEventListener("pointerenter", emitCopy);
          node.addEventListener("click", emitCopy);
        }
      }

      explainabilityOutcomeTelemetry.events = readExplainabilityOutcomeEvents();
      if (explainabilityOutcomeTelemetry.events.length > EXPLAINABILITY_OUTCOME_MAX_EVENTS) {
        explainabilityOutcomeTelemetry.events = explainabilityOutcomeTelemetry.events.slice(-EXPLAINABILITY_OUTCOME_MAX_EVENTS);
      }
      rebuildExplainabilityOutcomeDedupe();
      installExplainabilityOutcomeDebugApi();
      installExplainabilityOutcomeTelemetry();

      function readTrustActionNudgeEvents() {
        try {
          const raw = localStorage.getItem(TRUST_ACTION_NUDGE_STORAGE_KEY);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          return parsed.filter((row) => row && typeof row === "object");
        } catch (_err) {
          return [];
        }
      }

      function writeTrustActionNudgeEvents() {
        try {
          localStorage.setItem(TRUST_ACTION_NUDGE_STORAGE_KEY, JSON.stringify(trustActionNudgeTelemetry.events));
        } catch (_err) {}
      }

      function recordTrustActionNudgeEvent(eventType, payload) {
        const et = String(eventType || "").trim().toLowerCase();
        if (!et) return;
        const p = payload && typeof payload === "object" ? payload : {};
        const row = {
          telemetry_version: TRUST_ACTION_NUDGE_TELEMETRY_VERSION,
          event_type: et,
          ts: nowIsoUtc(),
          session_id: String(p.session_id || TRUST_ACTION_NUDGE_SESSION_ID),
          source_view: String(p.source_view || (state && state.viewMode) || "unknown"),
          nudge_id: String(p.nudge_id || "").trim(),
          nudge_kind: String(p.nudge_kind || "evidence_click").trim(),
          trust_level: String(p.trust_level || "").trim(),
          stance: String(p.stance || "").trim(),
          party_id: Number.isFinite(Number(p.party_id || 0)) && Number(p.party_id || 0) > 0 ? Number(p.party_id || 0) : null,
          topic_id: Number.isFinite(Number(p.topic_id || 0)) && Number(p.topic_id || 0) > 0 ? Number(p.topic_id || 0) : null,
          concern_id: String(p.concern_id || "").trim() || null,
          link_target: String(p.link_target || "").trim() || null,
        };
        trustActionNudgeTelemetry.events.push(row);
        if (trustActionNudgeTelemetry.events.length > TRUST_ACTION_NUDGE_MAX_EVENTS) {
          trustActionNudgeTelemetry.events = trustActionNudgeTelemetry.events.slice(-TRUST_ACTION_NUDGE_MAX_EVENTS);
        }
        if (et === "trust_action_nudge_shown" && row.nudge_id) {
          trustActionNudgeTelemetry.shownNudgeKeys.add(`${row.session_id}:${row.nudge_id}`);
        }
        writeTrustActionNudgeEvents();
      }

      function summarizeTrustActionNudgeEvents() {
        const events = Array.isArray(trustActionNudgeTelemetry.events) ? trustActionNudgeTelemetry.events : [];
        const shown = events.filter((row) => String((row || {}).event_type || "") === "trust_action_nudge_shown");
        const clicked = events.filter((row) => String((row || {}).event_type || "") === "trust_action_nudge_clicked");
        const shownSessions = new Set();
        const clickedSessions = new Set();
        for (const row of shown) {
          shownSessions.add(String((row || {}).session_id || "global"));
        }
        for (const row of clicked) {
          clickedSessions.add(String((row || {}).session_id || "global"));
        }
        const ctr = shownSessions.size > 0 ? clickedSessions.size / shownSessions.size : null;
        return {
          telemetry_version: TRUST_ACTION_NUDGE_TELEMETRY_VERSION,
          generated_at: nowIsoUtc(),
          events_total: events.length,
          nudge_shown_events_total: shown.length,
          nudge_clicked_events_total: clicked.length,
          nudge_shown_sessions_total: shownSessions.size,
          nudge_clicked_sessions_total: clickedSessions.size,
          nudge_clickthrough_session_rate: ctr,
        };
      }

      function installTrustActionNudgeDebugApi() {
        const attach = (name, fn) => {
          try {
            Object.defineProperty(window, name, { configurable: true, writable: false, value: fn });
          } catch (_err) {
            window[name] = fn;
          }
        };

        attach("__vclcTrustActionNudgeSummary", function vclcTrustActionNudgeSummary() {
          return summarizeTrustActionNudgeEvents();
        });

        attach("__vclcTrustActionNudgeExport", function vclcTrustActionNudgeExport() {
          return {
            ...summarizeTrustActionNudgeEvents(),
            events: trustActionNudgeTelemetry.events.slice(),
          };
        });

        attach("__vclcTrustActionNudgeClear", function vclcTrustActionNudgeClear() {
          trustActionNudgeTelemetry.events = [];
          trustActionNudgeTelemetry.shownNudgeKeys = new Set();
          writeTrustActionNudgeEvents();
          return { ok: true, events_total: 0 };
        });
      }

      trustActionNudgeTelemetry.events = readTrustActionNudgeEvents();
      if (trustActionNudgeTelemetry.events.length > TRUST_ACTION_NUDGE_MAX_EVENTS) {
        trustActionNudgeTelemetry.events = trustActionNudgeTelemetry.events.slice(-TRUST_ACTION_NUDGE_MAX_EVENTS);
      }
      for (const row of trustActionNudgeTelemetry.events) {
        if (!row || String(row.event_type || "") !== "trust_action_nudge_shown") continue;
        const sid = String(row.session_id || "global");
        const nid = String(row.nudge_id || "");
        if (!nid) continue;
        trustActionNudgeTelemetry.shownNudgeKeys.add(`${sid}:${nid}`);
      }
      installTrustActionNudgeDebugApi();

      function stripDiacritics(s) {
        // Compatible with most browsers (avoid \p{Diacritic}).
        return String(s || "")
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "");
      }

      function norm(s) {
        return stripDiacritics(String(s || "").toLowerCase()).trim();
      }

      function fmtInt(n) {
        const x = Number(n || 0);
        if (!Number.isFinite(x)) return "0";
        return x.toLocaleString("es-ES");
      }

      function fmtPct01(x) {
        const v = Number(x || 0);
        if (!Number.isFinite(v)) return "0%";
        return `${Math.round(v * 100)}%`;
      }

      function debounce(fn, waitMs) {
        let timer = 0;
        const wait = Number.isFinite(Number(waitMs)) && Number(waitMs) > 0 ? Number(waitMs) : 0;
        return function debounced(...args) {
          if (timer) clearTimeout(timer);
          timer = setTimeout(() => {
            timer = 0;
            fn.apply(this, args);
          }, wait);
        };
      }

      let compareRenderQueued = false;
      function scheduleRenderCompare(trigger) {
        if (compareRenderQueued) return;
        compareRenderQueued = true;
        const run = () => {
          compareRenderQueued = false;
          try {
            renderCompare();
          } finally {
            commitInputLatencySample(String(trigger || "render_compare_schedule"));
          }
        };
        if (RENDER_COMPARE_SCHEDULE === "raf" && typeof window.requestAnimationFrame === "function") {
          window.requestAnimationFrame(run);
          return;
        }
        setTimeout(run, 0);
      }

      function stanceLabel(s) {
        const k = String(s || "");
        if (k === "support") return "A favor";
        if (k === "oppose") return "En contra";
        if (k === "mixed") return "Mixto";
        if (k === "unclear") return "Incierto";
        if (k === "no_signal") return "Sin senal";
        return "Incierto";
      }

      function dotClassForStance(s) {
        const k = String(s || "");
        if (k === "support") return "ok";
        if (k === "oppose") return "bad";
        if (k === "mixed") return "warn";
        if (k === "unclear") return "warn";
        if (k === "no_signal") return "";
        return "";
      }

      function confidenceTier(conf, stance) {
        const s = String(stance || "");
        const c = Number(conf || 0);
        if (s === "no_signal" || !Number.isFinite(c) || c <= 0) return "none";
        if (c >= 0.66) return "high";
        if (c >= 0.33) return "medium";
        return "low";
      }

      function confidenceTierLabel(tier) {
        const t = String(tier || "");
        if (t === "high") return "Alta";
        if (t === "medium") return "Media";
        if (t === "low") return "Baja";
        return "Nula";
      }

      function confidenceTierTagClass(tier) {
        const t = String(tier || "");
        if (t === "high") return "good";
        if (t === "low") return "hot";
        if (t === "none") return "bad";
        return "";
      }

      function computedMethodLabel() {
        const m = String((state.citizen?.meta || {}).computed_method || "");
        if (m === "votes") return "Hechos (votos)";
        if (m === "combined") return "Combinado (prioriza votos)";
        if (m === "declared") return "Dichos (intervenciones)";
        return "Posicion";
      }

      function isComparableStance(s) {
        const k = String(s || "");
        return k === "support" || k === "oppose";
      }

      function isClearStance(s) {
        const k = String(s || "");
        return k === "support" || k === "oppose" || k === "mixed";
      }

      function buildTopicByIdMap(citizen) {
        const m = new Map();
        for (const t of (citizen || {}).topics || []) {
          m.set(Number(t.topic_id || 0), t);
        }
        return m;
      }

      function buildPosByKeyMap(citizen) {
        const m = new Map();
        for (const r of (citizen || {}).party_topic_positions || []) {
          const key = `${Number(r.topic_id || 0)}:${Number(r.party_id || 0)}`;
          m.set(key, r);
        }
        return m;
      }

      function stanceFromPosMap(posMap, topicId, partyId) {
        const key = `${Number(topicId || 0)}:${Number(partyId || 0)}`;
        const row = posMap && posMap.get ? posMap.get(key) : null;
        return row ? String(row.stance || "no_signal") : "no_signal";
      }

      async function fetchJson(path) {
        const res = await fetch(path, { cache: "no-store" });
        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          throw new Error(`HTTP ${res.status} al cargar ${path}: ${txt.slice(0, 120)}`);
        }
        return await res.json();
      }

      const LS_SELECTED_CONCERNS = "vclc_citizen_selected_concerns_v3";
      const LS_METHOD = "vclc_citizen_method_v3";
      const LS_VIEW = "vclc_citizen_view_v3";
      const LS_PREFS = "vclc_citizen_prefs_v1";
      const LS_ONBOARD_DISMISSED = "vclc_citizen_onboard_dismissed_v1";
      const LS_EXPERIENCE_MODE = "vclc_citizen_experience_mode_v1";
      const CONSUMER_TOPIC_MAX = 12;
      const CONSUMER_PARTY_CARDS_MAX = 8;

      function lsGet(key) {
        try {
          return String(localStorage.getItem(String(key)) || "");
        } catch {
          return "";
        }
      }

      function lsSet(key, value) {
        try {
          localStorage.setItem(String(key), String(value));
        } catch {
          // ignore
        }
      }

      function normalizePrefValue(v) {
        const k = String(v || "").trim();
        if (k === "support" || k === "oppose") return k;
        return "";
      }

      function prefsToStorageValue(prefsMap) {
        const items = {};
        const keys = Array.from((prefsMap && prefsMap.keys ? prefsMap.keys() : [])).map((x) => Number(x || 0));
        keys.sort((a, b) => a - b);
        for (const tid of keys) {
          const pref = normalizePrefValue(prefsMap.get(tid));
          if (!pref) continue;
          items[String(tid)] = pref;
        }
        return JSON.stringify({ version: "v1", updated_at: new Date().toISOString(), items });
      }

      function prefsFromStorageValue(raw) {
        const txt = String(raw || "").trim();
        if (!txt) return new Map();
        try {
          const obj = JSON.parse(txt);
          const items = obj && obj.items && typeof obj.items === "object" ? obj.items : {};
          const out = new Map();
          for (const [k, v] of Object.entries(items)) {
            const tid = Number(k || 0);
            if (!Number.isFinite(tid) || tid <= 0) continue;
            const pref = normalizePrefValue(v);
            if (!pref) continue;
            out.set(tid, pref);
          }
          return out;
        } catch {
          return new Map();
        }
      }

      function encodePrefsPayload(prefsMap) {
        // Compact v1: topic_id=<s|o> pairs joined by commas.
        const keys = Array.from((prefsMap && prefsMap.keys ? prefsMap.keys() : [])).map((x) => Number(x || 0));
        keys.sort((a, b) => a - b);
        const parts = [];
        for (const tid of keys) {
          const pref = normalizePrefValue(prefsMap.get(tid));
          if (!pref) continue;
          parts.push(`${tid}=${pref === "support" ? "s" : "o"}`);
        }
        return parts.join(",");
      }

      function decodePrefsPayload(payload) {
        const txt = String(payload || "").trim();
        const out = new Map();
        if (!txt) return out;
        for (const part of txt.split(",")) {
          const p = String(part || "").trim();
          if (!p) continue;
          const [k, v] = p.split("=");
          const tid = Number(String(k || "").trim() || 0);
          if (!Number.isFinite(tid) || tid <= 0) continue;
          const vv = String(v || "").trim().toLowerCase();
          const pref = vv === "s" ? "support" : vv === "o" ? "oppose" : "";
          if (!pref) continue;
          out.set(tid, pref);
        }
        return out;
      }

      function readPrefsFromHash() {
        const h = String(location.hash || "");
        if (!h || h.length < 2) return { prefs: null, error: "" };
        // Expect: #prefs=v1:<payload>
        if (!h.startsWith("#prefs=")) return { prefs: null, error: "" };
        const raw = h.slice("#prefs=".length);
        const decoded = decodeURIComponent(raw);
        if (!decoded.startsWith("v1:")) return { prefs: null, error: "prefs hash version no soportada" };
        const payload = decoded.slice(3);
        return { prefs: decodePrefsPayload(payload), error: "" };
      }

      function presetCodec() {
        const codec = window.CitizenPresetCodec || null;
        if (!codec || typeof codec.encodePresetPayload !== "function") return null;
        return codec;
      }

      function presetCodecConfig() {
        const knownConcernIds = Array.isArray(state?.concerns)
          ? state.concerns.map((c) => String(c?.id || "")).filter((x) => x)
          : [];
        return { knownConcernIds, maxConcerns: 6 };
      }

      function encodePresetPayload(opts) {
        const codec = presetCodec();
        if (!codec) return "";
        return String(codec.encodePresetPayload(opts || {}, presetCodecConfig()) || "");
      }

      function decodePresetPayload(payload) {
        const codec = presetCodec();
        if (!codec) return null;
        return codec.decodePresetPayload(payload, presetCodecConfig());
      }

      function readPresetFromHash() {
        const codec = presetCodec();
        if (!codec) return { preset: null, error: "preset codec no disponible", error_code: "codec_missing" };
        return codec.readPresetFromHash(String(location.hash || ""), presetCodecConfig());
      }

      function presetErrorHint(errorCode) {
        const code = String(errorCode || "").trim();
        if (!code) return "";
        if (code === "unsupported_version") return "Este enlace usa otra version. Vuelve a generar un enlace con #preset=v1.";
        if (code === "decode_error") return "El hash del enlace esta corrupto o truncado. Copia el enlace completo de nuevo.";
        if (code === "empty_payload") return "El enlace no trae datos de preset. Se ignora y se usa estado local.";
        if (code === "no_supported_fields") return "El enlace no trae campos reconocidos (view/method/pack/concerns/concern).";
        if (code === "codec_missing") return "No se pudo cargar el modulo de preset. Recarga la pagina y prueba otra vez.";
        return "";
      }

      function buildAlignmentPresetShareUrl(opts) {
        const codec = presetCodec();
        if (!codec) return String(location.href || "");
        return codec.buildAlignmentPresetShareUrl(
          opts || {},
          String(location.href || ""),
          String(location.origin || ""),
          presetCodecConfig()
        );
      }

      async function copyToClipboard(text) {
        const txt = String(text || "");
        if (!txt) return false;
        try {
          await navigator.clipboard.writeText(txt);
          return true;
        } catch {
          return false;
        }
      }

      function buildShareUrlWithPrefs(prefsMap) {
        const base = new URL(String(location.href || ""), String(location.origin || undefined));
        const p = new URLSearchParams(base.search || "");
        // Ensure alignment view is explicit in shared links.
        p.set("view", "alignment");
        base.search = `?${p.toString()}`;
        base.hash = `#prefs=${encodeURIComponent("v1:" + encodePrefsPayload(prefsMap))}`;
        return base.toString();
      }

      function persistPrefs() {
        try {
          lsSet(LS_PREFS, prefsToStorageValue(state.prefs));
        } catch {
          // ignore
        }
      }

      function setPrefForTopic(topicId, pref) {
        const tid = Number(topicId || 0);
        if (!Number.isFinite(tid) || tid <= 0) return;
        const v = normalizePrefValue(pref);
        if (!v) return;
        const cur = String(state.prefs.get(tid) || "");
        if (cur === v) state.prefs.delete(tid);
        else state.prefs.set(tid, v);
        if (
          isConsumerMode() &&
          state.prefs.size > 0 &&
          state.viewMode !== "alignment" &&
          Number(state.activeTopicId || 0) === tid
        ) {
          state.viewMode = "alignment";
          const viewSel = qs("#viewMode");
          if (viewSel) viewSel.value = "alignment";
        }
        persistPrefs();
        renderTopicList();
        renderCompare();
      }

      function clearPrefForTopic(topicId) {
        const tid = Number(topicId || 0);
        if (!Number.isFinite(tid) || tid <= 0) return;
        if (!state.prefs.has(tid)) return;
        state.prefs.delete(tid);
        persistPrefs();
        renderTopicList();
        renderCompare();
      }

      function clearAllPrefs() {
        state.prefs = new Map();
        persistPrefs();
        renderTopicList();
        renderCompare();
      }

      function uniqKeepOrder(ids) {
        const out = [];
        const seen = new Set();
        for (const x of ids || []) {
          const k = String(x || "").trim();
          if (!k || seen.has(k)) continue;
          seen.add(k);
          out.push(k);
        }
        return out;
      }

      function parseCsvIds(s) {
        const txt = String(s || "").trim();
        if (!txt) return [];
        return uniqKeepOrder(
          txt
            .split(",")
            .map((x) => String(x || "").trim())
            .filter((x) => x)
        );
      }

      function formatCsvIds(ids) {
        return uniqKeepOrder(ids).join(",");
      }

      const state = {
        citizen: null,
        concernsCfg: null,
        concerns: [],
        concernPacks: [],
        concernPackQuality: null,
        concernPackQualityById: new Map(),
        concernPackQualityLoadError: "",
        topicById: new Map(),
        partyById: new Map(),
        posByKey: new Map(),
        progByKey: new Map(),
        topicTags: new Map(),
        countsByConcern: new Map(),
        selectedConcernIds: [],
        activeConcernPackId: "",
        activeConcernId: "",
        activeTopicId: 0,
        activePartyId: 0,
        experienceMode: "consumer", // consumer | audit
        consumerTopicExpanded: false,
        consumerShowAllParties: false,
        viewMode: "detail", // detail | dashboard | alignment | coherence
        method: "", // combined | votes | declared (URL/localStorage preference)
        programasMeta: null,
        firstAnswerPlan: null,
        prefs: new Map(), // topic_id -> support|oppose
        prefsLoadedFrom: "", // hash | localStorage | empty
        prefsLoadError: "",
        presetLoadedFrom: "", // hash_preset | empty
        presetLoadError: "",
        presetLoadErrorCode: "",
        presetCanonicalHash: "",
        presetRecoveredFrom: "",
        presetHashWasNormalized: false,
        hashPresetActive: false,
        coherence: {
          votes: null,
          declared: null,
          combined: null,
          votesTopicById: new Map(),
          declaredTopicById: new Map(),
          combinedTopicById: new Map(),
          votesPosByKey: new Map(),
          declaredPosByKey: new Map(),
          combinedPosByKey: new Map(),
          loading: false,
          loadError: "",
          promise: null,
        },
      };

      function normalizeExperienceMode(v) {
        return String(v || "").trim().toLowerCase() === "audit" ? "audit" : "consumer";
      }

      function isAuditMode() {
        return normalizeExperienceMode(state.experienceMode) === "audit";
      }

      function isConsumerMode() {
        return !isAuditMode();
      }

      function limitRowsForExperience(rows) {
        const all = Array.isArray(rows) ? rows : [];
        if (!isConsumerMode() || Number(state.activePartyId || 0) > 0 || Boolean(state.consumerShowAllParties)) {
          return { rows: all, hidden: 0, total: all.length };
        }
        const limit = Math.max(1, Number(CONSUMER_PARTY_CARDS_MAX || 8));
        return {
          rows: all.slice(0, limit),
          hidden: Math.max(0, all.length - limit),
          total: all.length,
        };
      }

      function consumerHiddenRowsHint(hidden, label) {
        const n = Number(hidden || 0);
        if (!isConsumerMode() || n <= 0) return "";
        return (
          `<div class="rowMeta" style="margin-top:8px">` +
          `<span class="tag">modo ciudadano</span>` +
          `<span>Mostrando solo lo mas util ahora (${esc(String(n))} ${esc(String(label || "resultados"))} ocultos).</span>` +
          `<button class="btn md3-button" type="button" data-consumer-show-all-parties="1">Ver todo</button>` +
          `<span>Cambia a <strong>Modo auditoria</strong> para mantener la vista completa por defecto.</span>` +
          `</div>`
        );
      }

      function resetConsumerProgressiveDisclosure() {
        state.consumerTopicExpanded = false;
        state.consumerShowAllParties = false;
      }

      function readUrlState() {
        const p = new URLSearchParams(location.search || "");
        const concernsIds = parseCsvIds(String(p.get("concerns_ids") || ""));
        const concernPack = String(p.get("concern_pack") || "").trim();
        const concern = String(p.get("concern") || "").trim();
        const topicId = Number(p.get("topic_id") || 0);
        const partyId = Number(p.get("party_id") || 0);
        const method = String(p.get("method") || "").trim();
        const view = String(p.get("view") || "").trim();
        const mode = String(p.get("mode") || "").trim();

        if (concernsIds.length) state.selectedConcernIds = concernsIds;
        if (concernPack) state.activeConcernPackId = concernPack;
        if (concern) state.activeConcernId = concern;
        if (Number.isFinite(topicId) && topicId > 0) state.activeTopicId = topicId;
        if (Number.isFinite(partyId) && partyId > 0) state.activePartyId = partyId;
        if (method) state.method = method;
        if (view === "dashboard" || view === "detail" || view === "alignment" || view === "coherence") state.viewMode = view;
        if (mode) state.experienceMode = normalizeExperienceMode(mode);
      }

      function writeUrlState(push) {
        if (push && state.hashPresetActive) state.hashPresetActive = false;
        syncActiveConcernPackFromSelection();
        const cids = uniqKeepOrder(state.selectedConcernIds || []).slice(0, 6);
        const method = String(state.method || "").trim();
        const mode = normalizeExperienceMode(state.experienceMode);

        if (!push && state.hashPresetActive) {
          const nextHashOnly = `${String(location.pathname || "")}${String(location.hash || "")}`;
          history.replaceState({}, "", nextHashOnly);
          lsSet(LS_SELECTED_CONCERNS, formatCsvIds(cids));
          if (method) lsSet(LS_METHOD, method);
          lsSet(LS_VIEW, String(state.viewMode || "detail"));
          lsSet(LS_EXPERIENCE_MODE, mode);
          return;
        }

        const p = new URLSearchParams(location.search || "");
        if (state.activeConcernId) p.set("concern", state.activeConcernId);
        else p.delete("concern");
        if (state.activeTopicId) p.set("topic_id", String(state.activeTopicId));
        else p.delete("topic_id");
        if (cids.length > 1) p.set("concerns_ids", formatCsvIds(cids));
        else p.delete("concerns_ids");
        if (state.activeConcernPackId) p.set("concern_pack", String(state.activeConcernPackId));
        else p.delete("concern_pack");
        if (state.activePartyId) p.set("party_id", String(Number(state.activePartyId)));
        else p.delete("party_id");
        if (state.viewMode && state.viewMode !== "detail") p.set("view", String(state.viewMode));
        else p.delete("view");
        if (method && method !== "combined") p.set("method", method);
        else p.delete("method");
        if (mode === "audit") p.set("mode", "audit");
        else p.delete("mode");
        const next = `?${p.toString()}`;
        if (push) history.pushState({}, "", next);
        else history.replaceState({}, "", next);

        // Convenience persistence (URL remains the primary share mechanism).
        lsSet(LS_SELECTED_CONCERNS, formatCsvIds(cids));
        if (method) lsSet(LS_METHOD, method);
        lsSet(LS_VIEW, String(state.viewMode || "detail"));
        lsSet(LS_EXPERIENCE_MODE, mode);
      }

      function setBanner(html) {
        const el = qs("#banner");
        if (!el) return;
        if (!html) {
          el.style.display = "none";
          el.innerHTML = "";
          return;
        }
        el.style.display = "block";
        el.innerHTML = html;
        for (const btn of el.querySelectorAll("[data-preset-clear-hash]")) {
          btn.addEventListener("click", () => {
            const u = new URL(String(location.href || ""), String(location.origin || undefined));
            u.hash = "";
            history.replaceState({}, "", `${u.pathname}${u.search}`);
            state.hashPresetActive = false;
            state.presetLoadError = "";
            state.presetLoadErrorCode = "";
            state.presetCanonicalHash = "";
            state.presetRecoveredFrom = "";
            state.presetHashWasNormalized = false;
            setBanner(`<div><strong>Preset:</strong> hash limpiado. Puedes seguir con estado local o generar un enlace nuevo.</div>`);
          });
        }
        for (const btn of el.querySelectorAll("[data-preset-copy-canonical]")) {
          btn.addEventListener("click", async () => {
            const canonical = String(state.presetCanonicalHash || "").trim();
            if (!canonical) return;
            const u = new URL(String(location.href || ""), String(location.origin || undefined));
            u.hash = canonical;
            const copied = await copyToClipboard(u.toString());
            setBanner(
              `<div><strong>Preset canonico</strong>: ${copied ? "copiado al portapapeles" : "no se pudo copiar automaticamente"}.</div>` +
                `<div style="margin-top:8px"><span class="mono">${esc(u.toString())}</span></div>`
            );
          });
        }
      }

      function onboardingDismissed() {
        return String(lsGet(LS_ONBOARD_DISMISSED) || "") === "1";
      }

      function setOnboardingDismissed(v) {
        lsSet(LS_ONBOARD_DISMISSED, v ? "1" : "0");
      }

      function computeTags() {
        state.topicTags = new Map();
        state.countsByConcern = new Map();

        const concernDefs = state.concerns.map((c) => {
          const kws = Array.isArray(c.keywords) ? c.keywords : [];
          return {
            id: String(c.id || ""),
            label: String(c.label || ""),
            keywords: kws.map((k) => norm(k)).filter((k) => k),
          };
        });

        for (const t of state.citizen.topics || []) {
          const tid = Number(t.topic_id || 0);
          let tags = [];

          // Prefer snapshot-provided tags (v2 optional field) for reproducibility.
          if (Array.isArray(t.concern_ids) && t.concern_ids.length) {
            tags = t.concern_ids.map((x) => String(x || "")).filter((x) => x);
            tags = Array.from(new Set(tags)).sort();
          } else {
            const labelN = norm(t.label || "");
            for (const c of concernDefs) {
              if (!c.id) continue;
              if (c.keywords.some((k) => k && labelN.includes(k))) {
                tags.push(c.id);
              }
            }
          }

          state.topicTags.set(tid, tags);
          for (const cid of tags) {
            state.countsByConcern.set(cid, (state.countsByConcern.get(cid) || 0) + 1);
          }
        }
      }

      function renderStatus() {
        const el = qs("#statusChips");
        if (!el || !state.citizen) return;
        const meta = state.citizen.meta || {};
        const asOf = String(meta.as_of_date || "");
        const method = String(meta.computed_method || "");
        const setId = String(meta.topic_set_id || "");
        const version = String(meta.computed_version || "");
        const prog = meta.programas || null;
        const quality = meta.quality || null;
        const activePack = concernPackById(state.activeConcernPackId);
        const activePackQuality = activePack ? concernPackQualityForPack(activePack.id) : null;
        const packOutcome = summarizeConcernPackOutcomeEvents();
        const weakPacksTotal = Number(((state.concernPackQuality || {}).summary || {}).weak_packs_total || 0);
        const packsTotal = Number(((state.concernPackQuality || {}).summary || {}).packs_total || 0);
        const weakFollowRate = Number((packOutcome || {}).weak_pack_followthrough_rate || 0);
        const weakFollowDot =
          Number((packOutcome || {}).weak_pack_selected_sessions_total || 0) >= 5
            ? weakFollowRate >= 0.35
              ? "ok"
              : weakFollowRate >= 0.2
                ? "warn"
                : "bad"
            : "warn";
        const trustNudgeOutcome = summarizeTrustActionNudgeEvents();
        const trustNudgeCtr = Number((trustNudgeOutcome || {}).nudge_clickthrough_session_rate || 0);
        const trustNudgeDot =
          Number((trustNudgeOutcome || {}).nudge_shown_sessions_total || 0) >= 5
            ? trustNudgeCtr >= 0.4
              ? "ok"
              : trustNudgeCtr >= 0.25
                ? "warn"
                : "bad"
            : "warn";
        const clearPct = Number((quality || {}).clear_pct || 0);
        const unknownPct = Number((quality || {}).unknown_pct || 0);
        const confAvg = Number((quality || {}).confidence_avg_signal || 0);
        const clearDot = clearPct >= 0.7 ? "ok" : clearPct >= 0.45 ? "warn" : "bad";
        const unknownDot = unknownPct <= 0.3 ? "ok" : unknownPct <= 0.5 ? "warn" : "bad";
        const confDot = confAvg >= 0.66 ? "ok" : confAvg >= 0.33 ? "warn" : "bad";

        if (isConsumerMode()) {
          el.innerHTML =
            `<span class="chip md3-chip"><span class="dot ok"></span><span>actualizado</span><span class="mono">${esc(asOf || "?")}</span></span>` +
            `<span class="chip md3-chip"><span class="dot ok"></span><span>metodo</span><span class="mono">${esc(computedMethodLabel())}</span></span>` +
            (quality
              ? `<span class="chip md3-chip"><span class="dot ${clearDot}"></span><span>senal clara</span><span class="mono">${esc(
                  fmtPct01(clearPct)
                )}</span></span>`
              : "") +
            (quality
              ? `<span class="chip md3-chip"><span class="dot ${unknownDot}"></span><span>unknown</span><span class="mono">${esc(
                  fmtPct01(unknownPct)
                )}</span></span>`
              : "") +
            (prog && prog.topic_set_id
              ? `<span class="chip md3-chip"><span class="dot ${Number(prog.signal_total || 0) > 0 ? "ok" : "warn"}"></span><span>promesas</span><span class="mono">${esc(
                  String(prog.election_cycle || "?")
                )}</span></span>`
              : "");
          return;
        }

        el.innerHTML =
          `<span class="chip md3-chip"><span class="dot ok"></span><span>as_of</span><span class="mono">${esc(asOf)}</span></span>` +
          `<span class="chip md3-chip"><span class="dot ok"></span><span>metodo</span><span class="mono">${esc(method)}</span></span>` +
          `<span class="chip md3-chip"><span class="dot ok"></span><span>topic_set</span><span class="mono">${esc(setId)}</span></span>` +
          `<span class="chip md3-chip"><span class="dot ok"></span><span>version</span><span class="mono">${esc(version)}</span></span>` +
          (activePack
            ? `<span class="chip md3-chip"><span class="dot ok"></span><span>pack</span><span class="mono">${esc(
                String(activePack.label || activePack.id || "")
              )}</span></span>`
            : "") +
          (packsTotal > 0
            ? `<span class="chip md3-chip"><span class="dot ${weakPacksTotal > 0 ? "warn" : "ok"}"></span><span>packs_weak</span><span class="mono">${esc(
                String(weakPacksTotal)
              )}/${esc(String(packsTotal))}</span></span>`
            : "") +
          (activePackQuality
            ? `<span class="chip md3-chip"><span class="dot ${activePackQuality.weak ? "warn" : "ok"}"></span><span>pack_quality</span><span class="mono">${esc(
                fmtPct01(Number(activePackQuality.quality_score || 0))
              )}</span></span>`
            : "") +
          (Number((packOutcome || {}).pack_selected_events_total || 0) > 0
            ? `<span class="chip md3-chip"><span class="dot ${weakFollowDot}"></span><span>pack_follow</span><span class="mono">${esc(
                fmtPct01(weakFollowRate)
              )}</span></span>`
            : "") +
          (Number((trustNudgeOutcome || {}).nudge_shown_events_total || 0) > 0
            ? `<span class="chip md3-chip"><span class="dot ${trustNudgeDot}"></span><span>nudge_ctr</span><span class="mono">${esc(
                fmtPct01(trustNudgeCtr)
              )}</span></span>`
            : "") +
          (quality
            ? `<span class="chip md3-chip"><span class="dot ${clearDot}"></span><span>senal_clara</span><span class="mono">${esc(fmtPct01(clearPct))}</span></span>`
            : "") +
          (quality
            ? `<span class="chip md3-chip"><span class="dot ${unknownDot}"></span><span>unknown</span><span class="mono">${esc(fmtPct01(unknownPct))}</span></span>`
            : "") +
          (quality
            ? `<span class="chip md3-chip"><span class="dot ${confDot}"></span><span>conf_media</span><span class="mono">${esc(fmtPct01(confAvg))}</span></span>`
            : "") +
          (prog && prog.topic_set_id
            ? `<span class="chip md3-chip"><span class="dot ${Number(prog.signal_total || 0) > 0 ? "ok" : "warn"}"></span><span>programa</span><span class="mono">${esc(
                String(prog.election_cycle || "?")
              )}</span></span>`
            : "");
      }

      function renderExperienceModeUi() {
        const mode = normalizeExperienceMode(state.experienceMode);
        state.experienceMode = mode;
        const wrap = qs("#experienceModeSwitch");
        if (wrap) {
          for (const btn of wrap.querySelectorAll("[data-experience-mode]")) {
            const v = normalizeExperienceMode(btn.getAttribute("data-experience-mode"));
            btn.classList.toggle("is-active", v === mode);
            btn.setAttribute("aria-pressed", v === mode ? "true" : "false");
          }
        }
        const hint = qs("#experienceModeHint");
        if (hint) {
          hint.textContent =
            mode === "consumer"
              ? "Modo ciudadano: primero respuesta util, luego detalle. Cambia a auditoria para ver telemetria y tablas completas."
              : "Modo auditoria: vista completa con telemetria, filtros finos y detalle metodologico.";
        }

        const adv = qs(".advancedControls");
        if (adv) {
          if (mode === "audit") adv.open = true;
          else adv.removeAttribute("open");
        }

        const viewSel = qs("#viewMode");
        if (viewSel) {
          const cohOpt = viewSel.querySelector('option[value="coherence"]');
          if (cohOpt) {
            const hideCoherence = mode === "consumer";
            cohOpt.hidden = hideCoherence;
            cohOpt.disabled = hideCoherence;
            if (hideCoherence && String(state.viewMode || "") === "coherence") {
              state.viewMode = "dashboard";
              viewSel.value = "dashboard";
            }
          }
        }

        const topicLimit = qs("#topicLimit");
        if (topicLimit && mode === "consumer") {
          const cur = Number(topicLimit.value || 20);
          if (!Number.isFinite(cur) || cur > 20) topicLimit.value = "20";
        }
      }

      function setExperienceMode(mode, push) {
        const next = normalizeExperienceMode(mode);
        if (state.experienceMode === next) return;
        state.experienceMode = next;
        resetConsumerProgressiveDisclosure();
        if (next === "consumer") {
          const sortSel = qs("#partySort");
          if (sortSel && String(sortSel.value || "") === "name") sortSel.value = "coverage";
        }
        renderExperienceModeUi();
        writeUrlState(Boolean(push));
        renderStatus();
        renderTopicList();
        renderCompare();
      }

      function concernLabelById(cid) {
        const token = String(cid || "").trim();
        if (!token) return "";
        const cobj = (state.concerns || []).find((c) => String(c.id || "") === token) || null;
        return cobj ? String(cobj.label || cobj.id || token) : token;
      }

      function concernDescriptionById(cid) {
        const token = String(cid || "").trim();
        if (!token) return "";
        const cobj = (state.concerns || []).find((c) => String(c.id || "") === token) || null;
        return cobj ? String(cobj.description || "").trim() : "";
      }

      function normalizeConcernPackId(v) {
        return String(v || "")
          .trim()
          .toLowerCase()
          .replace(/[^a-z0-9_]+/g, "_")
          .replace(/^_+|_+$/g, "");
      }

      function normalizeSelectedConcernIds(ids) {
        const raw = uniqKeepOrder(ids || []).slice(0, 6);
        const known = new Set((state.concerns || []).map((c) => String(c.id || "")).filter((x) => x));
        if (!known.size) return raw;
        return raw.filter((cid) => known.has(String(cid)));
      }

      function normalizeConcernPackConfig(pack) {
        if (!pack || typeof pack !== "object") return null;
        const id = normalizeConcernPackId(pack.id);
        const label = String(pack.label || id || "").trim();
        const concernIds = normalizeSelectedConcernIds(Array.isArray(pack.concern_ids) ? pack.concern_ids : []);
        const tradeoff = String(pack.tradeoff || "").trim();
        if (!id || concernIds.length < 2) return null;
        return { id, label: label || id, concern_ids: concernIds, tradeoff };
      }

      function concernSetKey(ids) {
        const arr = uniqKeepOrder(ids || [])
          .map((x) => String(x || "").trim())
          .filter((x) => x)
          .sort();
        return arr.join("|");
      }

      function concernPackById(packId) {
        const token = normalizeConcernPackId(packId);
        if (!token) return null;
        return (state.concernPacks || []).find((p) => String(p.id || "") === token) || null;
      }

      function concernPackQualityForPack(packId) {
        const token = normalizeConcernPackId(packId);
        if (!token) return null;
        return state.concernPackQualityById.get(token) || null;
      }

      function loadConcernPackQualityRows(report) {
        state.concernPackQuality = report && typeof report === "object" ? report : null;
        state.concernPackQualityById = new Map();
        const rows = report && Array.isArray(report.packs) ? report.packs : [];
        for (const raw of rows) {
          if (!raw || typeof raw !== "object") continue;
          const pid = normalizeConcernPackId(raw.pack_id);
          if (!pid) continue;
          state.concernPackQualityById.set(pid, raw);
        }
      }

      function detectConcernPackForSelection(ids) {
        const key = concernSetKey(ids);
        if (!key) return "";
        for (const pack of state.concernPacks || []) {
          if (concernSetKey(pack.concern_ids) === key) return String(pack.id || "");
        }
        return "";
      }

      function syncActiveConcernPackFromSelection() {
        state.activeConcernPackId = detectConcernPackForSelection(state.selectedConcernIds || []);
      }

      function recommendedConcernPack() {
        const packs = Array.isArray(state.concernPacks) ? state.concernPacks : [];
        if (!packs.length) return null;
        let best = null;
        let bestScore = -1;
        let bestCount = -1;
        for (const pack of packs) {
          const quality = concernPackQualityForPack(pack.id);
          const score = Number((quality || {}).quality_score || 0);
          const count = topicsForConcernIdsAll(pack.concern_ids || []).length;
          if (score > bestScore) {
            best = pack;
            bestScore = score;
            bestCount = count;
            continue;
          }
          if (score === bestScore && count > bestCount) {
            best = pack;
            bestCount = count;
            continue;
          }
          if (
            score === bestScore &&
            count === bestCount &&
            best &&
            String(pack.label || "").localeCompare(String(best.label || "")) < 0
          ) {
            best = pack;
          }
        }
        return best || packs[0] || null;
      }

      function applyConcernPack(packId, push, opts) {
        const pack = concernPackById(packId);
        if (!pack) return;
        const options = opts || {};
        const switchToDashboard = options.switchToDashboard !== false;
        state.selectedConcernIds = normalizeSelectedConcernIds(pack.concern_ids || []);
        if (!state.selectedConcernIds.length) return;
        state.activeConcernPackId = String(pack.id || "");
        if (!state.selectedConcernIds.includes(String(state.activeConcernId || ""))) {
          state.activeConcernId = state.selectedConcernIds[0] || "";
        }
        state.activeTopicId = 0;
        if (switchToDashboard) {
          state.viewMode = "dashboard";
          const viewSel = qs("#viewMode");
          if (viewSel) viewSel.value = "dashboard";
        }
        const quality = concernPackQualityForPack(pack.id);
        recordConcernPackOutcomeEvent("pack_selected", {
          pack_id: String(pack.id || ""),
          pack_weak: quality && typeof quality.weak === "boolean" ? Boolean(quality.weak) : null,
          concern_ids_count: state.selectedConcernIds.length,
          source: String(options.source || "pack_apply"),
        });
        writeUrlState(Boolean(push));
        renderSelectedConcernTags();
        renderConcernList();
        renderTopicList();
        renderCompare();
      }

      function currentAlignmentPresetForShare(packIdOverride) {
        const explicitPack = concernPackById(packIdOverride || "");
        const activePack = concernPackById(state.activeConcernPackId || "");
        const pack = explicitPack || activePack || null;
        const concerns = normalizeSelectedConcernIds(state.selectedConcernIds || []);
        return {
          method: String(state.method || "combined"),
          pack_id: pack ? String(pack.id || "") : "",
          concerns_ids: concerns,
          concern_id: String(state.activeConcernId || concerns[0] || ""),
        };
      }

      function renderConcernPackTags() {
        const el = qs("#concernPackTags");
        const hint = qs("#concernPackHint");
        if (!el) return;
        syncActiveConcernPackFromSelection();

        const packs = Array.isArray(state.concernPacks) ? state.concernPacks : [];
        if (!packs.length) {
          el.innerHTML = `<span class="tag">sin packs configurados</span>`;
          if (hint) hint.textContent = "";
          return;
        }

        const activePack = concernPackById(state.activeConcernPackId);
        el.innerHTML =
          packs
            .map((pack) => {
              const active = activePack && String(activePack.id || "") === String(pack.id || "");
              const count = Number((pack.concern_ids || []).length || 0);
              const quality = concernPackQualityForPack(pack.id);
              const weak = Boolean(quality && quality.weak);
              const scoreTxt = quality ? fmtPct01(Number(quality.quality_score || 0)) : "";
              const weakTitle =
                weak && quality && Array.isArray(quality.weak_reasons) && quality.weak_reasons.length
                  ? ` title="pack_debil: ${esc(String(quality.weak_reasons.join(",")))}"`
                  : "";
              return (
                `<button class="tag tagbtn md3-tab ${active ? "active" : ""}" type="button" data-pack-id="${esc(String(pack.id || ""))}"${
                  weak ? ' data-pack-weak="1"' : ""
                }${weakTitle}>` +
                `${esc(String(pack.label || pack.id || ""))} · ${esc(String(count))}` +
                (quality ? ` · ${esc(scoreTxt)}` : "") +
                (weak ? ` · weak` : "") +
                `</button>`
              );
            })
            .join("") +
          (activePack ? `<button class="tag tagbtn md3-tab" type="button" data-pack-share="1">Link alineamiento</button>` : "") +
          (activePack ? `<button class="tag tagbtn md3-tab" type="button" data-pack-clear="1">Personalizado</button>` : "");

        for (const btn of el.querySelectorAll("[data-pack-id]")) {
          btn.addEventListener("click", () => {
            const pid = String(btn.getAttribute("data-pack-id") || "");
            applyConcernPack(pid, true, { switchToDashboard: true, source: "pack_tag" });
          });
        }
        for (const btn of el.querySelectorAll("[data-pack-clear]")) {
          btn.addEventListener("click", () => {
            const prevPack = concernPackById(state.activeConcernPackId || "");
            const prevQuality = prevPack ? concernPackQualityForPack(prevPack.id) : null;
            recordConcernPackOutcomeEvent("pack_cleared", {
              pack_id: prevPack ? String(prevPack.id || "") : String(state.activeConcernPackId || ""),
              pack_weak: prevQuality && typeof prevQuality.weak === "boolean" ? Boolean(prevQuality.weak) : null,
              concern_ids_count: Number((state.selectedConcernIds || []).length || 0),
              source: "pack_clear_button",
            });
            state.activeConcernPackId = "";
            writeUrlState(true);
            renderConcernPackTags();
          });
        }
        for (const btn of el.querySelectorAll("[data-pack-share]")) {
          btn.addEventListener("click", async () => {
            const payload = currentAlignmentPresetForShare();
            const url = buildAlignmentPresetShareUrl(payload);
            const copied = await copyToClipboard(url);
            setBanner(
              `<div><strong>Preset de alineamiento</strong>: ${copied ? "copiado al portapapeles" : "no se pudo copiar automaticamente"}.</div>` +
                `<div style="margin-top:8px"><span class="mono">${esc(url)}</span></div>` +
                `<div style="margin-top:8px">Este enlace usa <span class="mono">#preset=...</span> (fragmento) para evitar filtrar preferencias en query.</div>`
            );
          });
        }

        if (hint) {
          if (activePack) {
            const tradeoff = String(activePack.tradeoff || "").trim();
            const quality = concernPackQualityForPack(activePack.id);
            const qualityScore = quality ? fmtPct01(Number(quality.quality_score || 0)) : "";
            const weak = Boolean(quality && quality.weak);
            const weakReasons =
              weak && quality && Array.isArray(quality.weak_reasons) && quality.weak_reasons.length
                ? String(quality.weak_reasons.join(", "))
                : "";
            hint.innerHTML =
              `<span class="tag">Pack activo: ${esc(String(activePack.label || activePack.id || ""))}</span>` +
              (quality ? ` <span class="tag">calidad=${esc(qualityScore)}</span>` : "") +
              (weak ? ` <span class="tag hot" data-pack-weak-hint="1">pack_debil</span>` : "") +
              (weakReasons ? ` <span>${esc(weakReasons)}</span>` : "") +
              (tradeoff ? ` <span>${esc(tradeoff)}</span>` : "");
          } else {
            hint.innerHTML = `<span class="tag">Tip</span> <span>si cambias preocupaciones manualmente, el estado pasa a personalizado.</span>`;
          }
        }
      }

      function ensureConcernState() {
        // After loading concerns + tags, normalize selected+active state and apply localStorage defaults
        // only when URL didn't provide them.
        const p = new URLSearchParams(location.search || "");
        const wantsPackId = normalizeConcernPackId(String(state.activeConcernPackId || p.get("concern_pack") || ""));
        if (wantsPackId) state.activeConcernPackId = wantsPackId;

        if (state.activeConcernPackId && !p.has("concerns_ids") && !p.has("concern")) {
          const pack = concernPackById(state.activeConcernPackId);
          if (pack) state.selectedConcernIds = normalizeSelectedConcernIds(pack.concern_ids || []);
        }

        const hasPackOverride = Boolean(state.activeConcernPackId && concernPackById(state.activeConcernPackId));
        if (!hasPackOverride && !p.has("concerns_ids") && !p.has("concern")) {
          const fromLs = normalizeSelectedConcernIds(parseCsvIds(lsGet(LS_SELECTED_CONCERNS)));
          if (fromLs.length) state.selectedConcernIds = fromLs;
        }
        state.selectedConcernIds = normalizeSelectedConcernIds(state.selectedConcernIds);

        if (!p.has("method")) {
          const m = String(lsGet(LS_METHOD) || "").trim();
          if (m) state.method = m;
        }
        if (!state.method) state.method = "combined";
        if (state.method !== "combined" && state.method !== "votes" && state.method !== "declared") state.method = "combined";

        if (!p.has("view")) {
          const v = String(lsGet(LS_VIEW) || "").trim();
          if (v === "dashboard" || v === "detail" || v === "alignment" || v === "coherence") state.viewMode = v;
        }
        if (state.viewMode !== "dashboard" && state.viewMode !== "detail" && state.viewMode !== "alignment" && state.viewMode !== "coherence")
          state.viewMode = "detail";

        if (!p.has("mode")) {
          state.experienceMode = normalizeExperienceMode(lsGet(LS_EXPERIENCE_MODE));
        } else {
          state.experienceMode = normalizeExperienceMode(state.experienceMode);
        }

        const known = new Set((state.concerns || []).map((c) => String(c.id || "")).filter((x) => x));
        if (known.size && state.activeConcernId && !known.has(String(state.activeConcernId))) {
          state.activeConcernId = "";
        }

        if (state.activeConcernId) {
          if (!state.selectedConcernIds.includes(String(state.activeConcernId))) {
            state.selectedConcernIds = normalizeSelectedConcernIds([String(state.activeConcernId)].concat(state.selectedConcernIds));
          }
        }

        if (!state.selectedConcernIds.length) {
          // Deterministic default: most-tagged concern.
          let best = "";
          let bestCount = -1;
          for (const c of state.concerns || []) {
            const cid = String(c.id || "");
            if (!cid) continue;
            const cnt = Number(state.countsByConcern.get(cid) || 0);
            if (cnt > bestCount) {
              best = cid;
              bestCount = cnt;
            }
          }
          if (best) state.selectedConcernIds = [best];
        }
        if (!state.activeConcernId) {
          state.activeConcernId = state.selectedConcernIds[0] || "";
        }
        syncActiveConcernPackFromSelection();

        const viewSel = qs("#viewMode");
        if (viewSel) viewSel.value = String(state.viewMode || "detail");
        renderExperienceModeUi();
        if (viewSel) viewSel.value = String(state.viewMode || "detail");
        const methodSel = qs("#methodSelect");
        if (methodSel) {
          const avail = new Set(((state.citizen || {}).meta || {}).methods_available || []);
          for (const opt of methodSel.querySelectorAll("option")) {
            const v = String(opt.value || "");
            opt.disabled = avail.size ? !avail.has(v) : false;
          }
          if (avail.size && !avail.has(String(state.method || ""))) {
            state.method = avail.has("combined") ? "combined" : String(Array.from(avail)[0] || "combined");
          }
          methodSel.value = String(state.method || "combined");
          methodSel.disabled = p.has("citizen") || state.viewMode === "coherence";
        }

        const sortSel = qs("#partySort");
        if (sortSel) {
          const covOpt = sortSel.querySelector('option[value="coverage"]');
          const confOpt = sortSel.querySelector('option[value="confidence"]');
          if (state.viewMode === "alignment") {
            if (covOpt) covOpt.textContent = "Orden: cobertura (comparables)";
            if (confOpt) confOpt.textContent = "Orden: match neto";
          } else {
            if (covOpt) covOpt.textContent = "Orden: cobertura";
            if (confOpt) confOpt.textContent = "Orden: confianza";
          }
        }
      }

      async function ensureCoherenceSnapshotsLoaded() {
        const coh = state.coherence;
        if (coh.loadError) throw new Error(String(coh.loadError || "coherence load error"));
        if (coh.votes && coh.declared && coh.combined) return;
        if (coh.promise) return await coh.promise;

        coh.loading = true;
        coh.loadError = "";

        coh.promise = (async () => {
          const baseMethod = String((state.citizen?.meta || {}).computed_method || "").trim();

          // Reuse the already-loaded base dataset when possible to avoid extra fetches.
          if (!coh.votes && baseMethod === "votes") {
            coh.votes = state.citizen;
            coh.votesTopicById = state.topicById;
            coh.votesPosByKey = state.posByKey;
          }
          if (!coh.declared && baseMethod === "declared") {
            coh.declared = state.citizen;
            coh.declaredTopicById = state.topicById;
            coh.declaredPosByKey = state.posByKey;
          }
          if (!coh.combined && baseMethod === "combined") {
            coh.combined = state.citizen;
            coh.combinedTopicById = state.topicById;
            coh.combinedPosByKey = state.posByKey;
          }

          if (!coh.votes) {
            coh.votes = await fetchJson("./data/citizen_votes.json");
            coh.votesTopicById = buildTopicByIdMap(coh.votes);
            coh.votesPosByKey = buildPosByKeyMap(coh.votes);
          }
          if (!coh.declared) {
            coh.declared = await fetchJson("./data/citizen_declared.json");
            coh.declaredTopicById = buildTopicByIdMap(coh.declared);
            coh.declaredPosByKey = buildPosByKeyMap(coh.declared);
          }
          if (!coh.combined) {
            coh.combined = await fetchJson("./data/citizen.json");
            coh.combinedTopicById = buildTopicByIdMap(coh.combined);
            coh.combinedPosByKey = buildPosByKeyMap(coh.combined);
          }

          const topicsCounts = [coh.votes, coh.declared, coh.combined].map((x) => (x && x.topics ? x.topics.length : 0));
          const partiesCounts = [coh.votes, coh.declared, coh.combined].map((x) => (x && x.parties ? x.parties.length : 0));
          const sameTopics = topicsCounts.every((n) => n === topicsCounts[0]);
          const sameParties = partiesCounts.every((n) => n === partiesCounts[0]);
          if (!sameTopics || !sameParties) {
            throw new Error(
              `Dataset mismatch (topics=${topicsCounts.join(",")} parties=${partiesCounts.join(",")}). Rebuild GH Pages artifacts.`
            );
          }
        })()
          .catch((err) => {
            coh.loadError = String(err?.message || err || "coherence load failed");
            throw err;
          })
          .finally(() => {
            coh.loading = false;
            coh.promise = null;
          });

        return await coh.promise;
      }

      function renderSelectedConcernTags() {
        const el = qs("#selectedConcernTags");
        if (!el) return;
        const ids = normalizeSelectedConcernIds(state.selectedConcernIds || []);
        state.selectedConcernIds = ids;

        if (!ids.length) {
          el.innerHTML = `<span class="tag">ninguna</span>`;
          renderConcernPackTags();
          return;
        }

        el.innerHTML = ids
          .map((cid) => {
            const label = concernLabelById(cid) || cid;
            const active = state.activeConcernId && String(state.activeConcernId) === String(cid);
            return (
              `<button class="tag tagbtn md3-tab ${active ? "active" : ""}" type="button" data-sel-cid="${esc(cid)}">` +
              `${esc(label)} <span class="mono">x</span>` +
              `</button>`
            );
          })
          .join("");

        for (const btn of el.querySelectorAll("[data-sel-cid]")) {
          btn.addEventListener("click", () => {
            const cid = String(btn.getAttribute("data-sel-cid") || "");
            removeSelectedConcern(cid, true);
          });
        }

        renderConcernPackTags();
      }

      function removeSelectedConcern(cid, push) {
        const token = String(cid || "").trim();
        if (!token) return;
        const cur = normalizeSelectedConcernIds(state.selectedConcernIds || []);
        const next = cur.filter((x) => String(x) !== token);
        if (!next.length) return; // keep at least one
        state.selectedConcernIds = next;
        if (String(state.activeConcernId || "") === token) {
          state.activeConcernId = next[0] || "";
          state.activeTopicId = 0;
        }
        writeUrlState(Boolean(push));
        renderSelectedConcernTags();
        renderConcernList();
        renderTopicList();
        renderCompare();
      }

      function renderConcernList() {
        const list = qs("#concernList");
        if (!list) return;

        const needle = norm(qs("#concernSearch")?.value || "");

        const rows = (state.concerns || [])
          .map((c) => {
            const cid = String(c.id || "");
            const label = String(c.label || cid);
            const desc = String(c.description || "").trim();
            const count = Number(state.countsByConcern.get(cid) || 0);
            const labelN = norm(label);
            if (needle && !labelN.includes(needle) && !norm(cid).includes(needle)) return null;
            return { cid, label, desc, count };
          })
          .filter(Boolean)
          .sort((a, b) => {
            if (b.count !== a.count) return b.count - a.count;
            return a.label.localeCompare(b.label);
          });

        if (!rows.length) {
          list.innerHTML = `<div class="empty">No hay coincidencias para el filtro.</div>`;
          return;
        }

        list.innerHTML = rows
          .map((r) => {
            const active = state.activeConcernId && r.cid === state.activeConcernId;
            const selected = (state.selectedConcernIds || []).includes(r.cid);
            return (
              `<div class="row ${active ? "active" : ""}" data-cid="${esc(r.cid)}" role="button" tabindex="0">` +
              `<div class="rowTitle"><strong>${esc(r.label)}</strong><span class="tags">` +
              `<span class="tag">${fmtInt(r.count)} items</span>` +
              (selected ? `<span class="tag">dashboard</span>` : ``) +
              `</span></div>` +
              `<div class="rowMeta">` +
              `<span class="tag">${selected ? "en dashboard" : "puedes agregarla al dashboard"}</span>` +
              (r.desc ? `<span>${esc(r.desc)}</span>` : ``) +
              `</div>` +
              `</div>`
            );
          })
          .join("");

        for (const el of list.querySelectorAll("[data-cid]")) {
          el.addEventListener("click", () => {
            selectConcern(String(el.getAttribute("data-cid") || ""), true);
          });
          el.addEventListener("keydown", (ev) => {
            if (ev.key === "Enter" || ev.key === " ") {
              ev.preventDefault();
              selectConcern(String(el.getAttribute("data-cid") || ""), true);
            }
          });
        }
      }

      function topicsForConcernAll(cid) {
        const token = String(cid || "").trim();
        if (!token) return [];
        const out = [];
        for (const t of state.citizen.topics || []) {
          const tid = Number(t.topic_id || 0);
          const tags = state.topicTags.get(tid) || [];
          if (!tags.includes(token)) continue;
          out.push(t);
        }
        out.sort((a, b) => {
          const ah = a.is_high_stakes ? 1 : 0;
          const bh = b.is_high_stakes ? 1 : 0;
          if (bh !== ah) return bh - ah;
          const ar = a.stakes_rank == null ? 999999 : Number(a.stakes_rank);
          const br = b.stakes_rank == null ? 999999 : Number(b.stakes_rank);
          if (ar !== br) return ar - br;
          return Number(a.topic_id) - Number(b.topic_id);
        });
        return out;
      }

      function topicsForConcernIdsAll(cids) {
        const ids = uniqKeepOrder(cids || []).map((x) => String(x || "").trim()).filter((x) => x);
        if (!ids.length) return [];
        const want = new Set(ids);

        const out = [];
        for (const t of state.citizen.topics || []) {
          const tid = Number(t.topic_id || 0);
          const tags = state.topicTags.get(tid) || [];
          if (!tags.some((x) => want.has(String(x)))) continue;
          out.push(t);
        }
        out.sort((a, b) => {
          const ah = a.is_high_stakes ? 1 : 0;
          const bh = b.is_high_stakes ? 1 : 0;
          if (bh !== ah) return bh - ah;
          const ar = a.stakes_rank == null ? 999999 : Number(a.stakes_rank);
          const br = b.stakes_rank == null ? 999999 : Number(b.stakes_rank);
          if (ar !== br) return ar - br;
          return Number(a.topic_id) - Number(b.topic_id);
        });
        return out;
      }

      function computeFirstAnswerPlanFromState() {
        const concerns = Array.isArray(state.concerns)
          ? state.concerns.map((c) => ({
              id: String(c.id || ""),
              label: String(c.label || c.id || ""),
            }))
          : [];
        const topics = Array.isArray(state.citizen && state.citizen.topics)
          ? state.citizen.topics.map((t) => {
              const tid = Number(t.topic_id || 0);
              return {
                topic_id: tid,
                label: String(t.label || ""),
                stakes_rank: t.stakes_rank == null ? null : Number(t.stakes_rank),
                is_high_stakes: Boolean(t.is_high_stakes),
                concern_ids: (state.topicTags.get(tid) || []).slice(),
                links: t.links || {},
              };
            })
          : [];
        const parties = Array.isArray(state.citizen && state.citizen.parties) ? state.citizen.parties : [];
        const positions = Array.isArray(state.citizen && state.citizen.party_topic_positions)
          ? state.citizen.party_topic_positions
          : [];

        if (
          typeof CitizenFirstAnswerAccelerator !== "undefined" &&
          CitizenFirstAnswerAccelerator &&
          typeof CitizenFirstAnswerAccelerator.computeFirstAnswerPlan === "function"
        ) {
          return CitizenFirstAnswerAccelerator.computeFirstAnswerPlan({
            concerns,
            topics,
            parties,
            positions,
          });
        }

        return {
          accelerator_version: "first_answer_fallback",
          concerns_total: concerns.length,
          topics_total: topics.length,
          parties_total: parties.length,
          positions_total: positions.length,
          concern_rank: [],
          recommended: null,
          fallback_used: true,
          reason: "accelerator_missing",
        };
      }

      function firstAnswerRecommendation() {
        const plan = state.firstAnswerPlan || null;
        const rec = plan && plan.recommended ? plan.recommended : null;
        if (!rec) return null;
        const cid = String(rec.concern_id || "").trim();
        const tid = Number(rec.topic_id || 0);
        if (!cid || !Number.isFinite(tid) || tid <= 0) return null;
        return rec;
      }

      function runFirstAnswerRecommendation(push) {
        const rec = firstAnswerRecommendation();
        if (!rec) return false;
        const cid = String(rec.concern_id || "").trim();
        const tid = Number(rec.topic_id || 0);
        if (!cid || !Number.isFinite(tid) || tid <= 0) return false;

        state.activeConcernId = cid;
        state.selectedConcernIds = normalizeSelectedConcernIds([cid].concat(state.selectedConcernIds || []));
        state.activeTopicId = tid;
        state.viewMode = "alignment";
        const viewSel = qs("#viewMode");
        if (viewSel) viewSel.value = "alignment";

        writeUrlState(Boolean(push));
        renderSelectedConcernTags();
        renderConcernList();
        renderTopicList();
        renderCompare();
        return true;
      }

      function unknownExplainabilityModule() {
        const mod = window.CitizenUnknownExplainability || null;
        if (!mod || typeof mod.buildUnknownExplainability !== "function") return null;
        return mod;
      }

      function buildUnknownExplainability(input) {
        const i = input || {};
        const mod = unknownExplainabilityModule();
        if (mod) return mod.buildUnknownExplainability(i);

        const counts = i.counts && typeof i.counts === "object" ? i.counts : {};
        const nn = (v) => {
          const n = Number(v);
          if (!Number.isFinite(n) || n <= 0) return 0;
          return n;
        };
        const support = nn(counts.support);
        const oppose = nn(counts.oppose);
        const mixed = nn(counts.mixed);
        const unclear = nn(counts.unclear);
        const noSignal = nn(counts.no_signal);
        const totalRaw = Number(i.total);
        const total = Number.isFinite(totalRaw) && totalRaw > 0 ? totalRaw : support + oppose + mixed + unclear + noSignal;
        const clearTotal = support + oppose + mixed;
        const unknownTotal = unclear + noSignal;
        const coverageRatio = total > 0 ? clearTotal / total : 0;
        let dominant = "none";
        if (unknownTotal > 0) {
          const noSignalShare = noSignal / unknownTotal;
          const unclearShare = unclear / unknownTotal;
          if (noSignalShare >= 0.6) dominant = "no_signal";
          else if (unclearShare >= 0.6) dominant = "unclear";
          else dominant = "mixed";
        }
        let reasonLabel = "sin unknown";
        let reduceUncertainty = "Mantener cobertura y trazabilidad actuales.";
        if (dominant === "no_signal") {
          reasonLabel = "unknown dominado por sin_senal";
          reduceUncertainty = "Reducir incertidumbre: sumar evidencia verificable (votos, iniciativas o textos enlazados).";
        } else if (dominant === "unclear") {
          reasonLabel = coverageRatio < 0.2 ? "unknown por cobertura baja" : "unknown por senal ambigua";
          reduceUncertainty = "Reducir incertidumbre: subir cobertura clara y revisar los casos inciertos.";
        } else if (dominant === "mixed") {
          reasonLabel = "unknown mixto";
          reduceUncertainty = "Reducir incertidumbre: cerrar huecos sin_senal y resolver casos inciertos prioritarios.";
        }
        return {
          explainability_version: "unknown_explainability_fallback",
          total,
          clear_total: clearTotal,
          unknown_total: unknownTotal,
          unknown_ratio: total > 0 ? unknownTotal / total : 0,
          dominant_unknown: dominant,
          reason_label: reasonLabel,
          reduce_uncertainty: reduceUncertainty,
          should_show: Boolean(total > 0 && unknownTotal > 0),
        };
      }

      function renderUnknownExplainabilityHint(input, kind) {
        const x = buildUnknownExplainability(input || {});
        if (!x || !x.should_show) return "";
        const mode = String(kind || "card");
        const cls = mode === "summary" ? "rowMeta" : "partyMeta";
        const attr = mode === "summary" ? ' data-unknown-explainability-summary="1"' : ' data-unknown-explainability="1"';
        return (
          `<div class="${cls}"${attr}>` +
          `<span class="tag">unknown=${esc(fmtInt(Number(x.unknown_total || 0)))}/${esc(fmtInt(Number(x.total || 0)))} (${esc(
            fmtPct01(Number(x.unknown_ratio || 0))
          )})</span>` +
          `<span class="tag">${esc(String(x.reason_label || ""))}</span>` +
          `<span>${esc(String(x.reduce_uncertainty || ""))}</span>` +
          `</div>`
        );
      }

      function evidenceTrustPanelModule() {
        const mod = window.CitizenEvidenceTrustPanel || null;
        if (!mod || typeof mod.buildEvidenceTrustPanel !== "function") return null;
        return mod;
      }

      function parseDateOnlyMs(v) {
        const s = String(v || "").trim();
        if (!s) return null;
        if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) return null;
        const ms = Date.parse(`${s}T00:00:00Z`);
        if (!Number.isFinite(ms)) return null;
        return ms;
      }

      function buildEvidenceTrustPanel(input) {
        const i = input || {};
        const mod = evidenceTrustPanelModule();
        if (mod) return mod.buildEvidenceTrustPanel(i);

        const linksRaw = i.links && typeof i.links === "object" ? i.links : {};
        const links = {
          explorer_temas: String(linksRaw.explorer_temas || "").trim(),
          explorer_positions: String(linksRaw.explorer_positions || "").trim(),
          explorer_evidence: String(linksRaw.explorer_evidence || "").trim(),
        };
        const coverage = i.coverage && typeof i.coverage === "object" ? i.coverage : {};
        const membersTotal = Math.max(0, Number(coverage.members_total || 0));
        const membersSignal = Math.max(0, Number(coverage.members_with_signal || 0));
        const coverageRatioRaw = i.coverage_ratio == null ? (membersTotal > 0 ? membersSignal / membersTotal : 0) : Number(i.coverage_ratio || 0);
        const coverageRatio = Number.isFinite(coverageRatioRaw) ? Math.max(0, Math.min(1, coverageRatioRaw)) : 0;
        const evidenceCount = Math.max(0, Number(i.evidence_count_total != null ? i.evidence_count_total : coverage.evidence_count_total || 0));
        const asOf = String(i.as_of_date || "").trim();
        const lastEvidenceDate = String(i.last_evidence_date || coverage.last_evidence_date || "").trim();
        const asOfMs = parseDateOnlyMs(asOf);
        const lastMs = parseDateOnlyMs(lastEvidenceDate);
        const ageDays = asOfMs != null && lastMs != null ? Math.max(0, Math.floor((asOfMs - lastMs) / 86400000)) : null;
        const tier = ageDays == null ? "unknown" : ageDays <= 30 ? "fresh" : ageDays <= 120 ? "aging" : "stale";
        const drilldownTotal =
          Number(Boolean(links.explorer_temas)) +
          Number(Boolean(links.explorer_positions)) +
          Number(Boolean(links.explorer_evidence));
        const hasDrilldown = drilldownTotal > 0;
        const method = String(i.computed_method || i.method || "combined").trim() || "combined";
        const methodLabel = method === "votes" ? "votos" : method === "declared" ? "dichos" : "combinado";

        return {
          panel_version: "evidence_trust_panel_fallback",
          method,
          method_label: methodLabel,
          as_of_date: asOf || null,
          last_evidence_date: lastEvidenceDate || null,
          source_age_days: ageDays,
          freshness_tier: tier,
          freshness_label: tier === "fresh" ? "reciente" : tier === "aging" ? "vigente" : tier === "stale" ? "antigua" : "desconocida",
          coverage_ratio: Number(coverageRatio.toFixed(6)),
          evidence_count_total: Math.trunc(evidenceCount),
          members_total: Math.trunc(membersTotal),
          members_with_signal: Math.trunc(membersSignal),
          trust_level: tier === "fresh" && coverageRatio >= 0.5 && hasDrilldown ? "high" : coverageRatio >= 0.25 && hasDrilldown ? "medium" : "low",
          trust_reasons: [],
          links,
          drilldown_total: drilldownTotal,
          has_drilldown: hasDrilldown,
          should_show: true,
        };
      }

      function renderEvidenceTrustPanel(input, kind) {
        const x = buildEvidenceTrustPanel(input || {});
        if (!x || !x.should_show) return "";
        const mode = String(kind || "card");
        const cls = mode === "summary" ? "rowMeta" : "partyMeta";
        const tier = String(x.freshness_tier || "unknown");
        const methodLabel = String(x.method_label || x.method || "?");
        const age = x.source_age_days == null ? "?" : `${String(x.source_age_days)}d`;
        const cov = fmtPct01(Number(x.coverage_ratio || 0));
        const evCount = fmtInt(Number(x.evidence_count_total || 0));
        const linkTemas = String((x.links || {}).explorer_temas || "");
        const linkPos = String((x.links || {}).explorer_positions || "");
        const linkEv = String((x.links || {}).explorer_evidence || "");
        return (
          `<div class="${cls}" data-evidence-trust-panel="1">` +
          `<span class="tag" data-evidence-trust-freshness="${esc(tier)}">fuente_${esc(tier)}</span>` +
          `<span class="tag">edad_fuente=${esc(age)}</span>` +
          `<span class="tag">metodo=${esc(methodLabel)}</span>` +
          `<span class="tag">cobertura=${esc(cov)}</span>` +
          `<span class="tag">evidencia=${esc(evCount)}</span>` +
          (linkTemas ? `<a class="smallLink" href="${esc(linkTemas)}" target="_blank" rel="noopener noreferrer">Tema</a>` : "") +
          (linkPos ? `<a class="smallLink" href="${esc(linkPos)}" target="_blank" rel="noopener noreferrer">Posiciones</a>` : "") +
          (linkEv ? `<a class="smallLink" href="${esc(linkEv)}" target="_blank" rel="noopener noreferrer">Evidencia</a>` : "") +
          `</div>`
        );
      }

      function trustActionNudgeModule() {
        const mod = window.CitizenEvidenceTrustPanel || null;
        if (!mod || typeof mod.buildTrustActionNudge !== "function") return null;
        return mod;
      }

      function buildTrustActionNudge(input) {
        const i = input || {};
        const mod = trustActionNudgeModule();
        if (mod) return mod.buildTrustActionNudge(i);

        const rows = Array.isArray(i.rows) ? i.rows : [];
        let best = null;
        for (const raw of rows) {
          const row = raw && typeof raw === "object" ? raw : {};
          const links = row.links && typeof row.links === "object" ? row.links : {};
          const linkTarget = String(links.explorer_evidence || "").trim();
          if (!linkTarget) continue;
          const trustLevel = String(row.trust_level || "low").trim().toLowerCase();
          const stance = String(row.stance || "no_signal").trim().toLowerCase();
          const coverageRatio = Math.max(0, Math.min(1, Number(row.coverage_ratio || 0)));
          const trustScore = trustLevel === "low" ? 3 : trustLevel === "medium" ? 2 : 1;
          const unknownScore = stance === "unclear" || stance === "no_signal" ? 2 : 0;
          const score = trustScore * 2 + unknownScore * 2 + (1 - coverageRatio);
          const candidate = {
            party_id: Number(row.party_id || 0) > 0 ? Number(row.party_id || 0) : null,
            party_label: String(row.party_label || row.party || row.name || "partido"),
            trust_level: trustLevel || "low",
            stance: stance || "no_signal",
            coverage_ratio: coverageRatio,
            link_target: linkTarget,
            score,
          };
          if (!best) {
            best = candidate;
            continue;
          }
          if (candidate.score > best.score) {
            best = candidate;
            continue;
          }
          if (candidate.score === best.score) {
            const byLabel = String(candidate.party_label || "").localeCompare(String(best.party_label || ""));
            if (byLabel < 0) best = candidate;
          }
        }
        if (!best) {
          return {
            nudge_version: "trust_action_nudge_fallback",
            should_show: false,
            available_candidates_total: 0,
            selected: null,
          };
        }
        const concernId = String(i.concern_id || "").trim();
        const topicId = Number(i.topic_id || 0) > 0 ? Number(i.topic_id || 0) : null;
        const viewMode = String(i.view_mode || state.viewMode || "detail");
        const nudgeId = `${String(viewMode)}:${concernId || "none"}:${topicId || "none"}:${best.party_id || "none"}`;
        const locationLabel = String(i.topic_label || i.concern_label || "este bloque");
        return {
          nudge_version: "trust_action_nudge_fallback",
          should_show: true,
          available_candidates_total: 1,
          selected: {
            ...best,
            nudge_id: String(nudgeId).toLowerCase().replace(/[^a-z0-9:_-]+/g, "_"),
            kind: "evidence_click",
            view_mode: String(viewMode || "detail"),
            concern_id: concernId || null,
            topic_id: topicId,
            reason_code: "audit_next",
            reason_label: "siguiente paso recomendado de auditoria",
            message_short: `Siguiente paso: abrir evidencia de ${String(best.party_label || "partido")}`,
            message_long: `Revisa evidencia directa en ${locationLabel}.`,
          },
        };
      }

      function renderTrustActionNudge(input) {
        const nudge = buildTrustActionNudge(input || {});
        if (!nudge || !nudge.should_show || !nudge.selected) return "";
        const sel = nudge.selected || {};
        const nudgeId = String(sel.nudge_id || "").trim();
        const sid = TRUST_ACTION_NUDGE_SESSION_ID;
        const shownKey = `${sid}:${nudgeId}`;
        if (nudgeId && !trustActionNudgeTelemetry.shownNudgeKeys.has(shownKey)) {
          recordTrustActionNudgeEvent("trust_action_nudge_shown", {
            nudge_id: nudgeId,
            nudge_kind: String(sel.kind || "evidence_click"),
            source_view: String(sel.view_mode || state.viewMode || "detail"),
            trust_level: String(sel.trust_level || ""),
            stance: String(sel.stance || ""),
            party_id: Number(sel.party_id || 0),
            topic_id: Number(sel.topic_id || 0),
            concern_id: String(sel.concern_id || ""),
            link_target: String(sel.link_target || ""),
            session_id: sid,
          });
          renderStatus();
        }
        return (
          `<div class="rowMeta" data-trust-action-nudge="1">` +
          `<span class="tag">trust_next_evidence</span>` +
          `<span class="tag">party=${esc(String(sel.party_label || "?"))}</span>` +
          `<span class="tag">trust=${esc(String(sel.trust_level || "low"))}</span>` +
          `<span>${esc(String(sel.message_short || "Siguiente paso recomendado"))}</span>` +
          `<a class="smallLink" data-trust-action-nudge-link="1" data-nudge-id="${esc(String(nudgeId))}" data-source-view="${esc(
            String(sel.view_mode || state.viewMode || "detail")
          )}" data-trust-level="${esc(String(sel.trust_level || ""))}" data-stance="${esc(
            String(sel.stance || "")
          )}" data-party-id="${esc(String(sel.party_id || ""))}" data-topic-id="${esc(String(sel.topic_id || ""))}" data-concern-id="${esc(
            String(sel.concern_id || "")
          )}" href="${esc(String(sel.link_target || ""))}" target="_blank" rel="noopener noreferrer">Ver evidencia sugerida</a>` +
          `</div>`
        );
      }

      function wireTrustActionNudgeLinks(root) {
        const el = root || qs("#compare");
        if (!el) return;
        for (const link of el.querySelectorAll("[data-trust-action-nudge-link]")) {
          link.addEventListener("click", () => {
            recordTrustActionNudgeEvent("trust_action_nudge_clicked", {
              nudge_id: String(link.getAttribute("data-nudge-id") || ""),
              source_view: String(link.getAttribute("data-source-view") || state.viewMode || "detail"),
              trust_level: String(link.getAttribute("data-trust-level") || ""),
              stance: String(link.getAttribute("data-stance") || ""),
              party_id: Number(link.getAttribute("data-party-id") || 0),
              topic_id: Number(link.getAttribute("data-topic-id") || 0),
              concern_id: String(link.getAttribute("data-concern-id") || ""),
              link_target: String(link.getAttribute("href") || ""),
              session_id: TRUST_ACTION_NUDGE_SESSION_ID,
            });
            renderStatus();
          });
        }
      }

      function crossMethodStabilityModule() {
        const mod = window.CitizenCrossMethodStability || null;
        if (!mod || typeof mod.buildCrossMethodStability !== "function") return null;
        return mod;
      }

      function buildCrossMethodStability(input) {
        const i = input || {};
        const mod = crossMethodStabilityModule();
        if (mod) return mod.buildCrossMethodStability(i);

        const rows = Array.isArray(i.rows) ? i.rows : [];
        const normStance = (v) => {
          const s = String(v || "").trim().toLowerCase().replaceAll("-", "_").replaceAll(" ", "_");
          if (s === "support" || s === "oppose" || s === "mixed" || s === "unclear" || s === "no_signal") return s;
          return "no_signal";
        };
        const isComparable = (s) => {
          const k = normStance(s);
          return k === "support" || k === "oppose";
        };
        const pairStats = (a, b) => {
          let comparable = 0;
          let mismatch = 0;
          for (const row of rows) {
            const sa = normStance(row[a]);
            const sb = normStance(row[b]);
            if (isComparable(sa) && isComparable(sb)) {
              comparable += 1;
              if (sa !== sb) mismatch += 1;
            }
          }
          return {
            total_cells: rows.length,
            comparable,
            comparable_pct_total: rows.length > 0 ? comparable / rows.length : 0,
            mismatch,
            mismatch_pct_of_comparable: comparable > 0 ? mismatch / comparable : 0,
          };
        };
        const votesDeclared = pairStats("votes", "declared");
        const combinedVotes = pairStats("combined", "votes");
        const combinedDeclared = pairStats("combined", "declared");
        const reasons = [];
        if (votesDeclared.comparable_pct_total < 0.15) reasons.push("low_votes_declared_comparable");
        if (votesDeclared.comparable > 0 && votesDeclared.mismatch_pct_of_comparable >= 0.35) reasons.push("high_votes_declared_mismatch");
        const weightedStability = Math.max(
          0,
          Math.min(1, 1 - (votesDeclared.mismatch_pct_of_comparable + combinedVotes.mismatch_pct_of_comparable + combinedDeclared.mismatch_pct_of_comparable) / 3)
        );
        return {
          stability_version: "cross_method_stability_fallback",
          total_cells: rows.length,
          pair_stats: {
            votes_declared: votesDeclared,
            combined_votes: combinedVotes,
            combined_declared: combinedDeclared,
          },
          weighted_stability_score: Number(weightedStability.toFixed(6)),
          status: reasons.length ? "uncertain" : weightedStability >= 0.8 ? "stable" : weightedStability >= 0.55 ? "mixed" : "unstable",
          uncertainty_level: reasons.includes("low_votes_declared_comparable") ? "high" : "low",
          uncertainty_reasons: reasons,
          reason_label: reasons.length ? "comparables bajos entre votos y dichos" : "estabilidad sin alertas fuertes",
          reason_detail: reasons.length
            ? "La comparabilidad votes-vs-declared cae por debajo del umbral operativo."
            : "No se detectan señales fuertes de inestabilidad para este corte.",
          should_show: rows.length > 0,
        };
      }

      function renderCrossMethodStabilityPanel(input, kind) {
        const x = buildCrossMethodStability(input || {});
        if (!x || !x.should_show) return "";
        const mode = String(kind || "summary");
        const cls = mode === "card" ? "partyMeta" : "rowMeta";
        const vd = (x.pair_stats || {}).votes_declared || {};
        const cv = (x.pair_stats || {}).combined_votes || {};
        const cd = (x.pair_stats || {}).combined_declared || {};
        return (
          `<div class="${cls}" data-cross-method-stability="1" data-cross-method-status="${esc(String(x.status || ""))}">` +
          `<span class="tag">estabilidad=${esc(String(x.status || "unknown"))}</span>` +
          `<span class="tag">score=${esc(fmtPct01(Number(x.weighted_stability_score || 0)))}</span>` +
          `<span class="tag">vd_comp=${esc(fmtPct01(Number(vd.comparable_pct_total || 0)))}</span>` +
          `<span class="tag">vd_mismatch=${esc(fmtPct01(Number(vd.mismatch_pct_of_comparable || 0)))}</span>` +
          `<span class="tag">cv_mismatch=${esc(fmtPct01(Number(cv.mismatch_pct_of_comparable || 0)))}</span>` +
          `<span class="tag">cd_mismatch=${esc(fmtPct01(Number(cd.mismatch_pct_of_comparable || 0)))}</span>` +
          `<span class="tag" data-cross-method-uncertainty="${esc(String(x.uncertainty_level || ""))}">incertidumbre=${esc(
            String(x.uncertainty_level || "low")
          )}</span>` +
          `<span>${esc(String(x.reason_label || ""))}</span>` +
          `</div>`
        );
      }

      function unknownCountsForTopicStance(stance) {
        const counts = { support: 0, oppose: 0, mixed: 0, unclear: 0, no_signal: 0 };
        const s = String(stance || "");
        if (counts[s] != null) counts[s] = 1;
        return counts;
      }

      function recommendedOnboardingTopicForConcern(concernId) {
        const topics = topicsForConcernAll(String(concernId || ""));
        return topics.length ? topics[0] : null;
      }

      function recommendedOnboardingTopic() {
        return recommendedOnboardingTopicForConcern(String(state.activeConcernId || ""));
      }

      function computeOnboardingContract(input) {
        if (
          typeof CitizenOnboardingFunnel !== "undefined" &&
          CitizenOnboardingFunnel &&
          typeof CitizenOnboardingFunnel.computeFunnelState === "function"
        ) {
          return CitizenOnboardingFunnel.computeFunnelState(input || {});
        }
        const i = input || {};
        const requiredDone = [Boolean(i.concernReady), Boolean(i.topicReady), Boolean(i.alignmentReady), Boolean(i.preferenceReady)].filter(
          (x) => x
        ).length;
        return {
          checks: {
            pack_ready: Boolean(i.packReady),
            concern_ready: Boolean(i.concernReady),
            topic_ready: Boolean(i.topicReady),
            alignment_ready: Boolean(i.alignmentReady),
            preference_ready: Boolean(i.preferenceReady),
          },
          signals: {
            has_recommended_pack: Boolean(i.hasRecommendedPack),
            has_recommended_concern: Boolean(i.hasRecommendedConcern),
            has_recommended_topic: Boolean(i.hasRecommendedTopic),
          },
          required_total: 4,
          required_done: requiredDone,
          required_completion_pct: Number((requiredDone / 4).toFixed(6)),
          steps: [],
          next_action: { id: "done", label: "Onboarding completo", reason: "fallback" },
        };
      }

      function openOnboardingTopic(tid) {
        const topicId = Number(tid || 0);
        if (!Number.isFinite(topicId) || topicId <= 0) return false;
        state.activeTopicId = topicId;
        const activePack = concernPackById(state.activeConcernPackId || "");
        if (activePack) {
          const quality = concernPackQualityForPack(activePack.id);
          recordConcernPackOutcomeEvent("topic_open_with_pack", {
            pack_id: String(activePack.id || ""),
            pack_weak: quality && typeof quality.weak === "boolean" ? Boolean(quality.weak) : null,
            topic_id: topicId,
            concern_ids_count: Number((state.selectedConcernIds || []).length || 0),
            source: "onboarding_open_topic",
          });
        }
        writeUrlState(true);
        renderSelectedConcernTags();
        renderConcernList();
        renderTopicList();
        renderCompare();
        return true;
      }

      function goOnboardingAlignment(recTid) {
        state.viewMode = "alignment";
        const viewSel = qs("#viewMode");
        if (viewSel) viewSel.value = "alignment";
        if (!state.activeTopicId && recTid) state.activeTopicId = Number(recTid);
        writeUrlState(true);
        ensureConcernState();
        renderSelectedConcernTags();
        renderConcernList();
        renderTopicList();
        renderCompare();
        return true;
      }

      function runOnboardingAction(actionId, ctx) {
        const action = String(actionId || "").trim();
        const c = ctx || {};
        const recPackId = String(c.recPackId || "").trim();
        const recConcernId = String(c.recConcernId || "").trim();
        const recTid = Number(c.recTid || 0);

        if (action === "apply_pack") {
          if (!recPackId) return false;
          applyConcernPack(recPackId, true, { switchToDashboard: true, source: "onboarding_apply_pack" });
          return true;
        }
        if (action === "select_concern") {
          if (!recConcernId) return false;
          selectConcern(recConcernId, true);
          return true;
        }
        if (action === "open_topic") return openOnboardingTopic(recTid);
        if (action === "open_alignment") return goOnboardingAlignment(recTid);
        if (action === "set_preference") {
          if (!state.activeTopicId && recTid) openOnboardingTopic(recTid);
          goOnboardingAlignment(recTid);
          setBanner(
            `<div><strong>Siguiente paso</strong>: marca tu postura en un item con <span class="mono">Yo: a favor</span> o <span class="mono">Yo: en contra</span> para activar match/mismatch por partido.</div>`
          );
          return true;
        }
        if (action === "done") {
          setOnboardingDismissed(true);
          renderOnboarding();
          return true;
        }
        return false;
      }

      function renderOnboarding() {
        const box = qs("#onboard");
        if (!box || !state.citizen) return;
        if (isConsumerMode()) {
          box.style.display = "none";
          box.innerHTML = "";
          return;
        }

        const prefsReady = Boolean(state.prefs && state.prefs.size > 0);
        if (prefsReady || onboardingDismissed()) {
          box.style.display = "none";
          box.innerHTML = "";
          return;
        }

        const concernReady = Boolean(String(state.activeConcernId || "").trim());
        const topicReady = Number(state.activeTopicId || 0) > 0;
        const alignReady = String(state.viewMode || "") === "alignment";
        const recPack = recommendedConcernPack();
        const recPackId = recPack ? String(recPack.id || "") : "";
        const recPackLabel = recPack ? String(recPack.label || recPackId) : "";
        const packReady = Boolean(state.activeConcernPackId && concernPackById(state.activeConcernPackId));
        const accelRec = firstAnswerRecommendation();
        const accelConcernId = accelRec ? String(accelRec.concern_id || "").trim() : "";
        const accelConcernLabel = accelRec ? String(accelRec.concern_label || accelConcernId || "") : "";
        const accelTid = accelRec ? Number(accelRec.topic_id || 0) : 0;
        const accelTopicLabel = accelRec ? String(accelRec.topic_label || `topic_id=${accelTid}`) : "";
        const accelScore = accelRec ? Number(accelRec.score || 0) : 0;
        const accelLinks = accelRec && accelRec.links ? accelRec.links : {};
        const recConcernId = String(
          state.activeConcernId ||
            accelConcernId ||
            (state.selectedConcernIds || [])[0] ||
            (recPack && recPack.concern_ids ? recPack.concern_ids[0] : "")
        ).trim();
        let rec = recommendedOnboardingTopicForConcern(recConcernId);
        if ((!rec || Number(rec.topic_id || 0) <= 0) && Number.isFinite(accelTid) && accelTid > 0) {
          rec = state.topicById.get(accelTid) || {
            topic_id: accelTid,
            label: accelTopicLabel || `topic_id=${accelTid}`,
            links: accelLinks || {},
          };
        }
        const recTid = rec ? Number(rec.topic_id || 0) : 0;
        const recLabel = rec ? String(rec.label || `topic_id=${recTid}`) : "";

        const contract = computeOnboardingContract({
          packReady,
          concernReady,
          topicReady,
          alignmentReady: alignReady,
          preferenceReady: prefsReady,
          hasRecommendedPack: Boolean(recPackId),
          hasRecommendedConcern: Boolean(recConcernId),
          hasRecommendedTopic: Boolean(recTid),
        });
        const nextAction = contract && contract.next_action ? contract.next_action : { id: "done", label: "Onboarding completo" };
        const completionPct = Math.round(Number(contract && contract.required_completion_pct ? contract.required_completion_pct : 0) * 100);
        const steps = Array.isArray(contract && contract.steps) ? contract.steps : [];
        const stepById = new Map();
        for (const s of steps) {
          const id = String(s && s.id ? s.id : "").trim();
          if (!id) continue;
          stepById.set(id, s);
        }
        const stepPack = stepById.get("pack");
        const stepConcern = stepById.get("concern");
        const stepTopic = stepById.get("topic");
        const stepAlignment = stepById.get("alignment");
        const stepPreference = stepById.get("preference");
        const packDone = stepPack ? Boolean(stepPack.done) : packReady;
        const concernDone = stepConcern ? Boolean(stepConcern.done) : concernReady;
        const topicDone = stepTopic ? Boolean(stepTopic.done) : topicReady;
        const alignmentDone = stepAlignment ? Boolean(stepAlignment.done) : alignReady;
        const preferenceDone = stepPreference ? Boolean(stepPreference.done) : prefsReady;

        box.style.display = "block";
        box.innerHTML =
          `<div class="onboardHead">` +
          `<div>` +
          `<p class="onboardTitle">Empieza aqui: primer resultado en 90 segundos</p>` +
          `<p class="onboardHint">Sin ranking magico: eliges una preocupacion, revisas un item y luego marcas tu postura para ver match/mismatch/unknown por partido.</p>` +
          `</div>` +
          `<span class="tag">${esc("progreso " + String(completionPct) + "%")}</span>` +
          `</div>` +
          `<div class="onboardSteps">` +
          `<span class="tag ${packDone ? "good" : ""}">0) pack ${esc(packDone ? "listo" : "opcional")}</span>` +
          `<span class="tag ${concernDone ? "good" : ""}">1) preocupacion ${esc(concernDone ? "lista" : "pendiente")}</span>` +
          `<span class="tag ${topicDone ? "good" : ""}">2) item ${esc(topicDone ? "listo" : "pendiente")}</span>` +
          `<span class="tag ${alignmentDone ? "good" : ""}">3) vista alineamiento ${esc(
            alignmentDone ? "lista" : "pendiente"
          )}</span>` +
          `<span class="tag ${preferenceDone ? "good" : ""}">4) tu postura ${esc(preferenceDone ? "lista" : "pendiente")}</span>` +
          `</div>` +
          `<div class="onboardActions">` +
          `<button class="btn md3-button" type="button" data-onboard-next="${esc(String(nextAction.id || ""))}" ${String(nextAction.id || "") === "done" ? "disabled" : ""}>${esc(
            String(nextAction.label || "Siguiente paso")
          )}</button>` +
          `<button class="btn md3-button" type="button" data-first-answer-run="1" ${accelConcernId && accelTid > 0 ? "" : "disabled"}>${esc(
            accelConcernId && accelTid > 0 ? "Respuesta rapida recomendada" : "Sin recomendacion"
          )}</button>` +
          (accelConcernId && accelTid > 0
            ? `<span class="tag">acelerador: ${esc(accelConcernLabel)} -> ${esc(accelTopicLabel)}</span>`
            : `<span class="tag">acelerador sin ranking</span>`) +
          (accelConcernId && accelTid > 0
            ? `<span class="tag">score=${esc(fmtPct01(accelScore))}</span>`
            : ``) +
          (accelLinks && accelLinks.explorer_evidence
            ? `<a class="smallLink" href="${esc(String(accelLinks.explorer_evidence || ""))}" target="_blank" rel="noopener noreferrer">Evidencia recomendada</a>`
            : ``) +
          (accelLinks && accelLinks.explorer_temas
            ? `<a class="smallLink" href="${esc(String(accelLinks.explorer_temas || ""))}" target="_blank" rel="noopener noreferrer">Tema recomendado</a>`
            : ``) +
          `<button class="btn md3-button" type="button" data-onboard-pack="${esc(recPackId)}" ${recPackId ? "" : "disabled"}>` +
          `${esc(packReady ? "Pack activo" : "Aplicar pack rapido")}` +
          `</button>` +
          (recPackId
            ? `<span class="tag">pack: ${esc(recPackLabel)}</span>`
            : `<span class="tag">sin pack sugerido</span>`) +
          `<button class="btn md3-button" type="button" data-onboard-pack-share="1" ${recPackId ? "" : "disabled"}>Link pack</button>` +
          `<button class="btn md3-button" type="button" data-onboard-topic="${esc(String(recTid || 0))}" ${recTid ? "" : "disabled"}>` +
          `${esc(topicReady ? "Item activo" : "Abrir item recomendado")}` +
          `</button>` +
          (recTid
            ? `<span class="tag">recomendado: ${esc(recLabel)}</span>`
            : `<span class="tag">sin item recomendado</span>`) +
          `<button class="btn md3-button" type="button" data-onboard-alignment="1">${esc(
            alignReady ? "Alineamiento activo" : "Ir a alineamiento"
          )}</button>` +
          `<button class="btn md3-button" type="button" data-onboard-dismiss="1">Ocultar guia</button>` +
          `</div>`;

        const actionCtx = {
          recPackId,
          recConcernId,
          recTid,
        };
        for (const btn of box.querySelectorAll("[data-first-answer-run]")) {
          btn.addEventListener("click", () => {
            if (!runFirstAnswerRecommendation(true)) return;
            setBanner(
              `<div><strong>Respuesta rapida</strong>: se activo el item recomendado para acelerar tu primer match/mismatch con evidencia auditable.</div>`
            );
          });
        }
        for (const btn of box.querySelectorAll("[data-onboard-next]")) {
          btn.addEventListener("click", () => {
            const action = String(btn.getAttribute("data-onboard-next") || "");
            runOnboardingAction(action, actionCtx);
          });
        }
        for (const btn of box.querySelectorAll("[data-onboard-pack]")) {
          btn.addEventListener("click", () => {
            const pid = String(btn.getAttribute("data-onboard-pack") || "");
            runOnboardingAction("apply_pack", {
              recPackId: pid,
              recConcernId,
              recTid,
            });
          });
        }
        for (const btn of box.querySelectorAll("[data-onboard-pack-share]")) {
          btn.addEventListener("click", async () => {
            const payload = currentAlignmentPresetForShare(recPackId);
            const url = buildAlignmentPresetShareUrl(payload);
            const copied = await copyToClipboard(url);
            setBanner(
              `<div><strong>Preset de alineamiento</strong>: ${copied ? "copiado al portapapeles" : "no se pudo copiar automaticamente"}.</div>` +
                `<div style="margin-top:8px"><span class="mono">${esc(url)}</span></div>`
            );
          });
        }
        for (const btn of box.querySelectorAll("[data-onboard-topic]")) {
          btn.addEventListener("click", () => {
            const tid = Number(btn.getAttribute("data-onboard-topic") || 0);
            runOnboardingAction("open_topic", {
              recPackId,
              recConcernId,
              recTid: tid,
            });
          });
        }
        for (const btn of box.querySelectorAll("[data-onboard-alignment]")) {
          btn.addEventListener("click", () => {
            runOnboardingAction("open_alignment", actionCtx);
          });
        }
        for (const btn of box.querySelectorAll("[data-onboard-dismiss]")) {
          btn.addEventListener("click", () => {
            setOnboardingDismissed(true);
            renderOnboarding();
          });
        }
      }

      function journeyStepState() {
        const concernDone = Boolean(String(state.activeConcernId || "").trim());
        const topicDone = Number(state.activeTopicId || 0) > 0;
        const preferenceDone = Boolean(state.prefs && state.prefs.size > 0);
        const compareDone = concernDone && (topicDone || state.viewMode === "dashboard" || state.viewMode === "coherence");
        const steps = [
          { key: "concern", done: concernDone },
          { key: "topic", done: topicDone },
          { key: "preference", done: preferenceDone },
          { key: "compare", done: compareDone },
        ];
        const doneCount = steps.filter((x) => x.done).length;
        const activeKey =
          !concernDone ? "concern" : !topicDone ? "topic" : !preferenceDone ? "preference" : !compareDone ? "compare" : "compare";
        return { concernDone, topicDone, preferenceDone, compareDone, steps, doneCount, activeKey };
      }

      function journeyViewLabel() {
        const mode = String(state.viewMode || "detail");
        if (mode === "dashboard") return "dashboard";
        if (mode === "alignment") return "alineamiento";
        if (mode === "coherence") return "coherencia";
        return "detalle";
      }

      function scrollToSection(sel) {
        const target = document.querySelector(String(sel || ""));
        if (!target) return false;
        target.scrollIntoView({ behavior: "smooth", block: "start" });
        return true;
      }

      function renderJourneyFlow() {
        const root = qs("#experienceFlow");
        if (!root || !state.citizen) return;
        const nextBtn = qs("#journeyNextAction");
        const firstAnswerBtn = qs("#journeyFirstAnswerAction");
        const narrative = qs("#journeyNarrative");
        const progressFill = qs("#journeyProgressFill");
        const progressText = qs("#journeyProgressText");
        const titleEl = qs("#journeyDecisionTitle");
        const bodyEl = qs("#journeyDecisionBody");
        const tagsEl = qs("#journeyDecisionTags");
        const linksEl = qs("#journeyDecisionLinks");

        const j = journeyStepState();
        const stepMap = [
          { id: "journeyStepConcern", key: "concern", pending: "Elige la preocupacion principal.", done: "Prioridad definida." },
          { id: "journeyStepTopic", key: "topic", pending: "Abre un item concreto.", done: "Caso seleccionado." },
          { id: "journeyStepPreference", key: "preference", pending: "Marca tu postura personal.", done: "Postura registrada." },
          { id: "journeyStepCompare", key: "compare", pending: "Contrasta y abre evidencia.", done: "Comparacion lista." },
        ];

        for (const cfg of stepMap) {
          const el = qs(`#${cfg.id}`);
          if (!el) continue;
          const statusEl = el.querySelector("[data-step-status]");
          const done = Boolean(j[cfg.key + "Done"]);
          const active = !done && j.activeKey === cfg.key;
          el.classList.toggle("is-done", done);
          el.classList.toggle("is-active", active);
          if (statusEl) statusEl.textContent = done ? cfg.done : cfg.pending;
        }

        if (progressFill) progressFill.style.width = `${Math.round((j.doneCount / 4) * 100)}%`;
        if (progressText) progressText.textContent = `${j.doneCount}/4`;

        const rec = firstAnswerRecommendation();
        const recConcernLabel = rec ? String(rec.concern_label || rec.concern_id || "") : "";
        const recTopicLabel = rec ? String(rec.topic_label || "") : "";

        if (!j.concernDone) {
          if (narrative) {
            narrative.textContent = rec
              ? `Empieza por ${recConcernLabel} y abre ${recTopicLabel} para obtener una respuesta inicial con evidencia.`
              : "Empieza eligiendo una preocupacion. Eso define el recorte de casos y partidos.";
          }
        } else if (!j.topicDone) {
          if (narrative) narrative.textContent = "Ya tienes prioridad. Ahora abre un caso concreto para evitar comparaciones abstractas.";
        } else if (!j.preferenceDone) {
          if (narrative) narrative.textContent = "Marca tu postura en el caso activo para activar match/mismatch con partidos.";
        } else {
          if (narrative) narrative.textContent = "Flujo completo: ya puedes comparar, auditar evidencia y compartir preset.";
        }

        if (nextBtn) {
          nextBtn.textContent = !j.concernDone
            ? "Elegir prioridad"
            : !j.topicDone
              ? "Abrir caso recomendado"
              : !j.preferenceDone
                ? "Marcar mi postura"
                : "Ir a comparacion";
        }
        if (firstAnswerBtn) firstAnswerBtn.disabled = !rec;

        const activeConcernLabel = concernLabelById(String(state.activeConcernId || ""));
        const activePack = concernPackById(state.activeConcernPackId || "");
        const activeTopic = state.topicById.get(Number(state.activeTopicId || 0)) || null;
        const pref = activeTopic ? normalizePrefValue(state.prefs.get(Number(activeTopic.topic_id || 0))) : "";
        const tags = [];
        const links = [];

        if (!activeConcernLabel) {
          if (titleEl) titleEl.textContent = "Selecciona una preocupacion para empezar.";
          if (bodyEl) bodyEl.textContent = "La experiencia se simplifica cuando defines primero el problema que quieres resolver.";
        } else if (!activeTopic) {
          const recTopic = recommendedOnboardingTopicForConcern(String(state.activeConcernId || ""));
          if (titleEl) titleEl.textContent = `${activeConcernLabel}: define el caso concreto`;
          if (bodyEl) {
            bodyEl.textContent = recTopic
              ? `Siguiente paso recomendado: ${String(recTopic.label || "").trim() || "abrir el primer caso relevante"}.`
              : "Siguiente paso: abre un item para pasar de narrativa general a evidencia concreta.";
          }
          tags.push(`<span class="tag">prioridad=${esc(activeConcernLabel)}</span>`);
        } else {
          const topicLabel = String(activeTopic.label || `topic_id=${activeTopic.topic_id || ""}`);
          const cov = coverageStatsForTopics([activeTopic], state.posByKey);
          const clearPct = Number(cov && cov.clear_pct != null ? cov.clear_pct : 0);
          const unknownPct = Math.max(0, 1 - clearPct);
          if (titleEl) titleEl.textContent = `${activeConcernLabel}: ${topicLabel}`;
          if (bodyEl) {
            bodyEl.textContent = pref
              ? `Tu postura: ${stanceLabel(pref)}. Ahora compara partidos y abre evidencia en los casos con mayor incertidumbre.`
              : "No has marcado tu postura aun. Marca tu posicion en este caso para personalizar la comparacion.";
          }
          tags.push(`<span class="tag">metodo=${esc(computedMethodLabel())}</span>`);
          tags.push(`<span class="tag">vista=${esc(journeyViewLabel())}</span>`);
          tags.push(`<span class="tag">cobertura=${esc(fmtPct01(clearPct))}</span>`);
          tags.push(`<span class="tag">unknown=${esc(fmtPct01(unknownPct))}</span>`);
          if (pref) tags.push(`<span class="tag good">tu_postura=${esc(stanceLabel(pref))}</span>`);
          const topicLinks = activeTopic.links && typeof activeTopic.links === "object" ? activeTopic.links : {};
          if (String(topicLinks.explorer_temas || "").trim()) {
            links.push(
              `<a class="smallLink" href="${esc(String(topicLinks.explorer_temas || ""))}" target="_blank" rel="noopener noreferrer">Tema</a>`
            );
          }
          if (String(topicLinks.explorer_evidence || "").trim()) {
            links.push(
              `<a class="smallLink" href="${esc(String(topicLinks.explorer_evidence || ""))}" target="_blank" rel="noopener noreferrer">Evidencia</a>`
            );
          }
          if (String(topicLinks.explorer_positions || "").trim()) {
            links.push(
              `<a class="smallLink" href="${esc(String(topicLinks.explorer_positions || ""))}" target="_blank" rel="noopener noreferrer">Posiciones</a>`
            );
          }
        }

        if (activePack) tags.push(`<span class="tag">pack=${esc(String(activePack.label || activePack.id || ""))}</span>`);
        if (Array.isArray(state.selectedConcernIds) && state.selectedConcernIds.length > 1) {
          tags.push(`<span class="tag">${esc(String(state.selectedConcernIds.length))} preocupaciones</span>`);
        }
        if (tagsEl) tagsEl.innerHTML = tags.join("");
        if (linksEl) linksEl.innerHTML = links.join("");
      }

      async function runJourneyAction(actionId) {
        const action = String(actionId || "").trim();
        if (action === "first_answer") {
          if (!runFirstAnswerRecommendation(true)) {
            setBanner(`<div><strong>Sin recomendacion activa</strong>: elige una preocupacion para iniciar el flujo.</div>`);
          }
          return;
        }
        if (action === "share_preset") {
          const payload = currentAlignmentPresetForShare();
          const url = buildAlignmentPresetShareUrl(payload);
          const copied = await copyToClipboard(url);
          setBanner(
            `<div><strong>Preset de alineamiento</strong>: ${copied ? "copiado al portapapeles" : "no se pudo copiar automaticamente"}.</div>` +
              `<div style="margin-top:8px"><span class="mono">${esc(url)}</span></div>`
          );
          return;
        }
        if (action === "next_step") {
          const j = journeyStepState();
          if (!j.concernDone) {
            const rec = firstAnswerRecommendation();
            if (rec && String(rec.concern_id || "").trim()) {
              selectConcern(String(rec.concern_id || ""), true);
            } else {
              scrollToSection("#stepConcern");
            }
            return;
          }
          if (!j.topicDone) {
            const recTopic = recommendedOnboardingTopicForConcern(String(state.activeConcernId || ""));
            if (recTopic && Number(recTopic.topic_id || 0) > 0) {
              openOnboardingTopic(Number(recTopic.topic_id || 0));
            } else {
              scrollToSection("#stepItems");
            }
            return;
          }
          if (!j.preferenceDone) {
            goOnboardingAlignment(Number(state.activeTopicId || 0));
            setBanner(
              `<div><strong>Siguiente paso</strong>: marca tu postura con <span class="mono">Yo: a favor</span> o <span class="mono">Yo: en contra</span> en el caso activo.</div>`
            );
            scrollToSection("#stepItems");
            return;
          }
          scrollToSection("#stepCompare");
        }
      }

      function wireJourneyFlow() {
        const root = qs("#experienceFlow");
        if (!root || root.dataset.wiredJourney === "1") return;
        root.dataset.wiredJourney = "1";
        root.addEventListener("click", async (ev) => {
          const btn = ev.target && ev.target.closest ? ev.target.closest("[data-journey-action],[data-journey-scroll]") : null;
          if (!btn) return;
          const jumpSel = String(btn.getAttribute("data-journey-scroll") || "").trim();
          if (jumpSel) {
            ev.preventDefault();
            scrollToSection(jumpSel);
            return;
          }
          const action = String(btn.getAttribute("data-journey-action") || "").trim();
          if (!action) return;
          ev.preventDefault();
          await runJourneyAction(action);
        });
      }

      function wireExperienceModeSwitch() {
        const root = qs("#experienceModeSwitch");
        if (!root || root.dataset.wired === "1") return;
        root.dataset.wired = "1";
        root.addEventListener("click", (ev) => {
          const btn = ev.target && ev.target.closest ? ev.target.closest("[data-experience-mode]") : null;
          if (!btn) return;
          const mode = String(btn.getAttribute("data-experience-mode") || "");
          if (!mode) return;
          ev.preventDefault();
          setExperienceMode(mode, true);
        });
      }

      function topicsForActiveConcernAll() {
        const cid = String(state.activeConcernId || "");
        const needle = norm(qs("#topicSearch")?.value || "");

        let out = topicsForConcernAll(cid);
        if (needle) {
          out = out.filter((t) => {
            const tid = Number(t.topic_id || 0);
            const label = String(t.label || "");
            return norm(label).includes(needle) || norm(String(tid)).includes(needle);
          });
        }
        return out;
      }

      function renderTopicList() {
        const list = qs("#topicList");
        if (!list) return;
        renderPartyFocusControls();
        const alignmentMode = state.viewMode === "alignment";
        if (!state.activeConcernId) {
          list.innerHTML = `<div class="empty">Elige una preocupacion para ver items.</div>`;
          return;
        }

        const topicsAll = topicsForActiveConcernAll();
        if (!topicsAll.length) {
          list.innerHTML = `<div class="empty">No hay items que coincidan con esta preocupacion (o con el filtro).</div>`;
          return;
        }

        const configuredLimit = Number(qs("#topicLimit")?.value || 60);
        const safeConfiguredLimit = Math.max(1, Math.min(200, Number.isFinite(configuredLimit) ? configuredLimit : 60));
        const cappedLimit = isConsumerMode() ? Math.min(safeConfiguredLimit, CONSUMER_TOPIC_MAX) : safeConfiguredLimit;
        const effectiveLimit = isConsumerMode() && state.consumerTopicExpanded ? topicsAll.length : cappedLimit;
        const topics = topicsAll.slice(0, effectiveLimit);
        const hiddenTopics = Math.max(0, topicsAll.length - topics.length);

        list.innerHTML = topics
          .map((t) => {
            const tid = Number(t.topic_id || 0);
            const active = state.activeTopicId && tid === state.activeTopicId;
            const tags = [];
            if (t.is_high_stakes) tags.push(`<span class="tag hot">high-stakes</span>`);
            if (t.stakes_rank != null) tags.push(`<span class="tag">rank #${esc(String(t.stakes_rank))}</span>`);
            tags.push(`<span class="tag">caso auditable</span>`);

            if (alignmentMode) {
              const pref = normalizePrefValue(state.prefs.get(tid));
              if (pref) {
                tags.push(
                  `<span class="stanceChip mini ${esc(pref)}"><span class="dot ${esc(dotClassForStance(pref))}"></span>tu:${esc(
                    stanceLabel(pref)
                  )}</span>`
                );
              }
            }

            if (state.activePartyId) {
              const pid = Number(state.activePartyId);
              const coh = state.coherence;
              const coherenceReady = Boolean(
                state.viewMode === "coherence" &&
                  coh &&
                  coh.votesPosByKey &&
                  coh.declaredPosByKey &&
                  coh.votesPosByKey.size &&
                  coh.declaredPosByKey.size
              );

              if (coherenceReady) {
                const sv = stanceFromPosMap(coh.votesPosByKey, tid, pid);
                const sd = stanceFromPosMap(coh.declaredPosByKey, tid, pid);
                const mismatch = isComparableStance(sv) && isComparableStance(sd) && sv !== sd;
                if (mismatch) tags.push(`<span class="tag hot">mismatch</span>`);
                tags.push(
                  `<span class="stanceChip mini ${esc(sv)}"><span class="dot ${esc(dotClassForStance(sv))}"></span>v:${esc(
                    stanceLabel(sv)
                  )}</span>`
                );
                tags.push(
                  `<span class="stanceChip mini ${esc(sd)}"><span class="dot ${esc(dotClassForStance(sd))}"></span>d:${esc(
                    stanceLabel(sd)
                  )}</span>`
                );
              } else {
                const key = `${tid}:${pid}`;
                const r = state.posByKey.get(key) || null;
                const s = r ? String(r.stance || "no_signal") : "no_signal";
                if (alignmentMode) {
                  const pref = normalizePrefValue(state.prefs.get(tid));
                  if (pref) {
                    if (isComparableStance(s)) {
                      tags.push(`<span class="tag ${esc(s === pref ? "good" : "bad")}">${esc(s === pref ? "match" : "mismatch")}</span>`);
                    } else {
                      tags.push(`<span class="tag">unknown</span>`);
                    }
                  }
                }
                tags.push(
                  `<span class="stanceChip mini ${esc(s)}"><span class="dot ${esc(dotClassForStance(s))}"></span>${esc(
                    stanceLabel(s)
                  )}</span>`
                );
              }
            }

            return (
              `<div class="row topicRow ${active ? "active" : ""}" data-tid="${esc(String(tid))}" role="button" tabindex="0">` +
              `<div class="rowTitle"><strong>${esc(String(t.label || ""))}</strong><span class="tags">${tags.join(
                ""
              )}</span></div>` +
              `<div class="rowMeta">` +
              `<a class="smallLink" href="${esc(String((t.links || {}).explorer_temas || ""))}" target="_blank" rel="noopener noreferrer">Ver en Temas</a>` +
              `<span>·</span>` +
              `<a class="smallLink" href="${esc(String((t.links || {}).explorer_positions || ""))}" target="_blank" rel="noopener noreferrer">Posiciones (SQL)</a>` +
              `</div>` +
              `</div>`
            );
          })
          .join("") +
          (isConsumerMode() && hiddenTopics > 0 && !state.consumerTopicExpanded
            ? `<div class="empty" style="margin: 8px 3px 0">` +
              `<span>Hay ${esc(String(hiddenTopics))} casos mas. </span>` +
              `<button class="btn md3-button" type="button" data-topic-show-more="1">Ver mas casos</button>` +
              `</div>`
            : "");

        for (const el of list.querySelectorAll("[data-tid]")) {
          el.addEventListener("click", () => {
            selectTopic(Number(el.getAttribute("data-tid") || 0), true);
          });
          el.addEventListener("keydown", (ev) => {
            if (ev.key === "Enter" || ev.key === " ") {
              ev.preventDefault();
              selectTopic(Number(el.getAttribute("data-tid") || 0), true);
            }
          });
        }
        for (const btn of list.querySelectorAll("[data-topic-show-more]")) {
          btn.addEventListener("click", () => {
            state.consumerTopicExpanded = true;
            renderTopicList();
          });
        }
      }

      function positionsForTopic(topicId) {
        const out = [];
        for (const party of state.citizen.parties || []) {
          const pid = Number(party.party_id || 0);
          const key = `${Number(topicId)}:${pid}`;
          const row = state.posByKey.get(key) || null;
          if (row) out.push(row);
        }
        return out;
      }

      function coverageRatioForRow(row) {
        const cov = row && row.coverage && typeof row.coverage === "object" ? row.coverage : {};
        const total = Number(cov.members_total || 0);
        const withSignal = Number(cov.members_with_signal || 0);
        return total > 0 ? withSignal / total : 0;
      }

      function pickTopPartyByStance(rows, targetStance) {
        const target = String(targetStance || "");
        let best = null;
        for (const raw of Array.isArray(rows) ? rows : []) {
          const stance = String((raw || {}).stance || "");
          if (stance !== target) continue;
          const coverage = coverageRatioForRow(raw);
          const conf = Number((raw || {}).confidence || 0);
          const score = coverage * 0.7 + conf * 0.3;
          const candidate = {
            row: raw,
            party_id: Number((raw || {}).party_id || 0),
            party_label: partyName(Number((raw || {}).party_id || 0)),
            score,
          };
          if (!best || candidate.score > best.score) {
            best = candidate;
            continue;
          }
          if (best && candidate.score === best.score) {
            if (String(candidate.party_label || "").localeCompare(String(best.party_label || "")) < 0) {
              best = candidate;
            }
          }
        }
        return best;
      }

      function renderConsumerTopicAnswer(topic, topicId, rows) {
        if (!isConsumerMode()) return "";
        const tid = Number(topicId || 0);
        if (!tid) return "";
        const t = topic || state.topicById.get(tid) || null;
        const label = t ? String(t.label || "") : `topic_id=${tid}`;
        const pref = normalizePrefValue(state.prefs.get(tid));
        const supportTop = pickTopPartyByStance(rows, "support");
        const opposeTop = pickTopPartyByStance(rows, "oppose");
        const unknownCount = (rows || []).filter((r) => {
          const s = String((r || {}).stance || "no_signal");
          return s === "unclear" || s === "no_signal";
        }).length;

        let title = "Respuesta rapida para este caso";
        let body =
          "Marca tu postura y te muestro el contraste inmediato por partido sin ruido metodologico.";
        let tags = "";
        if (pref === "support") {
          title = "Si tu postura es A favor";
          body = supportTop
            ? `Partido mas alineado ahora: ${supportTop.party_label}.`
            : "No hay suficiente senal clara para identificar alineamiento directo.";
          tags =
            `<span class="tag good">tu postura: ${esc(stanceLabel(pref))}</span>` +
            (supportTop ? `<span class="tag">top match: ${esc(String(supportTop.party_label || ""))}</span>` : ``) +
            (opposeTop ? `<span class="tag">top contraste: ${esc(String(opposeTop.party_label || ""))}</span>` : ``) +
            `<span class="tag">unknown=${esc(fmtInt(unknownCount))}</span>`;
        } else if (pref === "oppose") {
          title = "Si tu postura es En contra";
          body = opposeTop
            ? `Partido mas alineado ahora: ${opposeTop.party_label}.`
            : "No hay suficiente senal clara para identificar alineamiento directo.";
          tags =
            `<span class="tag good">tu postura: ${esc(stanceLabel(pref))}</span>` +
            (opposeTop ? `<span class="tag">top match: ${esc(String(opposeTop.party_label || ""))}</span>` : ``) +
            (supportTop ? `<span class="tag">top contraste: ${esc(String(supportTop.party_label || ""))}</span>` : ``) +
            `<span class="tag">unknown=${esc(fmtInt(unknownCount))}</span>`;
        } else {
          tags =
            (supportTop ? `<span class="tag">si apoyas: ${esc(String(supportTop.party_label || ""))}</span>` : ``) +
            (opposeTop ? `<span class="tag">si te opones: ${esc(String(opposeTop.party_label || ""))}</span>` : ``) +
            `<span class="tag">unknown=${esc(fmtInt(unknownCount))}</span>`;
        }

        return (
          `<div class="consumerAnswer">` +
          `<h3>${esc(title)}</h3>` +
          `<p>${esc(body)}</p>` +
          `<div class="partyMeta" style="margin-top:8px"><span class="tag">caso: ${esc(label)}</span>${tags}</div>` +
          `<div class="consumerAnswerActions">` +
          `<button class="btn md3-button" type="button" data-consumer-pref="${esc(String(tid))}:support">Yo: a favor</button>` +
          `<button class="btn md3-button" type="button" data-consumer-pref="${esc(String(tid))}:oppose">Yo: en contra</button>` +
          `<button class="btn md3-button" type="button" data-consumer-pref-clear="${esc(String(tid))}">Quitar postura</button>` +
          `<button class="btn md3-button" type="button" data-consumer-go-alignment="1">Ver alineamiento completo</button>` +
          `</div>` +
          `</div>`
        );
      }

      function renderConsumerAlignmentDecision(rows, prefsItems) {
        if (!isConsumerMode()) return "";
        const prefs = Array.isArray(prefsItems) ? prefsItems : [];
        if (!prefs.length) return "";
        const bandsByParty = rankingBandsByParty(rows, prefs.length);
        const ranked = rankAlignmentRowsForConsumer(rows);
        if (!ranked.length) return "";

        const leader = ranked[0] || null;
        if (!leader) return "";
        const runner = ranked.length > 1 ? ranked[1] : null;
        const tail = ranked.length > 1 ? ranked[ranked.length - 1] : null;

        const leaderName = partyName(Number(leader.party_id || 0));
        const leaderCoverage = Number(leader.coverage || 0);
        const leaderSignal = leaderCoverage >= 0.7 ? "senal alta" : leaderCoverage >= 0.4 ? "senal media" : "senal debil";
        const leadGap = runner ? Number(leader.net || 0) - Number(runner.net || 0) : Number(leader.net || 0);
        const leadGapTag = runner ? `ventaja_vs_2=${fmtInt(leadGap)}` : `net=${fmtInt(Number(leader.net || 0))}`;
        const caution =
          leaderCoverage >= 0.5
            ? "Lectura util para decidir: abre al menos un mismatch para validar contexto antes de compartir."
            : "Lectura preliminar: cobertura limitada. Abre evidencia antes de decidir.";

        const mismatchTopic = leader.audit_mismatch_topic || null;
        const mismatchLabel = mismatchTopic ? String(mismatchTopic.label || "") : "";
        const mismatchLink = mismatchTopic && mismatchTopic.links ? String(mismatchTopic.links.explorer_temas || "") : "";
        const matchTopic = leader.audit_match_topic || null;
        const matchLink = matchTopic && matchTopic.links ? String(matchTopic.links.explorer_temas || "") : "";
        const leaderBand = bandsByParty.get(Number(leader.party_id || 0)) || { id: "fragil", label: "fragil", reason: "" };
        const top3Tags = ranked
          .slice(0, 3)
          .map((r, idx) => {
            const pid = Number((r || {}).party_id || 0);
            const n = partyName(pid);
            const net = Number((r || {}).net || 0);
            const cov = Number((r || {}).coverage || 0);
            const band = bandsByParty.get(pid) || { id: "fragil", label: "fragil" };
            return `<span class="tag ${esc(rankBandTagClass(band.id))}">${esc(String(idx + 1))}) ${esc(n)} net=${esc(fmtInt(net))} cov=${esc(
              fmtPct01(cov)
            )} banda=${esc(String(band.label || ""))}</span>`;
          })
          .join("");

        return (
          `<div class="consumerDecision">` +
          `<p class="eyebrow">Decision provisional</p>` +
          `<h3>Top match actual: ${esc(leaderName)}</h3>` +
          `<p>Con ${esc(fmtInt(prefs.length))} posturas: ${esc(fmtInt(Number(leader.match || 0)))} match, ${esc(
            fmtInt(Number(leader.mismatch || 0))
          )} mismatch, ${esc(fmtInt(Number(leader.unknown || 0)))} unknown y cobertura ${esc(fmtPct01(leaderCoverage))}.</p>` +
          `<div class="partyMeta" style="margin-top:8px">` +
          `<span class="tag good">top=${esc(leaderName)}</span>` +
          `<span class="tag">${esc(leadGapTag)}</span>` +
          `<span class="tag">${esc(leaderSignal)}</span>` +
          `<span class="tag ${esc(rankBandTagClass(leaderBand.id))}">banda=${esc(String(leaderBand.label || ""))}</span>` +
          (runner ? `<span class="tag">2o=${esc(partyName(Number(runner.party_id || 0)))}</span>` : ``) +
          (tail ? `<span class="tag bad">mas distante=${esc(partyName(Number(tail.party_id || 0)))}</span>` : ``) +
          `</div>` +
          (top3Tags ? `<div class="partyMeta" style="margin-top:8px">${top3Tags}</div>` : ``) +
          `<p class="consumerDecisionHint">${esc(caution)} ${esc(String(leaderBand.reason || ""))}</p>` +
          `<div class="consumerDecisionActions">` +
          `<button class="btn md3-button" type="button" data-focus-party="${esc(String(Number(leader.party_id || 0)))}">Ver detalle top match</button>` +
          `<button class="btn md3-button" type="button" data-copy-consumer-decision="1">Copiar resumen</button>` +
          `<button class="btn md3-button" type="button" data-prefs-share="1">Compartir comparacion</button>` +
          (mismatchLink
            ? `<a class="smallLink" href="${esc(mismatchLink)}" target="_blank" rel="noopener noreferrer">Auditar mismatch: ${esc(
                mismatchLabel || "abrir caso"
              )}</a>`
            : ``) +
          (matchLink
            ? `<a class="smallLink" href="${esc(matchLink)}" target="_blank" rel="noopener noreferrer">Auditar match</a>`
            : ``) +
          `</div>` +
          `</div>`
        );
      }

      function rankAlignmentRowsForConsumer(rows) {
        return (Array.isArray(rows) ? rows.slice() : []).sort((a, b) => {
          const an = Number((a || {}).net || 0);
          const bn = Number((b || {}).net || 0);
          if (bn !== an) return bn - an;
          const ac = Number((a || {}).coverage || 0);
          const bc = Number((b || {}).coverage || 0);
          if (bc !== ac) return bc - ac;
          const am = Number((a || {}).match || 0);
          const bm = Number((b || {}).match || 0);
          if (bm !== am) return bm - am;
          return partyName(Number((a || {}).party_id || 0)).localeCompare(partyName(Number((b || {}).party_id || 0)));
        });
      }

      function rankBandTagClass(bandId) {
        const id = String(bandId || "");
        if (id === "estable") return "good";
        if (id === "fragil") return "bad";
        return "hot";
      }

      function rankingConfidenceBand(row, nextRow, prefsTotal) {
        const total = Math.max(0, Number(prefsTotal || 0));
        const comparable = Math.max(0, Number((row || {}).comparable || 0));
        const coverage = Number((row || {}).coverage || 0);
        const unknown = Math.max(0, Number((row || {}).unknown || 0));
        const net = Number((row || {}).net || 0);
        const nextNet = nextRow ? Number((nextRow || {}).net || 0) : net - 3;
        const gap = nextRow ? net - nextNet : Math.max(0, net);

        if (total <= 0) return { id: "fragil", label: "fragil", reason: "sin preferencias suficientes." };
        if (comparable <= 1 || coverage < 0.34 || gap <= 1) {
          return { id: "fragil", label: "fragil", reason: "poca distancia o baja cobertura; puede cambiar rapido." };
        }
        if (gap >= 3 && coverage >= 0.67 && comparable >= Math.max(2, Math.floor(total * 0.6))) {
          if (unknown > comparable) {
            return { id: "intermedia", label: "intermedia", reason: "ventaja clara, pero unknown alto relativo." };
          }
          return { id: "estable", label: "estable", reason: "ventaja clara con buena cobertura comparable." };
        }
        if (unknown > comparable) {
          return { id: "fragil", label: "fragil", reason: "unknown alto frente a comparables; ranking inestable." };
        }
        return { id: "intermedia", label: "intermedia", reason: "ventaja moderada; conviene validar 1-2 temas mas." };
      }

      function rankingBandsByParty(rows, prefsTotal) {
        const ranked = rankAlignmentRowsForConsumer(rows);
        const out = new Map();
        for (let i = 0; i < ranked.length; i += 1) {
          const cur = ranked[i];
          const next = i + 1 < ranked.length ? ranked[i + 1] : null;
          out.set(Number((cur || {}).party_id || 0), rankingConfidenceBand(cur, next, prefsTotal));
        }
        return out;
      }

      function consumerReadinessBand(rows, prefsItems) {
        const prefs = Array.isArray(prefsItems) ? prefsItems : [];
        const ranked = rankAlignmentRowsForConsumer(rows);
        if (!prefs.length || !ranked.length) {
          return {
            score: 0,
            label: "preliminar",
            reason: "marca posturas para activar comparacion util.",
            leader: null,
            runner: null,
            coverage: 0,
            gap: 0,
            leaderBand: { id: "fragil", label: "fragil", reason: "sin base suficiente." },
          };
        }
        const leader = ranked[0] || null;
        const runner = ranked.length > 1 ? ranked[1] : null;
        const coverage = Math.max(0, Math.min(1, Number((leader || {}).coverage || 0)));
        const gap = runner ? Math.max(0, Number((leader || {}).net || 0) - Number((runner || {}).net || 0)) : Math.max(0, Number((leader || {}).net || 0));
        const bandsByParty = rankingBandsByParty(rows, prefs.length);
        const leaderBand = bandsByParty.get(Number((leader || {}).party_id || 0)) || {
          id: "fragil",
          label: "fragil",
          reason: "poca distancia o baja cobertura.",
        };

        const prefsProgress = Math.min(1, prefs.length / 5);
        const gapScore = Math.min(1, gap / 4);
        const bandScore = leaderBand.id === "estable" ? 1 : leaderBand.id === "intermedia" ? 0.68 : 0.42;
        const score = Math.round((0.35 * prefsProgress + 0.35 * coverage + 0.2 * bandScore + 0.1 * gapScore) * 100);

        let label = "preliminar";
        let reason = "base limitada para una decision final.";
        if (score >= 75) {
          label = "listo_para_decidir";
          reason = "senal consistente para una decision provisional auditable.";
        } else if (score >= 55) {
          label = "casi_listo";
          reason = "falta uno o dos pasos para cerrar decision con menos duda.";
        }
        if (prefs.length < 3) {
          reason = "todavia hay pocas posturas marcadas para comparar con solidez.";
        } else if (coverage < 0.5) {
          reason = "cobertura baja: faltan comparables para algunos partidos.";
        } else if (String(leaderBand.id || "") === "fragil") {
          reason = String(leaderBand.reason || reason);
        }

        return { score, label, reason, leader, runner, coverage, gap, leaderBand };
      }

      function buildConsumerAlignmentShareSummary(rows, prefsItems) {
        const ranked = rankAlignmentRowsForConsumer(rows);
        const prefs = Array.isArray(prefsItems) ? prefsItems : [];
        const bandsByParty = rankingBandsByParty(rows, prefs.length);
        const readiness = consumerReadinessBand(rows, prefs);
        const supportN = prefs.filter((x) => String((x || {}).pref || "") === "support").length;
        const opposeN = prefs.filter((x) => String((x || {}).pref || "") === "oppose").length;
        const payload = currentAlignmentPresetForShare();
        const url = buildAlignmentPresetShareUrl(payload);
        const lines = [];
        lines.push(`Comparacion ciudadana (${computedMethodLabel()})`);
        lines.push(`Posturas marcadas: ${fmtInt(prefs.length)} (a favor=${fmtInt(supportN)}, en contra=${fmtInt(opposeN)})`);
        lines.push(`Readiness: ${fmtInt(Number(readiness.score || 0))}% (${String(readiness.label || "preliminar")})`);
        for (const r of ranked.slice(0, 3)) {
          const pid = Number((r || {}).party_id || 0);
          const band = bandsByParty.get(pid) || { label: "fragil" };
          lines.push(
            `${partyName(pid)} -> match=${fmtInt(Number((r || {}).match || 0))}, mismatch=${fmtInt(Number((r || {}).mismatch || 0))}, unknown=${fmtInt(
              Number((r || {}).unknown || 0)
            )}, cobertura=${fmtPct01(Number((r || {}).coverage || 0))}, banda=${String(band.label || "fragil")}`
          );
        }
        lines.push(`Link: ${url}`);
        return { text: lines.join("\n"), url };
      }

      function alignmentNarrativeForParty(row, prefsTotal) {
        const total = Math.max(0, Number(prefsTotal || 0));
        const match = Math.max(0, Number((row || {}).match || 0));
        const mismatch = Math.max(0, Number((row || {}).mismatch || 0));
        const unknown = Math.max(0, Number((row || {}).unknown || 0));
        const coverage = Number((row || {}).coverage || 0);
        const net = Number((row || {}).net || 0);

        if (total <= 0) return "Sin posturas marcadas todavia.";
        if (coverage < 0.34) {
          return `Senal limitada: solo ${fmtInt(match + mismatch)}/${fmtInt(total)} comparables. Revisa evidencia antes de decidir.`;
        }
        if (net >= 2 && mismatch === 0) {
          return `Alta alineacion: coincide en ${fmtInt(match)} de ${fmtInt(total)} casos comparables.`;
        }
        if (net > 0) {
          return `Alineacion moderada: ${fmtInt(match)} match frente a ${fmtInt(mismatch)} mismatch. Unknown=${fmtInt(unknown)}.`;
        }
        if (net === 0) {
          return `Empate practico: mismo volumen de match y mismatch. Necesita auditoria puntual.`;
        }
        return `Desalineacion: ${fmtInt(mismatch)} mismatch supera ${fmtInt(match)} match. Unknown=${fmtInt(unknown)}.`;
      }

      function buildFocusMismatchShareSummary(partyId, focusItems, prefsItems) {
        const pid = Number(partyId || 0);
        const items = Array.isArray(focusItems) ? focusItems : [];
        const prefs = Array.isArray(prefsItems) ? prefsItems : [];
        const mismatches = items.filter((x) => String((x || {}).res || "") === "mismatch");
        const matches = items.filter((x) => String((x || {}).res || "") === "match");
        const unknowns = items.filter((x) => String((x || {}).res || "") === "unknown");
        const payload = currentAlignmentPresetForShare();
        const url = buildAlignmentPresetShareUrl(payload);
        const lines = [];
        lines.push(`Diagnostico de mismatch: ${partyName(pid)}`);
        lines.push(`Posturas marcadas=${fmtInt(prefs.length)}; match=${fmtInt(matches.length)}; mismatch=${fmtInt(mismatches.length)}; unknown=${fmtInt(unknowns.length)}`);
        if (mismatches.length) {
          lines.push(`Principales desacuerdos:`);
          for (const row of mismatches.slice(0, 5)) {
            const label = String((row && row.topic_label) || "");
            const pref = String((row && row.pref) || "");
            const stance = String((row && row.stance) || "no_signal");
            lines.push(`- ${label}: tu=${stanceLabel(pref)} partido=${stanceLabel(stance)}`);
          }
        } else {
          lines.push(`No hay mismatches en los temas comparables actuales.`);
        }
        lines.push(`Link: ${url}`);
        return { text: lines.join("\n"), url };
      }

      function alignmentScopeConcernIds() {
        const selected = normalizeSelectedConcernIds(state.selectedConcernIds || []);
        if (selected.length) return selected;
        const active = String(state.activeConcernId || "").trim();
        return active ? [active] : [];
      }

      function disambiguationCandidatesForTopParties(topPid, secondPid, prefsItems) {
        const pidA = Number(topPid || 0);
        const pidB = Number(secondPid || 0);
        if (!pidA || !pidB || pidA === pidB) return [];

        const prefSet = new Set((Array.isArray(prefsItems) ? prefsItems : []).map((x) => Number((x || {}).topic_id || 0)));
        const cids = alignmentScopeConcernIds();
        const scopeTopics = topicsForConcernIdsAll(cids);
        const out = [];

        for (const t of scopeTopics) {
          const tid = Number((t || {}).topic_id || 0);
          if (!tid || prefSet.has(tid)) continue;
          const sa = stanceFromPosMap(state.posByKey, tid, pidA);
          const sb = stanceFromPosMap(state.posByKey, tid, pidB);
          const ca = isComparableStance(sa);
          const cb = isComparableStance(sb);
          let bucket = "";
          if (ca && cb && sa !== sb) bucket = "direct_split";
          else if ((ca && !cb) || (!ca && cb)) bucket = "signal_gap";
          else continue;

          const linkTemas = t && t.links ? String(t.links.explorer_temas || "") : "";
          const score = bucket === "direct_split" ? 3 : 2;
          out.push({
            topic: t,
            topic_id: tid,
            topic_label: String((t || {}).label || ""),
            stakes_rank: Number((t || {}).stakes_rank || 0),
            is_high_stakes: Boolean((t || {}).is_high_stakes),
            bucket,
            score,
            top_stance: String(sa || "no_signal"),
            second_stance: String(sb || "no_signal"),
            link_temas: linkTemas,
          });
        }

        out.sort((a, b) => {
          if (b.score !== a.score) return b.score - a.score;
          if (a.is_high_stakes !== b.is_high_stakes) return a.is_high_stakes ? -1 : 1;
          const ar = Number(a.stakes_rank || 0);
          const br = Number(b.stakes_rank || 0);
          const aHas = Number.isFinite(ar) && ar > 0;
          const bHas = Number.isFinite(br) && br > 0;
          if (aHas && bHas && ar !== br) return ar - br;
          if (aHas !== bHas) return aHas ? -1 : 1;
          return String(a.topic_label || "").localeCompare(String(b.topic_label || ""));
        });
        return out;
      }

      function renderConsumerDisambiguationGuide(rows, prefsItems) {
        if (!isConsumerMode()) return "";
        const ranked = rankAlignmentRowsForConsumer(rows);
        if (ranked.length < 2) return "";
        const prefs = Array.isArray(prefsItems) ? prefsItems : [];
        const bandsByParty = rankingBandsByParty(rows, prefs.length);

        const leader = ranked[0] || null;
        const second = ranked[1] || null;
        if (!leader || !second) return "";

        const leadNet = Number(leader.net || 0);
        const secondNet = Number(second.net || 0);
        const gap = leadNet - secondNet;
        const minExtra = Math.max(1, Math.ceil((Math.abs(gap) + 1) / 2));
        const candidates = disambiguationCandidatesForTopParties(leader.party_id, second.party_id, prefsItems).slice(0, 3);
        const leaderBand = bandsByParty.get(Number(leader.party_id || 0)) || { id: "fragil", label: "fragil", reason: "" };
        const caution =
          gap <= 1
            ? "Carrera ajustada: un tema bien elegido puede cambiar el orden."
            : `Ventaja actual de ${fmtInt(gap)} net para ${partyName(Number(leader.party_id || 0))}.`;

        return (
          `<div class="mismatchPanel" style="margin-top:10px">` +
          `<div class="partyMeta">` +
          `<span class="tag">desempate</span>` +
          `<span class="tag">top1=${esc(partyName(Number(leader.party_id || 0)))}</span>` +
          `<span class="tag">top2=${esc(partyName(Number(second.party_id || 0)))}</span>` +
          `<span class="tag">gap_net=${esc(fmtInt(gap))}</span>` +
          `<span class="tag">min_temas_extra~${esc(fmtInt(minExtra))}</span>` +
          `<span class="tag ${esc(rankBandTagClass(leaderBand.id))}">banda_top1=${esc(String(leaderBand.label || ""))}</span>` +
          `</div>` +
          `<div class="partyNarrative" style="margin-top:8px">${esc(caution)} ${esc(String(leaderBand.reason || ""))}</div>` +
          (candidates.length
            ? `<ol class="mismatchList">` +
              candidates
                .map((c) => {
                  const reason =
                    c.bucket === "direct_split"
                      ? `partidos en lados opuestos (${stanceLabel(c.top_stance)} vs ${stanceLabel(c.second_stance)})`
                      : `brecha de senal (${stanceLabel(c.top_stance)} vs ${stanceLabel(c.second_stance)})`;
                  return (
                    `<li>` +
                    `<strong>${esc(String(c.topic_label || ""))}</strong> ` +
                    `<span class="mono">${esc(reason)}</span> ` +
                    `<button class="btn md3-button" type="button" data-guidance-open-topic="${esc(String(c.topic_id || 0))}">Abrir tema</button>` +
                    (c.link_temas
                      ? `<a class="smallLink" href="${esc(String(c.link_temas || ""))}" target="_blank" rel="noopener noreferrer">Auditar</a>`
                      : ``) +
                    `</li>`
                  );
                })
                .join("") +
              `</ol>`
            : `<div class="partyNarrative" style="margin-top:8px">No hay temas claramente discriminantes en el recorte actual.</div>`) +
          `</div>`
        );
      }

      function renderConsumerActionPlan(rows, prefsItems) {
        if (!isConsumerMode()) return "";
        const prefs = Array.isArray(prefsItems) ? prefsItems : [];
        if (!prefs.length) return "";
        const readiness = consumerReadinessBand(rows, prefs);
        const leader = readiness.leader || null;
        if (!leader) return "";
        const runner = readiness.runner || null;
        const score = Math.max(0, Math.min(100, Number(readiness.score || 0)));
        const levelClass = score >= 75 ? "good" : score >= 55 ? "hot" : "bad";
        const toMark = Math.max(0, 4 - prefs.length);
        const leaderPartyName = partyName(Number((leader || {}).party_id || 0));
        const leaderMismatch = leader.audit_mismatch_topic || null;
        const leaderMismatchLink = leaderMismatch && leaderMismatch.links ? String(leaderMismatch.links.explorer_temas || "") : "";
        const leaderMismatchLabel = leaderMismatch ? String(leaderMismatch.label || "") : "";

        const tieCandidates =
          runner && Number((runner || {}).party_id || 0) > 0
            ? disambiguationCandidatesForTopParties(Number((leader || {}).party_id || 0), Number((runner || {}).party_id || 0), prefs).slice(0, 1)
            : [];
        const tieTopic = tieCandidates.length ? tieCandidates[0] : null;

        const steps = [];
        if (toMark > 0) {
          steps.push(
            `<li><strong>Completa base minima</strong>: marca ${esc(fmtInt(toMark))} postura(s) mas para mejorar cobertura.` +
              ` <button class="btn md3-button" type="button" data-consumer-go-items="1">Ir a casos</button></li>`
          );
        } else {
          steps.push(`<li><strong>Base activa</strong>: ya tienes suficientes posturas para comparar partidos sin promedios vacios.</li>`);
        }

        if (tieTopic) {
          steps.push(
            `<li><strong>Reduce duda entre lideres</strong>: abre <span class="mono">${esc(String(tieTopic.topic_label || ""))}</span> para separar ${esc(
              leaderPartyName
            )}${runner ? ` y ${esc(partyName(Number((runner || {}).party_id || 0)))}` : ""}.` +
              ` <button class="btn md3-button" type="button" data-guidance-open-topic="${esc(String(tieTopic.topic_id || 0))}">Abrir tema</button></li>`
          );
        }

        if (leaderMismatchLink) {
          steps.push(
            `<li><strong>Audita un desacuerdo clave</strong>: valida contexto en <span class="mono">${esc(leaderMismatchLabel || "mismatch")}</span>.` +
              ` <a class="smallLink" href="${esc(leaderMismatchLink)}" target="_blank" rel="noopener noreferrer">Auditar mismatch</a></li>`
          );
        } else {
          steps.push(`<li><strong>Valida evidencia</strong>: abre al menos un caso en Temas/SQL antes de compartir tu conclusion.</li>`);
        }

        if (score >= 75) {
          steps.push(`<li><strong>Comparte decision provisional</strong>: exporta resumen y link para discutir con evidencia.` + ` <button class="btn md3-button" type="button" data-copy-consumer-decision="1">Copiar resumen</button></li>`);
        }

        const renderedSteps = steps.slice(0, 4).join("");
        return (
          `<div class="mismatchPanel" style="margin-top:10px" data-consumer-action-plan="1">` +
          `<div class="partyMeta">` +
          `<span class="tag ${esc(levelClass)}">readiness=${esc(fmtInt(score))}%</span>` +
          `<span class="tag">estado=${esc(String(readiness.label || "preliminar"))}</span>` +
          `<span class="tag">top=${esc(leaderPartyName)}</span>` +
          `<span class="tag">cobertura=${esc(fmtPct01(Number(readiness.coverage || 0)))}</span>` +
          `<span class="tag">gap_net=${esc(fmtInt(Number(readiness.gap || 0)))}</span>` +
          `<span class="tag ${esc(rankBandTagClass(String((readiness.leaderBand || {}).id || "fragil")))}">banda_top1=${esc(
            String((readiness.leaderBand || {}).label || "fragil")
          )}</span>` +
          `</div>` +
          `<div class="partyNarrative" style="margin-top:8px">Valor practico: ${esc(String(readiness.reason || ""))}</div>` +
          `<ol class="mismatchList">${renderedSteps}</ol>` +
          `</div>`
        );
      }

      function stanceCounts(rows) {
        const c = {
          support: 0,
          oppose: 0,
          mixed: 0,
          unclear: 0,
          no_signal: 0,
        };
        for (const r of rows) {
          const s = String(r.stance || "unclear");
          if (c[s] == null) continue;
          c[s] += 1;
        }
        return c;
      }

      function summaryStanceFromCounts(counts, itemsTotal) {
        const n = Number(itemsTotal || 0);
        if (n <= 0) return "no_signal";

        const support = Number(counts.support || 0);
        const oppose = Number(counts.oppose || 0);
        const mixed = Number(counts.mixed || 0);
        const unclear = Number(counts.unclear || 0);

        const clear = support + oppose + mixed;
        if (clear <= 0) {
          return unclear > 0 ? "unclear" : "no_signal";
        }

        const conflict = support > 0 && oppose > 0;
        if (conflict) return "mixed";
        return support >= oppose ? "support" : "oppose";
      }

      function partySummariesForTopics(topics) {
        const itemsTotal = (topics || []).length;
        const out = [];
        for (const party of state.citizen.parties || []) {
          const pid = Number(party.party_id || 0);
          const counts = { support: 0, oppose: 0, mixed: 0, unclear: 0, no_signal: 0 };
          let confSum = 0;
          let confN = 0;
          let auditTopic = (topics || [])[0] || null;
          let auditTopicIsFallback = Boolean(auditTopic);

          for (const t of topics || []) {
            const tid = Number(t.topic_id || 0);
            const key = `${tid}:${pid}`;
            const row = state.posByKey.get(key) || null;
            const stance = row ? String(row.stance || "no_signal") : "no_signal";
            if (counts[stance] != null) counts[stance] += 1;

            if (row && stance !== "no_signal") {
              confSum += Number(row.confidence || 0);
              confN += 1;
            }

            if (row && (stance === "support" || stance === "oppose" || stance === "mixed")) {
              // Pick the first clear-stance topic deterministically for audit.
              if (auditTopicIsFallback) {
                auditTopic = t;
                auditTopicIsFallback = false;
              }
            }
          }

          const summaryStance = summaryStanceFromCounts(counts, itemsTotal);
          const clearTotal = Number(counts.support) + Number(counts.oppose) + Number(counts.mixed);
          const coverageItemsRatio = itemsTotal > 0 ? clearTotal / itemsTotal : 0;
          const confidenceAvg = confN > 0 ? confSum / confN : 0;

          out.push({
            party_id: pid,
            stance: summaryStance,
            counts,
            items_total: itemsTotal,
            clear_total: clearTotal,
            coverage_items_ratio: coverageItemsRatio,
            confidence_avg: confidenceAvg,
            audit_topic: auditTopic,
          });
        }

        return { topics: topics || [], items_total: itemsTotal, rows: out };
      }

      function concernPartySummaries() {
        return partySummariesForTopics(topicsForConcernAll(String(state.activeConcernId || "")));
      }

      function dashboardPartySummaries() {
        const cids = normalizeSelectedConcernIds(state.selectedConcernIds || []);
        const topics = topicsForConcernIdsAll(cids);
        return { concern_ids: cids, ...partySummariesForTopics(topics) };
      }

      function coverageStatsForTopics(topics, posByKey) {
        const counts = { support: 0, oppose: 0, mixed: 0, unclear: 0, no_signal: 0 };
        const parties = state.citizen && Array.isArray(state.citizen.parties) ? state.citizen.parties : [];
        const items = Array.isArray(topics) ? topics : [];
        for (const t of items) {
          const tid = Number(t.topic_id || 0);
          for (const party of parties) {
            const pid = Number(party.party_id || 0);
            const s = stanceFromPosMap(posByKey, tid, pid);
            if (counts[s] != null) counts[s] += 1;
          }
        }
        const cellsTotal = items.length * parties.length;
        const clearTotal = Number(counts.support) + Number(counts.oppose) + Number(counts.mixed);
        const anySignal = cellsTotal - Number(counts.no_signal);
        return {
          cells_total: cellsTotal,
          items_total: items.length,
          parties_total: parties.length,
          counts,
          any_signal: anySignal,
          any_signal_pct: cellsTotal > 0 ? anySignal / cellsTotal : 0,
          clear_total: clearTotal,
          clear_pct: cellsTotal > 0 ? clearTotal / cellsTotal : 0,
        };
      }

      function trustCoverageForPartyTopics(partyId, topics) {
        const pid = Number(partyId || 0);
        const items = Array.isArray(topics) ? topics : [];
        if (!pid || !items.length) {
          return {
            evidence_count_total: 0,
            members_total: 0,
            members_with_signal: 0,
            last_evidence_date: "",
          };
        }

        let evidenceCountTotal = 0;
        let membersTotal = 0;
        let membersWithSignal = 0;
        let lastEvidenceDate = "";

        for (const t of items) {
          const tid = Number((t || {}).topic_id || 0);
          if (!tid) continue;
          const row = state.posByKey.get(`${tid}:${pid}`) || null;
          if (!row) continue;
          const cov = row.coverage && typeof row.coverage === "object" ? row.coverage : {};

          evidenceCountTotal += Number(cov.evidence_count_total || 0);
          membersTotal += Number(cov.members_total || 0);
          membersWithSignal += Number(cov.members_with_signal || 0);

          const evDate = String(cov.last_evidence_date || "").trim();
          if (evDate && (!lastEvidenceDate || evDate > lastEvidenceDate)) {
            lastEvidenceDate = evDate;
          }
        }

        return {
          evidence_count_total: Math.max(0, Math.trunc(evidenceCountTotal)),
          members_total: Math.max(0, Math.trunc(membersTotal)),
          members_with_signal: Math.max(0, Math.trunc(membersWithSignal)),
          last_evidence_date: lastEvidenceDate,
        };
      }

      function crossMethodRowsForTopics(topics, votesPosByKey, declaredPosByKey, combinedPosByKey) {
        const parties = state.citizen && Array.isArray(state.citizen.parties) ? state.citizen.parties : [];
        const items = Array.isArray(topics) ? topics : [];
        const out = [];
        for (const t of items) {
          const tid = Number(t.topic_id || 0);
          if (!tid) continue;
          for (const party of parties) {
            const pid = Number(party.party_id || 0);
            if (!pid) continue;
            out.push({
              topic_id: tid,
              party_id: pid,
              votes: stanceFromPosMap(votesPosByKey, tid, pid),
              declared: stanceFromPosMap(declaredPosByKey, tid, pid),
              combined: stanceFromPosMap(combinedPosByKey, tid, pid),
            });
          }
        }
        return out;
      }

      function coherenceTotalsForTopics(topics, votesPosByKey, declaredPosByKey) {
        const parties = state.citizen && Array.isArray(state.citizen.parties) ? state.citizen.parties : [];
        const items = Array.isArray(topics) ? topics : [];
        let cellsTotal = 0;
        let comparable = 0;
        let match = 0;
        let mismatch = 0;
        let notComparable = 0;

        for (const t of items) {
          const tid = Number(t.topic_id || 0);
          for (const party of parties) {
            const pid = Number(party.party_id || 0);
            cellsTotal += 1;
            const sv = stanceFromPosMap(votesPosByKey, tid, pid);
            const sd = stanceFromPosMap(declaredPosByKey, tid, pid);
            if (isComparableStance(sv) && isComparableStance(sd)) {
              comparable += 1;
              if (sv === sd) match += 1;
              else mismatch += 1;
            } else {
              notComparable += 1;
            }
          }
        }

        return {
          cells_total: cellsTotal,
          items_total: items.length,
          parties_total: parties.length,
          comparable,
          comparable_pct: cellsTotal > 0 ? comparable / cellsTotal : 0,
          match,
          mismatch,
          mismatch_pct_of_comparable: comparable > 0 ? mismatch / comparable : 0,
          not_comparable: notComparable,
        };
      }

      function coherenceSummaryForParty(topics, pid, votesPosByKey, declaredPosByKey) {
        const items = Array.isArray(topics) ? topics : [];
        let comparable = 0;
        let match = 0;
        let mismatch = 0;
        let notComparable = 0;
        let auditMismatchTopic = null;
        let auditMatchTopic = null;

        for (const t of items) {
          const tid = Number(t.topic_id || 0);
          const sv = stanceFromPosMap(votesPosByKey, tid, pid);
          const sd = stanceFromPosMap(declaredPosByKey, tid, pid);
          if (isComparableStance(sv) && isComparableStance(sd)) {
            comparable += 1;
            if (sv === sd) {
              match += 1;
              if (!auditMatchTopic) auditMatchTopic = t;
            } else {
              mismatch += 1;
              if (!auditMismatchTopic) auditMismatchTopic = t;
            }
          } else {
            notComparable += 1;
          }
        }

        return {
          party_id: Number(pid || 0),
          items_total: items.length,
          comparable,
          comparable_ratio: items.length > 0 ? comparable / items.length : 0,
          match,
          mismatch,
          mismatch_ratio: comparable > 0 ? mismatch / comparable : 0,
          not_comparable: notComparable,
          audit_mismatch_topic: auditMismatchTopic,
          audit_match_topic: auditMatchTopic,
        };
      }

      function programasSummaryForParty(pid, concernIds) {
        const ids = normalizeSelectedConcernIds(concernIds || []);
        const counts = { support: 0, oppose: 0, mixed: 0, unclear: 0, no_signal: 0 };
        let confSum = 0;
        let confN = 0;
        let auditLink = "";

        for (const cid of ids) {
          const key = `${String(cid || "")}:${Number(pid || 0)}`;
          const row = state.progByKey.get(key) || null;
          const stance = row ? String(row.stance || "no_signal") : "no_signal";
          if (counts[stance] != null) counts[stance] += 1;
          if (row && stance !== "no_signal") {
            confSum += Number(row.confidence || 0);
            confN += 1;
          }
          if (!auditLink && row && row.links && String(row.links.explorer_evidence || "")) {
            auditLink = String(row.links.explorer_evidence || "");
          }
        }

        const itemsTotal = ids.length;
        const summaryStance = summaryStanceFromCounts(counts, itemsTotal);
        const confidenceAvg = confN > 0 ? confSum / confN : 0;
        return { stance: summaryStance, counts, items_total: itemsTotal, confidence_avg: confidenceAvg, audit_link: auditLink };
      }

      function partyName(pid) {
        const p = state.partyById.get(Number(pid)) || null;
        if (!p) return `party_id=${pid}`;
        const a = String(p.acronym || "").trim();
        const n = String(p.name || "").trim();
        return a ? `${a} · ${n}` : n;
      }

      function clearPartyFocus() {
        state.activePartyId = 0;
        writeUrlState(true);
        renderTopicList();
        renderCompare();
      }

      function setPartyFocus(pid) {
        const next = Number(pid || 0);
        if (!Number.isFinite(next) || next <= 0) return;
        state.activePartyId = next;
        // Keep topic unselected in focus mode to emphasize drill-down via items list.
        state.activeTopicId = 0;
        // Party focus is shareable (encoded in URL).
        writeUrlState(true);
        renderTopicList();
        renderCompare();
      }

      function renderPartyFocusControls() {
        const btn = qs("#btnPartyFocusClear");
        const chip = qs("#partyFocusChip");
        const name = qs("#partyFocusName");
        if (!btn || !chip || !name) return;

        if (state.activePartyId) {
          btn.style.display = "inline-flex";
          chip.style.display = "inline-flex";
          name.textContent = partyName(state.activePartyId);
        } else {
          btn.style.display = "none";
          chip.style.display = "none";
          name.textContent = "";
        }
      }

      function resolveConcernIdForTopic(topicId, selectedConcernIds) {
        const tid = Number(topicId || 0);
        const selected = normalizeSelectedConcernIds(selectedConcernIds || []);
        if (!selected.length) return "";
        if (!tid) return String(selected[0] || "");
        const tags = Array.isArray(state.topicTags.get(tid)) ? state.topicTags.get(tid) : [];
        for (const cid of selected) {
          if (tags.includes(cid)) return String(cid || "");
        }
        if (tags.length) return String(tags[0] || "");
        return String(selected[0] || "");
      }

      function buildCoherenceDrilldownLink(rawLink, opts) {
        const base = String(rawLink || "").trim();
        if (!base) return "";
        const o = opts || {};
        const partyId = Number(o.party_id || 0);
        const topicId = Number(o.topic_id || 0);
        const concernId = String(o.concern_id || "").trim();
        const bucket = String(o.bucket || "incoherent").trim() || "incoherent";
        const view = String(o.view || "coherence").trim() || "coherence";
        try {
          const u = new URL(base, window.location.href);
          if (topicId > 0) u.searchParams.set("topic_id", String(topicId));
          if (partyId > 0) u.searchParams.set("party_id", String(partyId));
          if (concernId) u.searchParams.set("concern", concernId);
          u.searchParams.set("view", view);
          u.searchParams.set("bucket", bucket);
          u.searchParams.set("source", "citizen_coherence");
          return `${u.pathname}${u.search}${u.hash}`;
        } catch (_err) {
          const glue = base.includes("?") ? "&" : "?";
          const p = new URLSearchParams();
          if (topicId > 0) p.set("topic_id", String(topicId));
          if (partyId > 0) p.set("party_id", String(partyId));
          if (concernId) p.set("concern", concernId);
          p.set("view", view);
          p.set("bucket", bucket);
          p.set("source", "citizen_coherence");
          return `${base}${glue}${p.toString()}`;
        }
      }

      function renderCoherenceCompare(el, selectedConcernIds, { sortMode } = {}) {
        const cids = normalizeSelectedConcernIds(selectedConcernIds || []);
        if (!cids.length) {
          el.innerHTML = `<div class="empty"><strong>Coherencia</strong>: selecciona al menos 1 preocupacion.</div>`;
          return;
        }

        const coh = state.coherence;
        if (!coh.votes || !coh.declared || !coh.combined) {
          if (!coh.loading && !coh.promise && !coh.loadError) {
            ensureCoherenceSnapshotsLoaded()
              .then(() => {
                // Coherence mode affects topic-list chips when party focus is active.
                renderTopicList();
                renderCompare();
              })
              .catch(() => {
                renderCompare();
              });
          }

          if (coh.loadError) {
            el.innerHTML =
              `<div class="empty">` +
              `<strong>Coherencia</strong>: no se pudieron cargar datasets de votos+dichos.<br />` +
              `<span class="mono">${esc(String(coh.loadError || ""))}</span>` +
              `</div>`;
            return;
          }

          el.innerHTML =
            `<div class="empty">` +
            `<strong>Coherencia</strong>: cargando datos de votos + dichos (lazy)…` +
            `</div>`;
          return;
        }

        const topicsUnion = topicsForConcernIdsAll(cids);
        if (!topicsUnion.length) {
          el.innerHTML = `<div class="empty">No hay items etiquetados para las preocupaciones seleccionadas.</div>`;
          return;
        }

        const overallCoh = coherenceTotalsForTopics(topicsUnion, coh.votesPosByKey, coh.declaredPosByKey);
        const mismatchPct = Number(overallCoh.mismatch_pct_of_comparable || 0);
        const stabilityRows = crossMethodRowsForTopics(topicsUnion, coh.votesPosByKey, coh.declaredPosByKey, coh.combinedPosByKey);
        const stabilityPanel = renderCrossMethodStabilityPanel(
          {
            rows: stabilityRows,
            min_comparable_ratio: 0.15,
            high_mismatch_threshold: 0.35,
          },
          "summary"
        );

        const concernTags = cids
          .map((cid) => `<span class="tag">${esc(concernLabelById(cid) || cid)}</span>`)
          .join("");

        const coverageLines = cids
          .map((cid) => {
            const topics = topicsForConcernAll(cid);
            const votes = coverageStatsForTopics(topics, coh.votesPosByKey);
            const declared = coverageStatsForTopics(topics, coh.declaredPosByKey);
            const combined = coverageStatsForTopics(topics, coh.combinedPosByKey);
            const cohTotals = coherenceTotalsForTopics(topics, coh.votesPosByKey, coh.declaredPosByKey);
            return (
              `<div class="rowMeta">` +
              `<span class="tag"><strong>${esc(concernLabelById(cid) || cid)}</strong></span>` +
              `<span class="tag">items=${esc(fmtInt(votes.items_total))}</span>` +
              `<span class="tag">votos any=${esc(fmtPct01(votes.any_signal_pct))} clear=${esc(fmtPct01(votes.clear_pct))}</span>` +
              `<span class="tag">dichos any=${esc(fmtPct01(declared.any_signal_pct))} clear=${esc(fmtPct01(declared.clear_pct))}</span>` +
              `<span class="tag">combinado any=${esc(fmtPct01(combined.any_signal_pct))} clear=${esc(fmtPct01(combined.clear_pct))}</span>` +
              `<span class="tag">comparables=${esc(fmtInt(cohTotals.comparable))}</span>` +
              `<span class="tag">mismatch=${esc(fmtInt(cohTotals.mismatch))}</span>` +
              `</div>`
            );
          })
          .join("");

        let rows = (state.citizen.parties || []).map((party) => {
          const pid = Number(party.party_id || 0);
          return coherenceSummaryForParty(topicsUnion, pid, coh.votesPosByKey, coh.declaredPosByKey);
        });

        // Sort: reuse partySort selector semantics in coherence mode.
        rows.sort((a, b) => {
          if (sortMode === "coverage") {
            const ac = Number(a.comparable_ratio || 0);
            const bc = Number(b.comparable_ratio || 0);
            if (bc !== ac) return bc - ac;
          }
          if (sortMode === "confidence") {
            const am = Number(a.mismatch || 0);
            const bm = Number(b.mismatch || 0);
            if (bm !== am) return bm - am;
          }
          const an = partyName(a.party_id);
          const bn = partyName(b.party_id);
          return an.localeCompare(bn);
        });
        const coherenceLimited = limitRowsForExperience(rows);
        const coherenceRows = coherenceLimited.rows;
        const coherenceHiddenHint = consumerHiddenRowsHint(coherenceLimited.hidden, "partidos");

        el.innerHTML =
          `<div class="empty" style="margin-bottom: 12px">` +
          `<div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between">` +
          `<div><strong>Coherencia</strong> (votos vs dichos)</div>` +
          `<div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center">` +
          `<span class="tag">items=${esc(fmtInt(topicsUnion.length))}</span>` +
          `<span class="tag">comparables=${esc(fmtInt(overallCoh.comparable))}</span>` +
          `<span class="tag">mismatch=${esc(fmtInt(overallCoh.mismatch))} (${esc(fmtPct01(mismatchPct))} de comparables)</span>` +
          (state.activePartyId ? `<span class="tag">foco=${esc(partyName(state.activePartyId))}</span>` : "") +
          (state.activePartyId ? `<button class="btn md3-button" data-clear-party-focus="1" type="button">Salir foco</button>` : "") +
          `</div>` +
          `</div>` +
          `<div class="rowMeta" style="margin-top:8px">` +
          `<span class="tag">Comparable solo si ambos son A favor / En contra</span>` +
          `<span class="tag">mixed/unclear/no_signal = no comparable</span>` +
          `</div>` +
          (stabilityPanel ? `<div style="margin-top:8px">${stabilityPanel}</div>` : ``) +
          `<div class="rowMeta" style="margin-top:8px">` +
          `<span class="tag">Seleccionadas:</span>` +
          `<span class="tags">${concernTags || ""}</span>` +
          `</div>` +
          (coverageLines ? `<div style="margin-top:10px; display:flex; flex-direction:column; gap:8px">${coverageLines}</div>` : "") +
          (coherenceHiddenHint || "") +
          `</div>` +
          (coherenceRows.length
            ? coherenceRows
                .map((r) => {
                  const pid = Number(r.party_id || 0);
                  const itemsTotal = Number(r.items_total || 0);
                  const comparable = Number(r.comparable || 0);
                  const match = Number(r.match || 0);
                  const mismatch = Number(r.mismatch || 0);
                  const notComp = Number(r.not_comparable || 0);
                  const comparableRatio = Number(r.comparable_ratio || 0);
                  const mismatchRatio = Number(r.mismatch_ratio || 0);

                  const focused = state.activePartyId && Number(state.activePartyId) === pid;

                  const auditTopic = r.audit_mismatch_topic || r.audit_match_topic || null;
                  const auditIsMismatch = Boolean(r.audit_mismatch_topic);
                  const auditTid = auditTopic ? Number(auditTopic.topic_id || 0) : 0;

                  const vt = auditTid ? coh.votesTopicById.get(auditTid) : null;
                  const dt = auditTid ? coh.declaredTopicById.get(auditTid) : null;
                  const temasLink = vt && vt.links ? String(vt.links.explorer_temas || "") : "";
                  const votosLink = vt && vt.links ? String(vt.links.explorer_positions || "") : "";
                  const dichosLink = dt && dt.links ? String(dt.links.explorer_positions || "") : "";
                  const drillConcernId = resolveConcernIdForTopic(auditTid, cids);
                  const drilldownLink = buildCoherenceDrilldownLink(temasLink, {
                    party_id: pid,
                    topic_id: auditTid,
                    concern_id: drillConcernId,
                    bucket: auditIsMismatch ? "incoherent" : "coherent",
                    view: "coherence",
                  });
                  const drilldownLabel = auditIsMismatch ? "Auditar mismatch" : "Auditar coherencia";

                  const sv = auditTid ? stanceFromPosMap(coh.votesPosByKey, auditTid, pid) : "no_signal";
                  const sd = auditTid ? stanceFromPosMap(coh.declaredPosByKey, auditTid, pid) : "no_signal";

                  return (
                    `<div class="partyCard md3-card ${focused ? "focused" : ""}">` +
                    `<div class="partyHead">` +
                    `<div class="partyName">${esc(partyName(pid))}</div>` +
                    `<div class="tags">` +
                    `<span class="tag">${esc(auditIsMismatch ? "mismatch" : auditTopic ? "match" : "sin comparables")}</span>` +
                    `</div>` +
                    `</div>` +
                    `<div class="barWrap">` +
                    `<div class="barLabel"><span>Comparables</span><span class="mono">${esc(fmtInt(comparable))}/${esc(
                      fmtInt(itemsTotal)
                    )} (${esc(fmtPct01(comparableRatio))})</span></div>` +
                    `<div class="bar"><div style="width:${Math.round(comparableRatio * 100)}%"></div></div>` +
                    `</div>` +
                    `<div class="barWrap">` +
                    `<div class="barLabel"><span>Mismatch (de comparables)</span><span class="mono">${esc(fmtInt(mismatch))}/${esc(
                      fmtInt(comparable)
                    )} (${esc(fmtPct01(mismatchRatio))})</span></div>` +
                    `<div class="bar"><div style="width:${Math.round(mismatchRatio * 100)}%"></div></div>` +
                    `</div>` +
                    `<div class="partyMeta">` +
                    `<span class="tag">match=${esc(fmtInt(match))}</span>` +
                    `<span class="tag">mismatch=${esc(fmtInt(mismatch))}</span>` +
                    `<span class="tag">no_comparable=${esc(fmtInt(notComp))}</span>` +
                    `</div>` +
                    `<div class="partyMeta">` +
                    `<button class="btn md3-button" type="button" data-focus-party="${esc(String(pid))}">Foco partido</button>` +
                    (drilldownLink
                      ? `<a class="smallLink" data-coherence-drilldown-link="1" data-party-id="${esc(String(pid))}" data-topic-id="${esc(
                          String(auditTid || "")
                        )}" data-concern-id="${esc(String(drillConcernId || ""))}" href="${esc(
                          String(drilldownLink)
                        )}" target="_blank" rel="noopener noreferrer">${esc(drilldownLabel)}</a>`
                      : `<span class="tag">sin audit link</span>`) +
                    `</div>` +
                    (auditTopic
                      ? `<div class="partyMeta">` +
                        `<span class="tag">Ejemplo:</span>` +
                        `<span class="tag">${esc(String(auditTopic.label || `topic_id=${auditTid}`))}</span>` +
                        `<span class="stanceChip mini ${esc(sv)}"><span class="dot ${esc(dotClassForStance(sv))}"></span>votos: ${esc(
                          stanceLabel(sv)
                        )}</span>` +
                        `<span class="stanceChip mini ${esc(sd)}"><span class="dot ${esc(dotClassForStance(sd))}"></span>dichos: ${esc(
                          stanceLabel(sd)
                        )}</span>` +
                        (votosLink
                          ? `<a class="smallLink" href="${esc(String(votosLink))}" target="_blank" rel="noopener noreferrer">Votos (SQL)</a>`
                          : ``) +
                        (dichosLink
                          ? `<a class="smallLink" href="${esc(String(dichosLink))}" target="_blank" rel="noopener noreferrer">Dichos (SQL)</a>`
                          : ``) +
                        `</div>`
                      : ``) +
                    `</div>`
                  );
                })
                .join("")
            : `<div class="empty">No hay partidos para mostrar.</div>`);

        for (const btn of el.querySelectorAll("[data-focus-party]")) {
          btn.addEventListener("click", () => {
            const pid = Number(btn.getAttribute("data-focus-party") || 0);
            setPartyFocus(pid);
          });
        }
        for (const btn of el.querySelectorAll("[data-clear-party-focus]")) {
          btn.addEventListener("click", () => {
            clearPartyFocus();
          });
        }
      }

      function renderAlignmentCompare(el, { sortMode } = {}) {
        const tid = Number(state.activeTopicId || 0);
        const alignmentSort = String(sortMode || "coverage");

        const prefsItems = [];
        const keys = Array.from(state.prefs.keys()).map((x) => Number(x || 0));
        keys.sort((a, b) => a - b);
        for (const k of keys) {
          const pref = normalizePrefValue(state.prefs.get(k));
          const t = state.topicById.get(Number(k)) || null;
          if (!pref || !t) continue;
          prefsItems.push({ topic_id: Number(k), pref, topic: t });
        }

        const supportN = prefsItems.filter((x) => x.pref === "support").length;
        const opposeN = prefsItems.filter((x) => x.pref === "oppose").length;
        let alignmentRowsForConsumerSummary = [];
        let alignmentBandsByParty = new Map();
        let focusDetailItems = [];
        let focusDetailPartyId = 0;

        let selectedTopicHtml = "";
        if (tid && state.topicById.get(tid)) {
          const t = state.topicById.get(tid);
          const pref = normalizePrefValue(state.prefs.get(tid));
          const temasLink = t && t.links ? String(t.links.explorer_temas || "") : "";
          const posLink = t && t.links ? String(t.links.explorer_positions || "") : "";

          selectedTopicHtml =
            `<div class="empty" style="margin-bottom: 12px">` +
            `<div style="display:flex; gap:10px; flex-wrap:wrap; align-items:flex-start; justify-content:space-between">` +
            `<div style="min-width:0"><strong>Tema seleccionado</strong><div style="margin-top:6px">${esc(String(t.label || ""))}</div></div>` +
            `<div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end">` +
            (temasLink ? `<a class="pill neutral" href="${esc(temasLink)}" target="_blank" rel="noopener noreferrer">Auditar en Temas</a>` : "") +
            (posLink ? `<a class="pill neutral" href="${esc(posLink)}" target="_blank" rel="noopener noreferrer">Posiciones (SQL)</a>` : "") +
            `</div>` +
            `</div>` +
            `<div class="rowMeta" style="margin-top:10px">` +
            `<span class="tag">Tu preferencia:</span>` +
            `<button class="stanceChip mini support" type="button" data-pref-set="support" data-tid="${esc(String(tid))}">Yo: a favor</button>` +
            `<button class="stanceChip mini oppose" type="button" data-pref-set="oppose" data-tid="${esc(String(tid))}">Yo: en contra</button>` +
            `<button class="btn md3-button" type="button" data-pref-clear="1" data-tid="${esc(String(tid))}">Quitar</button>` +
            (pref
              ? `<span class="stanceChip mini ${esc(pref)}"><span class="dot ${esc(dotClassForStance(pref))}"></span>${esc(
                  stanceLabel(pref)
                )}</span>`
              : `<span class="tag">sin preferencia</span>`) +
            `</div>` +
            `</div>`;
        }

        const prefsHeader =
          `<div class="empty" style="margin-bottom: 12px">` +
          `<div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between">` +
          `<div><strong>Alineamiento</strong></div>` +
          `<div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:flex-end">` +
          `<span class="tag">${esc(computedMethodLabel())}</span>` +
          `<span class="tag">prefs=${esc(fmtInt(prefsItems.length))}</span>` +
          `<span class="tag">a_favor=${esc(fmtInt(supportN))}</span>` +
          `<span class="tag">en_contra=${esc(fmtInt(opposeN))}</span>` +
          (state.activePartyId ? `<span class="tag">foco=${esc(partyName(state.activePartyId))}</span>` : "") +
          (state.activePartyId ? `<button class="btn md3-button" data-clear-party-focus="1" type="button">Salir foco</button>` : "") +
          `</div>` +
          `</div>` +
          `<div class="rowMeta" style="margin-top:8px">` +
          `<span class="tag">Honestidad</span>` +
          `<span>match/mismatch solo cuando el partido tiene senal clara (a_favor/en_contra). Todo lo demas es <strong>unknown</strong>.</span>` +
          `</div>` +
          `<div class="rowMeta" style="margin-top:8px">` +
          `<span class="tag">Privacidad</span>` +
          `<span>tus preferencias se guardan solo en tu navegador. El link compartible (si lo generas) usa el fragmento <span class="mono">#...</span>.</span>` +
          `</div>` +
          `<div class="rowMeta" style="margin-top:10px">` +
          `<button class="btn md3-button" type="button" data-prefs-clear-all="1" ${prefsItems.length ? "" : "disabled"}>Borrar preferencias</button>` +
          `<button class="btn md3-button" type="button" data-prefs-share="1" ${prefsItems.length ? "" : "disabled"}>Generar link</button>` +
          `<button class="btn md3-button" type="button" data-prefs-download="1" ${prefsItems.length ? "" : "disabled"}>Descargar JSON</button>` +
          `<label class="btn md3-button" style="display:inline-flex; align-items:center; gap:8px; cursor:pointer">` +
          `Importar JSON<input id="prefsUpload" type="file" accept=\"application/json\" style="display:none" />` +
          `</label>` +
          `</div>` +
          `<div class="rowMeta" id="prefsShareWrap" style="margin-top:10px; display:none">` +
          `<input id="prefsShareLink" type="text" value="" readonly style="flex:1 1 320px" />` +
          `<button class="btn md3-button" type="button" data-prefs-copy="1">Copiar</button>` +
          `</div>` +
          `</div>`;

        if (!prefsItems.length) {
          el.innerHTML =
            selectedTopicHtml +
            prefsHeader +
            `<div class="empty">` +
            `<strong>Empieza aqui</strong>: selecciona un item en la columna 2 y marca <span class="mono">Yo: a favor</span> o <span class="mono">Yo: en contra</span>.` +
            `<div style="margin-top:8px">Veras un resumen por partido con <span class="mono">match/mismatch/unknown</span> y cobertura.</div>` +
            `</div>`;
        } else {
          const rows = [];
          for (const party of state.citizen.parties || []) {
            const pid = Number(party.party_id || 0);
            let match = 0;
            let mismatch = 0;
            let unknown = 0;
            let auditMatchTopic = null;
            let auditMismatchTopic = null;

            for (const it of prefsItems) {
              const stance = stanceFromPosMap(state.posByKey, it.topic_id, pid);
              if (isComparableStance(stance)) {
                if (stance === it.pref) {
                  match += 1;
                  if (!auditMatchTopic) auditMatchTopic = it.topic;
                } else {
                  mismatch += 1;
                  if (!auditMismatchTopic) auditMismatchTopic = it.topic;
                }
              } else {
                unknown += 1;
              }
            }

            const comparable = match + mismatch;
            const coverage = prefsItems.length > 0 ? comparable / prefsItems.length : 0;
            const net = match - mismatch;
            rows.push({
              party_id: pid,
              match,
              mismatch,
              unknown,
              comparable,
              coverage,
              net,
              audit_match_topic: auditMatchTopic,
              audit_mismatch_topic: auditMismatchTopic,
            });
          }

          rows.sort((a, b) => {
            if (alignmentSort === "coverage") {
              if (b.coverage !== a.coverage) return b.coverage - a.coverage;
              if (b.net !== a.net) return b.net - a.net;
            } else if (alignmentSort === "confidence") {
              // Reuse control slot: in alignment mode, "confidence" means net match.
              if (b.net !== a.net) return b.net - a.net;
              if (b.coverage !== a.coverage) return b.coverage - a.coverage;
            }
            return partyName(a.party_id).localeCompare(partyName(b.party_id));
          });
          alignmentRowsForConsumerSummary = rows.slice();
          alignmentBandsByParty = rankingBandsByParty(rows, prefsItems.length);
          const consumerDecision = renderConsumerAlignmentDecision(rows, prefsItems);
          const disambiguationGuide = renderConsumerDisambiguationGuide(rows, prefsItems);
          const consumerActionPlan = renderConsumerActionPlan(rows, prefsItems);
          const alignmentLimited = limitRowsForExperience(rows);
          const alignmentRows = alignmentLimited.rows;
          const alignmentHiddenHint = consumerHiddenRowsHint(alignmentLimited.hidden, "partidos");

          el.innerHTML =
            selectedTopicHtml +
            prefsHeader +
            (consumerDecision || "") +
            (disambiguationGuide || "") +
            (consumerActionPlan || "") +
            (alignmentRows.length
              ? alignmentRows
                  .map((r) => {
                    const pid = Number(r.party_id || 0);
                    const focused = state.activePartyId && Number(state.activePartyId) === pid;
                    const auditMismatch = r.audit_mismatch_topic || null;
                    const auditMatch = r.audit_match_topic || null;
                    const mismatchLink = auditMismatch && auditMismatch.links ? String(auditMismatch.links.explorer_temas || "") : "";
                    const matchLink = auditMatch && auditMatch.links ? String(auditMatch.links.explorer_temas || "") : "";
                    const cov = Number(r.coverage || 0);
                    const narrative = alignmentNarrativeForParty(r, prefsItems.length);
                    const band = alignmentBandsByParty.get(pid) || { id: "fragil", label: "fragil" };

                    return (
                      `<div class="partyCard md3-card ${focused ? "focused" : ""}">` +
                      `<div class="partyHead">` +
                      `<div class="partyName">${esc(partyName(pid))}</div>` +
                      `<div class="tags">` +
                      `<span class="tag">match=${esc(fmtInt(r.match))}</span>` +
                      `<span class="tag">mismatch=${esc(fmtInt(r.mismatch))}</span>` +
                      `<span class="tag">unknown=${esc(fmtInt(r.unknown))}</span>` +
                      `<span class="tag">net=${esc(fmtInt(r.net))}</span>` +
                      `<span class="tag ${esc(rankBandTagClass(band.id))}">banda=${esc(String(band.label || ""))}</span>` +
                      `</div>` +
                      `</div>` +
                      `<div class="barWrap">` +
                      `<div class="barLabel"><span>Cobertura (comparables)</span><span class="mono">${esc(fmtInt(r.comparable))}/${esc(
                        fmtInt(prefsItems.length)
                      )} (${esc(fmtPct01(cov))})</span></div>` +
                      `<div class="bar"><div style="width:${Math.round(cov * 100)}%"></div></div>` +
                      `</div>` +
                      `<p class="partyNarrative">${esc(narrative)}</p>` +
                      `<div class="partyMeta">` +
                      `<button class="btn md3-button" type="button" data-focus-party="${esc(String(pid))}">Foco</button>` +
                      (mismatchLink
                        ? `<a class="smallLink" href="${esc(mismatchLink)}" target="_blank" rel="noopener noreferrer">Auditar mismatch</a>`
                        : `<span class="tag">sin mismatch</span>`) +
                      (matchLink
                        ? `<a class="smallLink" href="${esc(matchLink)}" target="_blank" rel="noopener noreferrer">Auditar match</a>`
                        : `<span class="tag">sin match</span>`) +
                      `</div>` +
                      `</div>`
                    );
                  })
                  .join("")
              : `<div class="empty">No hay partidos para mostrar.</div>`);
          if (alignmentHiddenHint) {
            el.innerHTML += alignmentHiddenHint;
          }

          if (state.activePartyId) {
            const pid = Number(state.activePartyId);
            focusDetailPartyId = pid;
            focusDetailItems = prefsItems.map((it) => {
              const stance = stanceFromPosMap(state.posByKey, it.topic_id, pid);
              const comparable = isComparableStance(stance);
              const res = comparable ? (stance === it.pref ? "match" : "mismatch") : "unknown";
              const temasLink = it.topic && it.topic.links ? String(it.topic.links.explorer_temas || "") : "";
              const posLink = it.topic && it.topic.links ? String(it.topic.links.explorer_positions || "") : "";
              return {
                topic_id: Number(it.topic_id || 0),
                topic_label: String((it.topic && it.topic.label) || ""),
                pref: String(it.pref || ""),
                stance: String(stance || "no_signal"),
                res: String(res || "unknown"),
                temas_link: temasLink,
                pos_link: posLink,
              };
            });
            const mismatchItems = focusDetailItems.filter((x) => x.res === "mismatch");
            const matchItems = focusDetailItems.filter((x) => x.res === "match");
            const unknownItems = focusDetailItems.filter((x) => x.res === "unknown");
            const focusPartyLabel = partyName(pid);

            const mismatchPanel =
              `<div class="mismatchPanel">` +
              `<div class="partyMeta">` +
              `<span class="tag">match=${esc(fmtInt(matchItems.length))}</span>` +
              `<span class="tag bad">mismatch=${esc(fmtInt(mismatchItems.length))}</span>` +
              `<span class="tag">unknown=${esc(fmtInt(unknownItems.length))}</span>` +
              `</div>` +
              `<div class="partyNarrative" style="margin-top:8px">` +
              (mismatchItems.length
                ? `Principales motivos de desajuste para ${esc(focusPartyLabel)} (primeros ${fmtInt(Math.min(3, mismatchItems.length))}):`
                : `No hay mismatch en los temas comparables actuales para ${esc(focusPartyLabel)}.`) +
              `</div>` +
              (mismatchItems.length
                ? `<ol class="mismatchList">` +
                  mismatchItems
                    .slice(0, 3)
                    .map((row) => {
                      return (
                        `<li>` +
                        `<strong>${esc(String(row.topic_label || ""))}</strong> ` +
                        `tu: <span class="mono">${esc(stanceLabel(String(row.pref || "")))}</span> ` +
                        `vs partido: <span class="mono">${esc(stanceLabel(String(row.stance || "")))}</span> ` +
                        (row.temas_link
                          ? `<a class="smallLink" href="${esc(String(row.temas_link || ""))}" target="_blank" rel="noopener noreferrer">Auditar</a>`
                          : ``) +
                        `</li>`
                      );
                    })
                    .join("") +
                  `</ol>`
                : ``) +
              `<div class="consumerDecisionActions">` +
              `<button class="btn md3-button" type="button" data-copy-focus-mismatch-summary="1" data-party-id="${esc(String(pid))}">Copiar diagnostico</button>` +
              `<button class="btn md3-button" type="button" data-prefs-share="1">Compartir comparacion</button>` +
              `</div>` +
              `</div>`;

            const detailRows = focusDetailItems
              .map((row) => {
                const resClass = row.res === "match" ? "good" : row.res === "mismatch" ? "bad" : "";
                return (
                  `<div class="partyCard md3-card">` +
                  `<div class="partyHead">` +
                  `<div class="partyName">${esc(String(row.topic_label || ""))}</div>` +
                  `<span class="tag ${esc(resClass)}">${esc(String(row.res || "unknown"))}</span>` +
                  `</div>` +
                  `<div class="partyMeta">` +
                  `<span class="stanceChip mini ${esc(String(row.pref || ""))}"><span class="dot ${esc(dotClassForStance(String(row.pref || "")))}"></span>tu:${esc(
                    stanceLabel(String(row.pref || ""))
                  )}</span>` +
                  `<span class="stanceChip mini ${esc(String(row.stance || ""))}"><span class="dot ${esc(dotClassForStance(String(row.stance || "")))}"></span>${esc(
                    stanceLabel(String(row.stance || ""))
                  )}</span>` +
                  (row.temas_link
                    ? `<a class="smallLink" href="${esc(String(row.temas_link || ""))}" target="_blank" rel="noopener noreferrer">Temas</a>`
                    : "") +
                  (row.pos_link
                    ? `<a class="smallLink" href="${esc(String(row.pos_link || ""))}" target="_blank" rel="noopener noreferrer">SQL</a>`
                    : "") +
                  `</div>` +
                  `</div>`
                );
              })
              .join("");

            el.innerHTML +=
              `<div class="empty" style="margin-top: 12px">` +
              `<strong>Foco partido</strong>: ${esc(partyName(pid))}` +
              `<div style="margin-top:8px">Detalle por tema (tu preferencia vs posicion del partido).</div>` +
              `</div>` +
              mismatchPanel +
              detailRows;
          }
        }

        for (const btn of el.querySelectorAll("[data-focus-party]")) {
          btn.addEventListener("click", () => {
            const pid = Number(btn.getAttribute("data-focus-party") || 0);
            setPartyFocus(pid);
          });
        }
        for (const btn of el.querySelectorAll("[data-clear-party-focus]")) {
          btn.addEventListener("click", () => {
            clearPartyFocus();
          });
        }

        for (const btn of el.querySelectorAll("[data-pref-set]")) {
          btn.addEventListener("click", () => {
            const pref = String(btn.getAttribute("data-pref-set") || "");
            const t = Number(btn.getAttribute("data-tid") || 0);
            setPrefForTopic(t, pref);
          });
        }
        for (const btn of el.querySelectorAll("[data-pref-clear]")) {
          btn.addEventListener("click", () => {
            const t = Number(btn.getAttribute("data-tid") || 0);
            clearPrefForTopic(t);
          });
        }
        for (const btn of el.querySelectorAll("[data-prefs-clear-all]")) {
          btn.addEventListener("click", () => {
            clearAllPrefs();
          });
        }
        for (const btn of el.querySelectorAll("[data-prefs-share]")) {
          btn.addEventListener("click", () => {
            const wrap = qs("#prefsShareWrap");
            const inp = qs("#prefsShareLink");
            if (!wrap || !inp) return;
            inp.value = buildShareUrlWithPrefs(state.prefs);
            wrap.style.display = "flex";
            inp.focus();
            inp.select();
          });
        }
        for (const btn of el.querySelectorAll("[data-copy-consumer-decision]")) {
          btn.addEventListener("click", async () => {
            const summary = buildConsumerAlignmentShareSummary(alignmentRowsForConsumerSummary, prefsItems);
            const copied = await copyToClipboard(String(summary.text || ""));
            setBanner(
              `<div><strong>Resumen ciudadano</strong>: ${copied ? "copiado al portapapeles" : "no se pudo copiar automaticamente"}.</div>` +
                `<div style="margin-top:8px"><span class="mono">${esc(String(summary.url || ""))}</span></div>`
            );
          });
        }
        for (const btn of el.querySelectorAll("[data-copy-focus-mismatch-summary]")) {
          btn.addEventListener("click", async () => {
            if (!focusDetailPartyId) return;
            const summary = buildFocusMismatchShareSummary(focusDetailPartyId, focusDetailItems, prefsItems);
            const copied = await copyToClipboard(String(summary.text || ""));
            setBanner(
              `<div><strong>Diagnostico de mismatch</strong>: ${copied ? "copiado al portapapeles" : "no se pudo copiar automaticamente"}.</div>` +
                `<div style="margin-top:8px"><span class="mono">${esc(String(summary.url || ""))}</span></div>`
            );
          });
        }
        for (const btn of el.querySelectorAll("[data-guidance-open-topic]")) {
          btn.addEventListener("click", () => {
            const tid2 = Number(btn.getAttribute("data-guidance-open-topic") || 0);
            if (!Number.isFinite(tid2) || tid2 <= 0) return;
            selectTopic(tid2, true);
            scrollToSection("#stepItems");
            setBanner(
              `<div><strong>Tema sugerido abierto</strong>: marca tu postura para reducir empate entre partidos lideres.</div>`
            );
          });
        }
        for (const btn of el.querySelectorAll("[data-consumer-go-items]")) {
          btn.addEventListener("click", () => {
            state.viewMode = "detail";
            const viewSel = qs("#viewMode");
            if (viewSel) viewSel.value = "detail";
            writeUrlState(true);
            renderTopicList();
            renderCompare();
            scrollToSection("#stepItems");
            setBanner(
              `<div><strong>Siguiente paso</strong>: marca postura en mas casos para subir cobertura y estabilidad del ranking.</div>`
            );
          });
        }
        for (const btn of el.querySelectorAll("[data-prefs-copy]")) {
          btn.addEventListener("click", async () => {
            const inp = qs("#prefsShareLink");
            if (!inp) return;
            const txt = String(inp.value || "");
            if (!txt) return;
            try {
              await navigator.clipboard.writeText(txt);
            } catch {
              inp.focus();
              inp.select();
            }
          });
        }
        for (const btn of el.querySelectorAll("[data-prefs-download]")) {
          btn.addEventListener("click", () => {
            const keys = Array.from(state.prefs.keys()).map((x) => Number(x || 0));
            keys.sort((a, b) => a - b);
            const items = [];
            for (const k of keys) {
              const pref = normalizePrefValue(state.prefs.get(k));
              if (!pref) continue;
              const t = state.topicById.get(k) || null;
              items.push({ topic_id: k, pref, label: t ? String(t.label || "") : "" });
            }
            const blob = new Blob([JSON.stringify({ version: "prefs_v1", items }, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "vclc_prefs_v1.json";
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => URL.revokeObjectURL(url), 2500);
          });
        }
        const upload = qs("#prefsUpload");
        if (upload) {
          upload.addEventListener("change", async () => {
            const file = upload.files && upload.files[0] ? upload.files[0] : null;
            upload.value = "";
            if (!file) return;
            try {
              const txt = await file.text();
              const obj = JSON.parse(txt);
              const items = Array.isArray(obj.items) ? obj.items : [];
              const next = new Map();
              for (const it of items) {
                const tid = Number(it.topic_id || 0);
                const pref = normalizePrefValue(it.pref);
                if (!Number.isFinite(tid) || tid <= 0) continue;
                if (!pref) continue;
                if (!state.topicById.has(tid)) continue;
                next.set(tid, pref);
              }
              state.prefs = next;
              persistPrefs();
              renderTopicList();
              renderCompare();
            } catch (err) {
              setBanner(`<div><strong>Error al importar prefs</strong>: <span class="mono">${esc(String(err))}</span></div>`);
            }
          });
        }
      }

      function renderCompare() {
        const el = qs("#compare");
        if (!el) return;
        renderOnboarding();
        renderJourneyFlow();
        const tid = Number(state.activeTopicId || 0);
        const filter = String(qs("#stanceFilter")?.value || "all");
        const sortMode = String(qs("#partySort")?.value || "name");
        const alignmentMode = state.viewMode === "alignment";
        const coherenceMode = state.viewMode === "coherence";
        const stanceSel = qs("#stanceFilter");
        if (stanceSel) {
          stanceSel.disabled = coherenceMode || alignmentMode;
          if (coherenceMode || alignmentMode) stanceSel.value = "all";
        }

        if (!state.activeConcernId) {
          const rec = firstAnswerRecommendation();
          if (rec) {
            const evLink = String((rec.links || {}).explorer_evidence || "");
            const temasLink = String((rec.links || {}).explorer_temas || "");
            el.innerHTML =
              `<div class="empty">` +
              `<div><strong>Elige una preocupacion para empezar.</strong></div>` +
              `<div style="margin-top:8px">Sugerencia rapida: <span class="mono">${esc(String(rec.concern_label || rec.concern_id || ""))}</span> -> <span class="mono">${esc(
                String(rec.topic_label || "")
              )}</span>.</div>` +
              `<div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap">` +
              `<button class="btn md3-button" type="button" data-first-answer-run-inline="1">Usar recomendacion</button>` +
              (evLink
                ? `<a class="smallLink" href="${esc(evLink)}" target="_blank" rel="noopener noreferrer">Evidencia</a>`
                : ``) +
              (temasLink
                ? `<a class="smallLink" href="${esc(temasLink)}" target="_blank" rel="noopener noreferrer">Tema</a>`
                : ``) +
              `</div>` +
              `</div>`;
            for (const btn of el.querySelectorAll("[data-first-answer-run-inline]")) {
              btn.addEventListener("click", () => {
                runFirstAnswerRecommendation(true);
              });
            }
            return;
          }
          el.innerHTML = `<div class="empty">Elige una preocupacion para empezar.</div>`;
          return;
        }

        if (alignmentMode) {
          renderAlignmentCompare(el, { sortMode });
          wireTrustActionNudgeLinks(el);
          return;
        }

        if (!tid) {
          const selected = normalizeSelectedConcernIds(state.selectedConcernIds || []);
          if (coherenceMode) {
            renderCoherenceCompare(el, selected, { sortMode });
            return;
          }
          const isDashboard = state.viewMode === "dashboard";
          if (isDashboard) {
            if (selected.length < 2) {
              el.innerHTML =
                `<div class="empty">` +
                `<strong>Mi dashboard</strong>: selecciona al menos <strong>2</strong> preocupaciones en la columna 1 (se guardan arriba) para ver un resumen multi-concern.` +
                `</div>`;
              return;
            }

            const sum = dashboardPartySummaries();
            if (!sum.items_total) {
              el.innerHTML = `<div class="empty">No hay items para las preocupaciones seleccionadas.</div>`;
              return;
            }
            const dashboardCoverage = coverageStatsForTopics(sum.topics || [], state.posByKey);
            const dashboardUnknownSummary = renderUnknownExplainabilityHint(
              {
                counts: (dashboardCoverage || {}).counts || {},
                total: Number((dashboardCoverage || {}).cells_total || 0),
                coverage_ratio: Number((dashboardCoverage || {}).clear_pct || 0),
              },
              "summary"
            );

            let rows = (sum.rows || []).slice();
            if (filter && filter !== "all") {
              rows = rows.filter((r) => String(r.stance || "") === filter);
            }

            rows.sort((a, b) => {
              if (sortMode === "coverage") {
                const ac = Number(a.coverage_items_ratio || 0);
                const bc = Number(b.coverage_items_ratio || 0);
                if (bc !== ac) return bc - ac;
              }
              if (sortMode === "confidence") {
                const acf = Number(a.confidence_avg || 0);
                const bcf = Number(b.confidence_avg || 0);
                if (bcf !== acf) return bcf - acf;
              }
              const an = partyName(a.party_id);
              const bn = partyName(b.party_id);
              return an.localeCompare(bn);
            });
            const dashboardLimited = limitRowsForExperience(rows);
            const dashboardRows = dashboardLimited.rows;
            const dashboardHiddenHint = consumerHiddenRowsHint(dashboardLimited.hidden, "partidos");

            const concernTags = (sum.concern_ids || [])
              .map((cid) => `<span class="tag">${esc(concernLabelById(cid) || cid)}</span>`)
              .join("");
            const concernExplainers = (sum.concern_ids || [])
              .map((cid) => {
                const desc = concernDescriptionById(cid);
                if (!desc) return "";
                return `<span class="tag"><strong>${esc(concernLabelById(cid) || cid)}:</strong> ${esc(desc)}</span>`;
              })
              .filter((x) => x)
              .join("");
            const activePack = concernPackById(state.activeConcernPackId);
            const activePackTradeoff = activePack ? String(activePack.tradeoff || "").trim() : "";
            const dashboardNudge = renderTrustActionNudge({
              view_mode: "dashboard",
              concern_id: String((sum.concern_ids || [])[0] || ""),
              concern_label: concernLabelById(String((sum.concern_ids || [])[0] || "")),
              rows: (sum.rows || []).map((r) => {
                const pid = Number((r || {}).party_id || 0);
                const audit = r && r.audit_topic ? r.audit_topic : null;
                const trustCov = trustCoverageForPartyTopics(pid, sum.topics || []);
                const trustLinks = {
                  explorer_temas: audit && audit.links ? String(audit.links.explorer_temas || "") : "",
                  explorer_positions: audit && audit.links ? String(audit.links.explorer_positions || "") : "",
                  explorer_evidence: audit && audit.links ? String(audit.links.explorer_evidence || "") : "",
                };
                const trustPanel = buildEvidenceTrustPanel({
                  as_of_date: String(((state.citizen || {}).meta || {}).as_of_date || ""),
                  computed_method: String(((state.citizen || {}).meta || {}).computed_method || state.method || ""),
                  coverage: trustCov,
                  evidence_count_total: Number((trustCov || {}).evidence_count_total || 0),
                  last_evidence_date: String((trustCov || {}).last_evidence_date || ""),
                  coverage_ratio: Number((r || {}).coverage_items_ratio || 0),
                  links: trustLinks,
                });
                return {
                  party_id: pid,
                  party_label: partyName(pid),
                  stance: String((r || {}).stance || "no_signal"),
                  trust_level: String((trustPanel || {}).trust_level || "low"),
                  coverage_ratio: Number((r || {}).coverage_items_ratio || 0),
                  evidence_count_total: Number((trustCov || {}).evidence_count_total || 0),
                  links: {
                    explorer_evidence: String(trustLinks.explorer_evidence || ""),
                  },
                };
              }),
            });

            el.innerHTML =
              `<div class="empty" style="margin-bottom: 12px">` +
              `<div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between">` +
              `<div><strong>Mi dashboard</strong></div>` +
              `<div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center">` +
              `<span class="tag">${esc(computedMethodLabel())}</span>` +
              `<span class="tag">${esc(fmtInt(sum.items_total))} items (union)</span>` +
              `<span class="tag">${esc(fmtInt((sum.concern_ids || []).length))} preocupaciones</span>` +
              (activePack ? `<span class="tag">pack=${esc(String(activePack.label || activePack.id || ""))}</span>` : `<span class="tag">pack=personalizado</span>`) +
              `<button class="btn md3-button" data-dashboard-share-preset="1" type="button">Compartir preset</button>` +
              (state.activePartyId ? `<span class="tag">foco=${esc(partyName(state.activePartyId))}</span>` : "") +
              (state.activePartyId
                ? `<button class="btn md3-button" data-clear-party-focus="1" type="button">Salir foco</button>`
                : "") +
              `</div>` +
              `</div>` +
              `<div class="rowMeta" style="margin-top:8px">` +
              `<span class="tag">Seleccionadas:</span>` +
              `<span class="tags">${concernTags || ""}</span>` +
              `</div>` +
              `<div class="rowMeta" style="margin-top:8px">` +
              `<span class="tag">unknown = incierto + sin_senal</span>` +
              `<span class="tag">confianza alta/media/baja/nula por partido</span>` +
              `</div>` +
              (dashboardUnknownSummary || "") +
              (dashboardNudge || "") +
              (activePackTradeoff
                ? `<div class="rowMeta" style="margin-top:8px"><span class="tag">tradeoff pack</span><span>${esc(activePackTradeoff)}</span></div>`
                : ``) +
              (concernExplainers ? `<div class="rowMeta" style="margin-top:8px">${concernExplainers}</div>` : ``) +
              (dashboardHiddenHint || "") +
              `</div>` +
              (dashboardRows.length
                ? dashboardRows
                    .map((r) => {
                      const pid = Number(r.party_id || 0);
                      const stance = String(r.stance || "no_signal");
                      const counts = r.counts || {};
                      const itemsTotal = Number(r.items_total || 0);
                      const clearTotal = Number(r.clear_total || 0);
                      const cov = Number(r.coverage_items_ratio || 0);
                      const conf = Number(r.confidence_avg || 0);
                      const confTier = confidenceTier(conf, stance);
                      const unknownHint = renderUnknownExplainabilityHint(
                        {
                          counts,
                          total: itemsTotal,
                          coverage_ratio: cov,
                        },
                        "card"
                      );

                      const audit = r.audit_topic || null;
                      const auditLink = audit && audit.links ? String(audit.links.explorer_temas || "") : "";
                      const trustCov = trustCoverageForPartyTopics(pid, sum.topics || []);
                      const trustLinks = {
                        explorer_temas: audit && audit.links ? String(audit.links.explorer_temas || "") : "",
                        explorer_positions: audit && audit.links ? String(audit.links.explorer_positions || "") : "",
                        explorer_evidence: audit && audit.links ? String(audit.links.explorer_evidence || "") : "",
                      };
                      const trustPanel = renderEvidenceTrustPanel(
                        {
                          as_of_date: String(((state.citizen || {}).meta || {}).as_of_date || ""),
                          computed_method: String(((state.citizen || {}).meta || {}).computed_method || state.method || ""),
                          coverage: trustCov,
                          evidence_count_total: Number((trustCov || {}).evidence_count_total || 0),
                          last_evidence_date: String((trustCov || {}).last_evidence_date || ""),
                          coverage_ratio: cov,
                          links: trustLinks,
                        },
                        "card"
                      );

                      const progSum = programasSummaryForParty(pid, sum.concern_ids || []);
                      const progStance = String((progSum || {}).stance || "no_signal");
                      const progConf = Number((progSum || {}).confidence_avg || 0);
                      const progTier = confidenceTier(progConf, progStance);
                      const progLink = String((progSum || {}).audit_link || "");
                      const progCounts = (progSum || {}).counts || {};

                      const focused = state.activePartyId && Number(state.activePartyId) === pid;
                      const showAuditDetails = isAuditMode();

                      return (
                        `<div class="partyCard md3-card ${focused ? "focused" : ""}">` +
                        `<div class="partyHead">` +
                        `<div class="partyName">${esc(partyName(pid))}</div>` +
                        `<div class="stanceChip ${esc(stance)}"><span class="dot ${esc(dotClassForStance(stance))}"></span>${esc(
                          stanceLabel(stance)
                        )}</div>` +
                        `</div>` +
                        `<div class="barWrap">` +
                        `<div class="barLabel"><span>Cobertura (items)</span><span class="mono">${esc(clearTotal)}/${esc(
                          itemsTotal
                        )} (${esc(fmtPct01(cov))})</span></div>` +
                        `<div class="bar"><div style="width:${Math.round(cov * 100)}%"></div></div>` +
                        `</div>` +
                        `<div class="barWrap">` +
                        `<div class="barLabel"><span>Confianza promedio</span><span class="mono">${esc(fmtPct01(conf))}</span></div>` +
                        `<div class="bar"><div style="width:${Math.round(conf * 100)}%"></div></div>` +
                        `</div>` +
                        `<div class="partyMeta">` +
                        (showAuditDetails
                          ? `<span class="tag">items=${esc(fmtInt(itemsTotal))}</span>` +
                            `<span class="tag">a_favor=${esc(fmtInt(Number(counts.support || 0)))}</span>` +
                            `<span class="tag">en_contra=${esc(fmtInt(Number(counts.oppose || 0)))}</span>` +
                            `<span class="tag">mixto=${esc(fmtInt(Number(counts.mixed || 0)))}</span>` +
                            `<span class="tag">incierto=${esc(fmtInt(Number(counts.unclear || 0)))}</span>` +
                            `<span class="tag">sin_senal=${esc(fmtInt(Number(counts.no_signal || 0)))}</span>` +
                            `<span class="tag ${esc(confidenceTierTagClass(confTier))}">conf_tier=${esc(confidenceTierLabel(confTier))}</span>`
                          : `<span class="tag">cobertura=${esc(fmtPct01(cov))}</span>` +
                            `<span class="tag">confianza=${esc(fmtPct01(conf))}</span>` +
                            `<span class="tag">unknown=${esc(fmtInt(Number(counts.unclear || 0) + Number(counts.no_signal || 0)))}</span>`) +
                        `</div>` +
                        (unknownHint || "") +
                        (showAuditDetails ? trustPanel || "" : "") +
                        `<div class="partyMeta">` +
                        `<button class="btn md3-button" type="button" data-focus-party="${esc(String(pid))}">Ver top items</button>` +
                        (auditLink
                          ? `<a class="smallLink" href="${esc(String(auditLink))}" target="_blank" rel="noopener noreferrer">Auditar item</a>`
                          : `<span class="tag">sin audit link</span>`) +
                        `</div>` +
                        (showAuditDetails
                          ? `<div class="partyMeta">` +
                            `<span class="tag">Programa</span>` +
                            `<span class="stanceChip mini ${esc(progStance)}">` +
                            `<span class="dot ${esc(dotClassForStance(progStance))}"></span>${esc(stanceLabel(progStance))}` +
                            `</span>` +
                            `<span class="tag">conf=${esc(fmtPct01(progConf))}</span>` +
                            `<span class="tag ${esc(confidenceTierTagClass(progTier))}">tier=${esc(confidenceTierLabel(progTier))}</span>` +
                            `<span class="tag">ok=${esc(fmtInt(Number(progCounts.support || 0) + Number(progCounts.oppose || 0) + Number(progCounts.mixed || 0)))}/${esc(
                              fmtInt(Number((sum.concern_ids || []).length))
                            )}</span>` +
                            (progLink
                              ? `<a class="smallLink" href="${esc(String(progLink))}" target="_blank" rel="noopener noreferrer">Evidencia (programa)</a>`
                              : `<span class="tag">sin evidencia</span>`) +
                            `</div>`
                          : "") +
                        `</div>`
                      );
                    })
                    .join("")
                : `<div class="empty">No hay partidos que coincidan con el filtro actual.</div>`);

            for (const btn of el.querySelectorAll("[data-focus-party]")) {
              btn.addEventListener("click", () => {
                const pid = Number(btn.getAttribute("data-focus-party") || 0);
                setPartyFocus(pid);
              });
            }
            for (const btn of el.querySelectorAll("[data-clear-party-focus]")) {
              btn.addEventListener("click", () => {
                clearPartyFocus();
              });
            }
            for (const btn of el.querySelectorAll("[data-dashboard-share-preset]")) {
              btn.addEventListener("click", async () => {
                const payload = currentAlignmentPresetForShare();
                const url = buildAlignmentPresetShareUrl(payload);
                const copied = await copyToClipboard(url);
                setBanner(
                  `<div><strong>Preset de alineamiento</strong>: ${copied ? "copiado al portapapeles" : "no se pudo copiar automaticamente"}.</div>` +
                    `<div style="margin-top:8px"><span class="mono">${esc(url)}</span></div>`
                );
              });
            }
            wireTrustActionNudgeLinks(el);
            return;
          }

          const cid = String(state.activeConcernId || "");
          const cobj = (state.concerns || []).find((c) => String(c.id || "") === cid) || null;
          const concernLabel = cobj ? String(cobj.label || cid) : cid;
          const concernDescription = cobj ? String(cobj.description || "").trim() : "";

          const sum = concernPartySummaries();
          if (!sum.items_total) {
            el.innerHTML = `<div class="empty">No hay items para esta preocupacion.</div>`;
            return;
          }
          const concernCoverage = coverageStatsForTopics(sum.topics || [], state.posByKey);
          const concernUnknownSummary = renderUnknownExplainabilityHint(
            {
              counts: (concernCoverage || {}).counts || {},
              total: Number((concernCoverage || {}).cells_total || 0),
              coverage_ratio: Number((concernCoverage || {}).clear_pct || 0),
            },
            "summary"
          );

          let rows = (sum.rows || []).slice();
          if (filter && filter !== "all") {
            rows = rows.filter((r) => String(r.stance || "") === filter);
          }

          rows.sort((a, b) => {
            if (sortMode === "coverage") {
              const ac = Number(a.coverage_items_ratio || 0);
              const bc = Number(b.coverage_items_ratio || 0);
              if (bc !== ac) return bc - ac;
            }
            if (sortMode === "confidence") {
              const acf = Number(a.confidence_avg || 0);
              const bcf = Number(b.confidence_avg || 0);
              if (bcf !== acf) return bcf - acf;
            }
            const an = partyName(a.party_id);
            const bn = partyName(b.party_id);
            return an.localeCompare(bn);
          });
          const concernLimited = limitRowsForExperience(rows);
          const concernRows = concernLimited.rows;
          const concernHiddenHint = consumerHiddenRowsHint(concernLimited.hidden, "partidos");

          const concernNudge = renderTrustActionNudge({
            view_mode: "concern",
            concern_id: cid,
            concern_label: concernLabel,
            rows: (sum.rows || []).map((r) => {
              const pid = Number((r || {}).party_id || 0);
              const audit = r && r.audit_topic ? r.audit_topic : null;
              const trustCov = trustCoverageForPartyTopics(pid, sum.topics || []);
              const trustLinks = {
                explorer_temas: audit && audit.links ? String(audit.links.explorer_temas || "") : "",
                explorer_positions: audit && audit.links ? String(audit.links.explorer_positions || "") : "",
                explorer_evidence: audit && audit.links ? String(audit.links.explorer_evidence || "") : "",
              };
              const trustPanel = buildEvidenceTrustPanel({
                as_of_date: String(((state.citizen || {}).meta || {}).as_of_date || ""),
                computed_method: String(((state.citizen || {}).meta || {}).computed_method || state.method || ""),
                coverage: trustCov,
                evidence_count_total: Number((trustCov || {}).evidence_count_total || 0),
                last_evidence_date: String((trustCov || {}).last_evidence_date || ""),
                coverage_ratio: Number((r || {}).coverage_items_ratio || 0),
                links: trustLinks,
              });
              return {
                party_id: pid,
                party_label: partyName(pid),
                stance: String((r || {}).stance || "no_signal"),
                trust_level: String((trustPanel || {}).trust_level || "low"),
                coverage_ratio: Number((r || {}).coverage_items_ratio || 0),
                evidence_count_total: Number((trustCov || {}).evidence_count_total || 0),
                links: {
                  explorer_evidence: String(trustLinks.explorer_evidence || ""),
                },
              };
            }),
          });

          el.innerHTML =
            `<div class="empty" style="margin-bottom: 12px">` +
            `<div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between">` +
            `<div><strong>${esc(concernLabel)}</strong></div>` +
            `<div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center">` +
            `<span class="tag">${esc(computedMethodLabel())}</span>` +
            `<span class="tag">${esc(fmtInt(sum.items_total))} items (total)</span>` +
            (state.activePartyId ? `<span class="tag">foco=${esc(partyName(state.activePartyId))}</span>` : "") +
            (state.activePartyId
              ? `<button class="btn md3-button" data-clear-party-focus="1" type="button">Salir foco</button>`
              : "") +
            `</div>` +
            `</div>` +
            `<div class="rowMeta" style="margin-top:8px">` +
            `<span class="tag">Resumen global: todos los items etiquetados</span>` +
            `<span class="tag">Columna 2 sirve para navegar/buscar items</span>` +
            `<span class="tag">Cobertura(items) = (a_favor+en_contra+mixto)/items</span>` +
            `<span class="tag">unknown = incierto + sin_senal</span>` +
            `</div>` +
            (concernUnknownSummary || "") +
            (concernNudge || "") +
            (concernDescription
              ? `<div class="rowMeta" style="margin-top:8px"><span class="tag">explicacion</span><span>${esc(concernDescription)}</span></div>`
              : ``) +
            (concernHiddenHint || "") +
            `</div>` +
            (concernRows.length
              ? concernRows
                  .map((r) => {
                    const pid = Number(r.party_id || 0);
                    const stance = String(r.stance || "no_signal");
                    const counts = r.counts || {};
                    const itemsTotal = Number(r.items_total || 0);
                    const clearTotal = Number(r.clear_total || 0);
                    const cov = Number(r.coverage_items_ratio || 0);
                    const conf = Number(r.confidence_avg || 0);
                    const confTier = confidenceTier(conf, stance);
                    const unknownHint = renderUnknownExplainabilityHint(
                      {
                        counts,
                        total: itemsTotal,
                        coverage_ratio: cov,
                      },
                      "card"
                    );

                    const audit = r.audit_topic || null;
                    const auditLink = audit && audit.links ? String(audit.links.explorer_temas || "") : "";
                    const trustCov = trustCoverageForPartyTopics(pid, sum.topics || []);
                    const trustLinks = {
                      explorer_temas: audit && audit.links ? String(audit.links.explorer_temas || "") : "",
                      explorer_positions: audit && audit.links ? String(audit.links.explorer_positions || "") : "",
                      explorer_evidence: audit && audit.links ? String(audit.links.explorer_evidence || "") : "",
                    };
                    const trustPanel = renderEvidenceTrustPanel(
                      {
                        as_of_date: String(((state.citizen || {}).meta || {}).as_of_date || ""),
                        computed_method: String(((state.citizen || {}).meta || {}).computed_method || state.method || ""),
                        coverage: trustCov,
                        evidence_count_total: Number((trustCov || {}).evidence_count_total || 0),
                        last_evidence_date: String((trustCov || {}).last_evidence_date || ""),
                        coverage_ratio: cov,
                        links: trustLinks,
                      },
                      "card"
                    );

                    const progKey = `${String(state.activeConcernId || "")}:${pid}`;
                    const prog = state.progByKey.get(progKey) || null;
                    const progStance = prog ? String(prog.stance || "no_signal") : "no_signal";
                    const progConf = prog ? Number(prog.confidence || 0) : 0;
                    const progTier = confidenceTier(progConf, progStance);
                    const progLink = prog && prog.links ? String(prog.links.explorer_evidence || "") : "";

                    const focused = state.activePartyId && Number(state.activePartyId) === pid;
                    const showAuditDetails = isAuditMode();

                    return (
                      `<div class="partyCard md3-card ${focused ? "focused" : ""}">` +
                      `<div class="partyHead">` +
                      `<div class="partyName">${esc(partyName(pid))}</div>` +
                      `<div class="stanceChip ${esc(stance)}"><span class="dot ${esc(dotClassForStance(stance))}"></span>${esc(
                        stanceLabel(stance)
                      )}</div>` +
                      `</div>` +
                      `<div class="barWrap">` +
                      `<div class="barLabel"><span>Cobertura (items)</span><span class="mono">${esc(clearTotal)}/${esc(
                        itemsTotal
                      )} (${esc(fmtPct01(cov))})</span></div>` +
                      `<div class="bar"><div style="width:${Math.round(cov * 100)}%"></div></div>` +
                      `</div>` +
                      `<div class="barWrap">` +
                      `<div class="barLabel"><span>Confianza promedio</span><span class="mono">${esc(fmtPct01(conf))}</span></div>` +
                      `<div class="bar"><div style="width:${Math.round(conf * 100)}%"></div></div>` +
                      `</div>` +
                      `<div class="partyMeta">` +
                      (showAuditDetails
                        ? `<span class="tag">items=${esc(fmtInt(itemsTotal))}</span>` +
                          `<span class="tag">a_favor=${esc(fmtInt(Number(counts.support || 0)))}</span>` +
                          `<span class="tag">en_contra=${esc(fmtInt(Number(counts.oppose || 0)))}</span>` +
                          `<span class="tag">mixto=${esc(fmtInt(Number(counts.mixed || 0)))}</span>` +
                          `<span class="tag">incierto=${esc(fmtInt(Number(counts.unclear || 0)))}</span>` +
                          `<span class="tag">sin_senal=${esc(fmtInt(Number(counts.no_signal || 0)))}</span>` +
                          `<span class="tag ${esc(confidenceTierTagClass(confTier))}">conf_tier=${esc(confidenceTierLabel(confTier))}</span>`
                        : `<span class="tag">cobertura=${esc(fmtPct01(cov))}</span>` +
                          `<span class="tag">confianza=${esc(fmtPct01(conf))}</span>` +
                          `<span class="tag">unknown=${esc(fmtInt(Number(counts.unclear || 0) + Number(counts.no_signal || 0)))}</span>`) +
                      `</div>` +
                      (unknownHint || "") +
                      (showAuditDetails ? trustPanel || "" : "") +
                      `<div class="partyMeta">` +
                      `<button class="btn md3-button" type="button" data-focus-party="${esc(String(pid))}">Ver top items</button>` +
                      (auditLink
                        ? `<a class="smallLink" href="${esc(String(auditLink))}" target="_blank" rel="noopener noreferrer">Auditar top item</a>`
                        : `<span class="tag">sin audit link</span>`) +
                      `</div>` +
                      (showAuditDetails
                        ? `<div class="partyMeta">` +
                          `<span class="tag">Programa</span>` +
                          `<span class="stanceChip mini ${esc(progStance)}">` +
                          `<span class="dot ${esc(dotClassForStance(progStance))}"></span>${esc(stanceLabel(progStance))}` +
                          `</span>` +
                          `<span class="tag">conf=${esc(fmtPct01(progConf))}</span>` +
                          `<span class="tag ${esc(confidenceTierTagClass(progTier))}">tier=${esc(confidenceTierLabel(progTier))}</span>` +
                          (progLink
                            ? `<a class="smallLink" href="${esc(String(progLink))}" target="_blank" rel="noopener noreferrer">Evidencia (programa)</a>`
                            : `<span class="tag">sin evidencia</span>`) +
                          `</div>`
                        : "") +
                      `</div>`
                    );
                  })
                  .join("")
              : `<div class="empty">No hay partidos que coincidan con el filtro actual.</div>`);

          for (const btn of el.querySelectorAll("[data-focus-party]")) {
            btn.addEventListener("click", () => {
              const pid = Number(btn.getAttribute("data-focus-party") || 0);
              setPartyFocus(pid);
            });
          }
          for (const btn of el.querySelectorAll("[data-clear-party-focus]")) {
            btn.addEventListener("click", () => {
              clearPartyFocus();
            });
          }
          wireTrustActionNudgeLinks(el);
          return;
        }

        const topic = state.topicById.get(tid) || null;
        const rows = positionsForTopic(tid);
        const counts = stanceCounts(rows);

        let filtered = rows.slice();
        if (filter && filter !== "all") {
          filtered = filtered.filter((r) => String(r.stance || "") === filter);
        }

        filtered.sort((a, b) => {
          if (sortMode === "coverage") {
            const ac = Number((a.coverage || {}).members_with_signal || 0) / Math.max(1, Number((a.coverage || {}).members_total || 0));
            const bc = Number((b.coverage || {}).members_with_signal || 0) / Math.max(1, Number((b.coverage || {}).members_total || 0));
            if (bc !== ac) return bc - ac;
          }
          if (sortMode === "confidence") {
            const acf = Number(a.confidence || 0);
            const bcf = Number(b.confidence || 0);
            if (bcf !== acf) return bcf - acf;
          }
          const an = partyName(a.party_id);
          const bn = partyName(b.party_id);
          return an.localeCompare(bn);
        });
        const topicLimited = limitRowsForExperience(filtered);
        const topicRows = topicLimited.rows;
        const topicHiddenHint = consumerHiddenRowsHint(topicLimited.hidden, "partidos");
        const maxMembersTotalInTopic = topicRows.reduce((max, row) => {
          const cov = row && row.coverage ? row.coverage : {};
          return Math.max(max, Number(cov.members_total || 0));
        }, 0);

        const topicLinks = topic && topic.links ? topic.links : {};
        const topicUnknownSummary = renderUnknownExplainabilityHint(
          {
            counts,
            total: rows.length,
            coverage_ratio:
              rows.length > 0
                ? (Number(counts.support || 0) + Number(counts.oppose || 0) + Number(counts.mixed || 0)) / rows.length
                : 0,
          },
          "summary"
        );
        const topicNudge = renderTrustActionNudge({
          view_mode: "topic",
          concern_id: String(state.activeConcernId || ""),
          concern_label: concernLabelById(String(state.activeConcernId || "")),
          topic_id: tid,
          topic_label: String(topic ? topic.label || "" : ""),
          rows: (rows || []).map((r) => {
            const pid = Number((r || {}).party_id || 0);
            const cov = r && r.coverage ? r.coverage : {};
            const membersTotal = Number((cov || {}).members_total || 0);
            const membersSignal = Number((cov || {}).members_with_signal || 0);
            const coverageRatio = membersTotal > 0 ? membersSignal / membersTotal : 0;
            const trustPanel = buildEvidenceTrustPanel({
              as_of_date: String(((state.citizen || {}).meta || {}).as_of_date || ""),
              computed_method: String(((state.citizen || {}).meta || {}).computed_method || state.method || ""),
              coverage: cov,
              evidence_count_total: Number((cov || {}).evidence_count_total || 0),
              last_evidence_date: String((cov || {}).last_evidence_date || ""),
              coverage_ratio: coverageRatio,
              links: {
                explorer_temas: String(((r || {}).links || {}).explorer_temas || ""),
                explorer_positions: String(((r || {}).links || {}).explorer_positions || ""),
                explorer_evidence: String(((r || {}).links || {}).explorer_evidence || ""),
              },
            });
            return {
              party_id: pid,
              party_label: partyName(pid),
              stance: String((r || {}).stance || "no_signal"),
              trust_level: String((trustPanel || {}).trust_level || "low"),
              coverage_ratio: coverageRatio,
              evidence_count_total: Number((cov || {}).evidence_count_total || 0),
              links: {
                explorer_evidence: String(((r || {}).links || {}).explorer_evidence || ""),
              },
            };
          }),
        });
        const consumerAnswer = renderConsumerTopicAnswer(topic, tid, rows);

        el.innerHTML =
          (consumerAnswer || "") +
          `<div class="summaryGrid">` +
          `<div class="kpi"><div class="k">A favor</div><div class="v">${fmtInt(counts.support)}</div></div>` +
          `<div class="kpi"><div class="k">En contra</div><div class="v">${fmtInt(counts.oppose)}</div></div>` +
          `<div class="kpi"><div class="k">Mixto</div><div class="v">${fmtInt(counts.mixed)}</div></div>` +
          `<div class="kpi"><div class="k">Incierto</div><div class="v">${fmtInt(counts.unclear)}</div></div>` +
          `<div class="kpi"><div class="k">Sin senal</div><div class="v">${fmtInt(counts.no_signal)}</div></div>` +
          `</div>` +
          `<div class="empty" style="margin-bottom: 12px">` +
          `<div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between">` +
          `<div><strong>${esc(String(topic ? topic.label : `topic_id=${tid}`))}</strong></div>` +
          `<div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center">` +
          (topicLinks.explorer_temas
            ? `<a class="smallLink" href="${esc(String(topicLinks.explorer_temas))}" target="_blank" rel="noopener noreferrer">Abrir en Temas</a>`
            : "") +
          (topicLinks.explorer_evidence
            ? `<a class="smallLink" href="${esc(String(topicLinks.explorer_evidence))}" target="_blank" rel="noopener noreferrer">Evidencia (SQL)</a>`
            : "") +
          `</div>` +
          `</div>` +
          `<div class="rowMeta" style="margin-top:8px">` +
          `<span class="tag">Regla: si cobertura < 20%, mostramos Incierto</span>` +
          `<span class="tag">Senal util = diputados con senal / total del partido</span>` +
          `<span class="tag">Peso relativo = total del partido / mayor bancada del caso</span>` +
          `<span class="tag">unknown = sin senal dentro del partido</span>` +
          `</div>` +
          (topicUnknownSummary || "") +
          (topicNudge || "") +
          (topicHiddenHint || "") +
          `</div>` +
          (topicRows.length
            ? topicRows
                .map((r) => {
                  const pid = Number(r.party_id || 0);
                  const stance = String(r.stance || "unclear");
                  const cov = r.coverage || {};
                  const membersTotal = Number(cov.members_total || 0);
                  const membersSignal = Number(cov.members_with_signal || 0);
                  const coverageRatio = membersTotal > 0 ? membersSignal / membersTotal : 0;
                  const unknownMembers = Math.max(0, membersTotal - membersSignal);
                  const weightRatio = maxMembersTotalInTopic > 0 ? membersTotal / maxMembersTotalInTopic : 0;
                  const signalPct = Math.max(0, Math.min(100, Math.round(coverageRatio * 100)));
                  const unknownPct = Math.max(0, 100 - signalPct);
                  const weightPct = Math.max(0, Math.min(100, Math.round(weightRatio * 100)));
                  const conf = Number(r.confidence || 0);
                  const confTier = confidenceTier(conf, stance);
                  const evCount = Number(cov.evidence_count_total || 0);
                  const lastEv = String(cov.last_evidence_date || "");
                  const linkPos = (r.links || {}).explorer_positions || "";
                  const linkTemas = (r.links || {}).explorer_temas || "";
                  const unknownHint = renderUnknownExplainabilityHint(
                    {
                      counts: unknownCountsForTopicStance(stance),
                      total: 1,
                      coverage_ratio: coverageRatio,
                    },
                    "card"
                  );
                  const trustPanel = renderEvidenceTrustPanel(
                    {
                      as_of_date: String(((state.citizen || {}).meta || {}).as_of_date || ""),
                      computed_method: String(((state.citizen || {}).meta || {}).computed_method || state.method || ""),
                      coverage: cov,
                      evidence_count_total: evCount,
                      last_evidence_date: lastEv,
                      coverage_ratio: coverageRatio,
                      links: {
                        explorer_temas: linkTemas,
                        explorer_positions: linkPos,
                        explorer_evidence: String((r.links || {}).explorer_evidence || ""),
                      },
                    },
                    "card"
                  );

                  const progKey = `${String(state.activeConcernId || "")}:${pid}`;
                  const prog = state.progByKey.get(progKey) || null;
                  const progStance = prog ? String(prog.stance || "no_signal") : "no_signal";
                  const progConf = prog ? Number(prog.confidence || 0) : 0;
                  const progTier = confidenceTier(progConf, progStance);
                  const progLink = prog && prog.links ? String(prog.links.explorer_evidence || "") : "";
                  const showAuditDetails = isAuditMode();

                  return (
                    `<div class="partyCard md3-card topicCompareCard">` +
                    `<div class="partyHead">` +
                    `<div class="partyName">${esc(partyName(pid))}</div>` +
                    `<div class="stanceChip ${esc(stance)}"><span class="dot ${esc(dotClassForStance(stance))}"></span>${esc(
                      stanceLabel(stance)
                    )}</div>` +
                    `</div>` +
                    `<div class="topicScales">` +
                    `<div class="topicScale">` +
                    `<div class="topicScaleHead"><strong>Senal util</strong><span class="mono">${esc(membersSignal)}/${esc(
                      membersTotal
                    )} (${esc(fmtPct01(coverageRatio))})</span></div>` +
                    `<div class="topicScaleTrack">` +
                    `<span class="topicScaleSignal ${esc(stance)}" style="width:${signalPct}%"></span>` +
                    `<span class="topicScaleUnknown" style="width:${unknownPct}%"></span>` +
                    `</div>` +
                    `<div class="topicScaleHint">unknown=${esc(fmtInt(unknownMembers))}/${esc(fmtInt(membersTotal))} · escala interna del partido</div>` +
                    `</div>` +
                    `<div class="topicScale">` +
                    `<div class="topicScaleHead"><strong>Peso relativo</strong><span class="mono">${esc(fmtInt(membersTotal))}/${esc(
                      fmtInt(maxMembersTotalInTopic || membersTotal || 0)
                    )} (${esc(fmtPct01(weightRatio))})</span></div>` +
                    `<div class="topicScaleWeightTrack"><div class="topicScaleWeightFill" style="width:${weightPct}%"></div></div>` +
                    `<div class="topicScaleHint">comparables entre partidos en este mismo caso</div>` +
                    `</div>` +
                    `</div>` +
                    `<div class="partyMeta">` +
                    (showAuditDetails
                      ? `<span class="tag">evidence_count=${esc(fmtInt(evCount))}</span>` +
                        `<span class="tag">unknown=${esc(fmtInt(unknownMembers))}</span>` +
                        `<span class="tag ${esc(confidenceTierTagClass(confTier))}">conf_tier=${esc(confidenceTierLabel(confTier))}</span>` +
                        (lastEv ? `<span class="tag">ultima=${esc(lastEv)}</span>` : `<span class="tag">ultima=?</span>`)
                      : `<span class="tag">confianza=${esc(fmtPct01(conf))}</span>` +
                        `<span class="tag">peso=${esc(fmtPct01(weightRatio))}</span>` +
                        `<span class="tag">unknown=${esc(fmtInt(unknownMembers))}/${esc(fmtInt(membersTotal))}</span>`) +
                    (linkPos ? `<a class="smallLink" href="${esc(String(linkPos))}" target="_blank" rel="noopener noreferrer">Ver posiciones</a>` : "") +
                    (linkTemas ? `<a class="smallLink" href="${esc(String(linkTemas))}" target="_blank" rel="noopener noreferrer">Ver en Temas</a>` : "") +
                    `</div>` +
                    (unknownHint || "") +
                    (showAuditDetails ? trustPanel || "" : "") +
                    (showAuditDetails
                      ? `<div class="partyMeta">` +
                        `<span class="tag">Programa</span>` +
                        `<span class="stanceChip mini ${esc(progStance)}">` +
                        `<span class="dot ${esc(dotClassForStance(progStance))}"></span>${esc(stanceLabel(progStance))}` +
                        `</span>` +
                        `<span class="tag">conf=${esc(fmtPct01(progConf))}</span>` +
                        `<span class="tag ${esc(confidenceTierTagClass(progTier))}">tier=${esc(confidenceTierLabel(progTier))}</span>` +
                        (progLink
                          ? `<a class="smallLink" href="${esc(String(progLink))}" target="_blank" rel="noopener noreferrer">Evidencia (programa)</a>`
                          : `<span class="tag">sin evidencia</span>`) +
                        `</div>`
                      : "") +
                    `</div>`
                  );
                })
                .join("")
            : `<div class="empty">No hay partidos que coincidan con el filtro actual.</div>`);

        for (const btn of el.querySelectorAll("[data-consumer-pref]")) {
          btn.addEventListener("click", () => {
            const raw = String(btn.getAttribute("data-consumer-pref") || "");
            const parts = raw.split(":");
            const tid2 = Number(parts[0] || 0);
            const pref = String(parts[1] || "");
            if (!Number.isFinite(tid2) || tid2 <= 0) return;
            if (!pref) return;
            setPrefForTopic(tid2, pref);
          });
        }
        for (const btn of el.querySelectorAll("[data-consumer-pref-clear]")) {
          btn.addEventListener("click", () => {
            const tid2 = Number(btn.getAttribute("data-consumer-pref-clear") || 0);
            clearPrefForTopic(tid2);
          });
        }
        for (const btn of el.querySelectorAll("[data-consumer-go-alignment]")) {
          btn.addEventListener("click", () => {
            state.viewMode = "alignment";
            const viewSel = qs("#viewMode");
            if (viewSel) viewSel.value = "alignment";
            writeUrlState(true);
            renderTopicList();
            renderCompare();
          });
        }
        wireTrustActionNudgeLinks(el);
      }

      function selectConcern(cid, push) {
        const next = String(cid || "").trim();
        if (!next) return;
        resetConsumerProgressiveDisclosure();
        state.activeConcernId = next;
        // Keep party focus when switching concerns (user-first).

        // Ensure selected concerns includes the active one.
        const cur = normalizeSelectedConcernIds([next].concat(state.selectedConcernIds || []));
        state.selectedConcernIds = cur;

        // Reset topic unless it still belongs (based on concern tags, not window filters).
        if (state.activeTopicId) {
          const tags = state.topicTags.get(Number(state.activeTopicId)) || [];
          if (!tags.includes(next)) state.activeTopicId = 0;
        }
        if (state.activeTopicId && state.activeConcernId) {
          // extra guard: activeTopicId must exist.
          if (!state.topicById.get(Number(state.activeTopicId))) {
            state.activeTopicId = 0;
          }
        }
        if (state.activeTopicId && !Number.isFinite(Number(state.activeTopicId))) {
          state.activeTopicId = 0;
        }

        writeUrlState(Boolean(push));
        renderSelectedConcernTags();
        renderConcernList();
        renderTopicList();
        renderCompare();
      }

      function selectTopic(tid, push) {
        const next = Number(tid || 0);
        if (!Number.isFinite(next) || next <= 0) return;
        state.consumerShowAllParties = false;
        state.activeTopicId = next;
        const activePack = concernPackById(state.activeConcernPackId || "");
        if (activePack) {
          const quality = concernPackQualityForPack(activePack.id);
          recordConcernPackOutcomeEvent("topic_open_with_pack", {
            pack_id: String(activePack.id || ""),
            pack_weak: quality && typeof quality.weak === "boolean" ? Boolean(quality.weak) : null,
            topic_id: next,
            concern_ids_count: Number((state.selectedConcernIds || []).length || 0),
            source: "topic_select",
          });
        }
        writeUrlState(Boolean(push));
        renderTopicList();
        renderCompare();
      }

      async function load() {
        readUrlState();

        state.presetLoadError = "";
        state.presetLoadErrorCode = "";
        state.presetLoadedFrom = "empty";
        state.presetCanonicalHash = "";
        state.presetRecoveredFrom = "";
        state.presetHashWasNormalized = false;
        state.hashPresetActive = false;
        state.concernPackQuality = null;
        state.concernPackQualityById = new Map();
        state.concernPackQualityLoadError = "";
        const presetFromHash = readPresetFromHash();
        if (presetFromHash && presetFromHash.error) {
          state.presetLoadError = String(presetFromHash.error || "");
          state.presetLoadErrorCode = String(presetFromHash.error_code || "");
        }
        if (presetFromHash && presetFromHash.preset) {
          const preset = presetFromHash.preset;
          if (preset.concerns_ids && preset.concerns_ids.length) state.selectedConcernIds = preset.concerns_ids;
          if (preset.concern_pack) state.activeConcernPackId = preset.concern_pack;
          if (preset.concern) state.activeConcernId = preset.concern;
          if (preset.view) state.viewMode = preset.view;
          if (preset.method) state.method = preset.method;
          state.presetCanonicalHash = String(presetFromHash.canonical_hash || "");
          state.presetRecoveredFrom = String(presetFromHash.recovered_from || "");
          state.presetLoadedFrom = "hash_preset";
          state.hashPresetActive = true;
          if (state.presetCanonicalHash && state.presetCanonicalHash !== String(location.hash || "")) {
            const u = new URL(String(location.href || ""), String(location.origin || undefined));
            u.hash = state.presetCanonicalHash;
            history.replaceState({}, "", `${u.pathname}${u.search}${u.hash}`);
            state.presetHashWasNormalized = true;
          }
        }

        // Preferences: local-first by default. Opt-in share uses URL fragment (#prefs=...).
        state.prefsLoadError = "";
        state.prefsLoadedFrom = "empty";
        const fromHash = readPrefsFromHash();
        if (fromHash && fromHash.error) {
          state.prefsLoadError = String(fromHash.error || "prefs hash error");
        }
        if (fromHash && fromHash.prefs) {
          state.prefs = fromHash.prefs;
          state.prefsLoadedFrom = "hash";
          persistPrefs(); // store locally for convenience
        } else {
          state.prefs = prefsFromStorageValue(lsGet(LS_PREFS));
          state.prefsLoadedFrom = state.prefs.size ? "localStorage" : "empty";
        }

        const p = new URLSearchParams(location.search || "");
        const citizenOverride = String(p.get("citizen") || "").trim();
        const wantsMethod = String(p.get("method") || "").trim();
        const concernsPath = String(p.get("concerns") || "./data/concerns_v1.json");

        let citizenPath = citizenOverride;
        if (!citizenPath) {
          // Resolve preferred method before loading data so method toggle can select a dataset file.
          let m = String(state.method || "").trim() || wantsMethod;
          if (!m) m = String(lsGet(LS_METHOD) || "").trim();
          if (!m) m = "combined";
          if (m !== "combined" && m !== "votes" && m !== "declared") m = "combined";
          state.method = m;

          if (m === "votes") citizenPath = "./data/citizen_votes.json";
          else if (m === "declared") citizenPath = "./data/citizen_declared.json";
          else citizenPath = "./data/citizen.json";
        }

        try {
          const citizenP = fetchJson(citizenPath).catch(async (err) => {
            // If the user asked for a method variant but the file isn't present, fall back to default.
            if (!citizenOverride && citizenPath !== "./data/citizen.json") {
              setBanner(
                `<div><strong>Aviso:</strong> no se pudo cargar <span class="mono">${esc(
                  citizenPath
                )}</span>. Se usa <span class="mono">citizen.json</span> por defecto. Error: <span class="mono">${esc(String(err))}</span></div>`
              );
              state.method = "combined";
              return await fetchJson("./data/citizen.json");
            }
            throw err;
          });

          const packQualityP = fetchJson("./data/concern_pack_quality.json").catch((err) => {
            state.concernPackQualityLoadError = String(err || "");
            return null;
          });

          const [citizen, concernsCfg, packQuality] = await Promise.all([citizenP, fetchJson(concernsPath), packQualityP]);
          state.citizen = citizen;
          state.concernsCfg = concernsCfg;
          loadConcernPackQualityRows(packQuality);
          state.concerns = Array.isArray(concernsCfg.concerns) ? concernsCfg.concerns : [];
          state.concernPacks = [];
          for (const rawPack of Array.isArray(concernsCfg.packs) ? concernsCfg.packs : []) {
            const pack = normalizeConcernPackConfig(rawPack);
            if (!pack) continue;
            if (state.concernPacks.some((p) => String(p.id || "") === String(pack.id || ""))) continue;
            state.concernPacks.push(pack);
          }

          state.topicById = new Map();
          for (const t of citizen.topics || []) {
            state.topicById.set(Number(t.topic_id || 0), t);
          }

          // Drop preferences for topics not present in the current snapshot.
          let prefsDropped = 0;
          for (const k of Array.from(state.prefs.keys())) {
            if (!state.topicById.has(Number(k))) {
              state.prefs.delete(Number(k));
              prefsDropped += 1;
            }
          }
          if (prefsDropped) persistPrefs();

          state.partyById = new Map();
          for (const party of citizen.parties || []) {
            state.partyById.set(Number(party.party_id || 0), party);
          }

          state.posByKey = new Map();
          for (const r of citizen.party_topic_positions || []) {
            const key = `${Number(r.topic_id || 0)}:${Number(r.party_id || 0)}`;
            state.posByKey.set(key, r);
          }

          state.progByKey = new Map();
          for (const r of citizen.party_concern_programas || []) {
            const key = `${String(r.concern_id || "")}:${Number(r.party_id || 0)}`;
            state.progByKey.set(key, r);
          }
          state.programasMeta = (citizen.meta || {}).programas || null;

          computeTags();
          state.firstAnswerPlan = computeFirstAnswerPlanFromState();
          ensureConcernState();
          renderSelectedConcernTags();
          renderStatus();

          // Validate initial topic.
          if (state.activeTopicId) {
            const tags = state.topicTags.get(Number(state.activeTopicId)) || [];
            if (!tags.includes(String(state.activeConcernId))) state.activeTopicId = 0;
          }

          writeUrlState(false);

          renderConcernList();
          renderTopicList();
          renderCompare();

          let banner =
            isConsumerMode()
              ? `<div><strong>Como usarlo rapido:</strong> 1) elige preocupacion, 2) abre un caso, 3) marca tu postura, 4) compara y abre evidencia solo donde haya dudas.</div>`
              : `<div><strong>Nota:</strong> esto es una vista ciudadana. “Programa” es una capa adicional (promesas) derivada de textos y puede requerir revision. Para auditoria completa, abre <a class="smallLink" href="../explorer-temas/">Temas</a> y <a class="smallLink" href="../explorer/">Explorer SQL</a>.</div>`;
          if (state.prefsLoadedFrom === "hash") {
            banner += `<div style="margin-top:8px"><strong>Preferencias:</strong> cargadas desde un enlace compartido y guardadas localmente en tu navegador.</div>`;
          }
          if (state.presetLoadedFrom === "hash_preset") {
            banner += `<div style="margin-top:8px"><strong>Preset:</strong> cargado desde enlace compartido de alineamiento (<span class="mono">#preset=...</span>).</div>`;
          }
          if (state.presetRecoveredFrom) {
            banner +=
              `<div style="margin-top:8px"><strong>Preset:</strong> se recupero un formato legacy y se aplico de forma compatible.</div>` +
              `<div style="margin-top:6px"><span class="tag">recovery=${esc(String(state.presetRecoveredFrom))}</span></div>`;
          }
          if (state.presetHashWasNormalized && state.presetCanonicalHash) {
            banner +=
              `<div style="margin-top:8px"><strong>Preset:</strong> enlace normalizado a formato canonico v1.</div>` +
              `<div style="margin-top:8px"><button class="btn md3-button" type="button" data-preset-copy-canonical="1">Copiar enlace canonico</button></div>`;
          }
          if (state.prefsLoadError) {
            banner += `<div style="margin-top:8px"><strong>Aviso prefs:</strong> <span class="mono">${esc(
              String(state.prefsLoadError)
            )}</span></div>`;
          }
          if (state.presetLoadError) {
            const presetHint = presetErrorHint(state.presetLoadErrorCode);
            banner += `<div style="margin-top:8px"><strong>Aviso preset:</strong> <span class="mono">${esc(
              String(state.presetLoadError)
            )}</span>${
              presetHint ? `<div style="margin-top:6px">${esc(presetHint)}</div>` : ""
            }</div>` +
            (String(location.hash || "").toLowerCase().startsWith("#preset=")
              ? `<div style="margin-top:8px"><button class="btn md3-button" type="button" data-preset-clear-hash="1">Limpiar hash preset</button></div>`
              : "");
          }
          if (prefsDropped) {
            banner += `<div style="margin-top:8px"><strong>Aviso prefs:</strong> se descartaron <span class="mono">${esc(
              String(prefsDropped)
            )}</span> preferencias porque esos temas no existen en este snapshot.</div>`;
          }
          setBanner(banner);
        } catch (err) {
          setBanner(`<div><strong>Error al cargar datos</strong>: <span class="mono">${esc(String(err))}</span></div>`);
          qs("#statusChips").innerHTML = `<span class="chip md3-chip"><span class="dot bad"></span><span class="mono">fallo carga</span></span>`;
          qs("#concernList").innerHTML = `<div class="empty">No se pudieron cargar datos.</div>`;
          qs("#topicList").innerHTML = `<div class="empty">No se pudieron cargar datos.</div>`;
          qs("#compare").innerHTML = `<div class="empty">No se pudieron cargar datos.</div>`;
        }
      }

      function wire() {
        wireJourneyFlow();
        wireExperienceModeSwitch();
        const onConcernSearchInput = debounce(() => {
          renderConcernList();
          commitInputLatencySample("concern_search_render");
        }, SEARCH_INPUT_DEBOUNCE_MS);
        const onConcernSearchInputRaw = () => {
          markInputLatencySampleStart("concern_search_input");
          onConcernSearchInput();
        };
        const onTopicSearchInput = debounce(() => {
          renderTopicList();
          commitInputLatencySample("topic_search_render");
        }, SEARCH_INPUT_DEBOUNCE_MS);
        const onTopicSearchInputRaw = () => {
          markInputLatencySampleStart("topic_search_input");
          onTopicSearchInput();
        };

        qs("#btnClear")?.addEventListener("click", () => {
          qs("#concernSearch").value = "";
          qs("#topicSearch").value = "";
          resetConsumerProgressiveDisclosure();
          state.activeTopicId = 0;
          state.activePartyId = 0;
          writeUrlState(true);
          renderSelectedConcernTags();
          renderConcernList();
          renderTopicList();
          renderCompare();
        });

        qs("#btnResetSelected")?.addEventListener("click", () => {
          resetConsumerProgressiveDisclosure();
          const keep = String(state.activeConcernId || "").trim();
          state.selectedConcernIds = keep ? [keep] : [];
          state.viewMode = "detail";
          state.activeTopicId = 0;
          const viewSel = qs("#viewMode");
          if (viewSel) viewSel.value = "detail";
          writeUrlState(true);
          renderSelectedConcernTags();
          renderConcernList();
          renderTopicList();
          renderCompare();
        });

        qs("#btnPartyFocusClear")?.addEventListener("click", () => {
          clearPartyFocus();
        });

        qs("#viewMode")?.addEventListener("change", () => {
          resetConsumerProgressiveDisclosure();
          const v = String(qs("#viewMode")?.value || "detail");
          state.viewMode = v === "dashboard" || v === "alignment" || v === "coherence" ? v : "detail";
          writeUrlState(true);
          ensureConcernState(); // keep method toggle disable/enable consistent with view mode
          renderTopicList(); // view affects topic chips (alignment/coherence)
          renderCompare();
        });

        qs("#methodSelect")?.addEventListener("change", () => {
          const sel = qs("#methodSelect");
          if (!sel || sel.disabled) return;
          const next = String(sel.value || "").trim();
          if (!next) return;

          // Ensure method toggle isn't blocked by a custom dataset override.
          const p = new URLSearchParams(location.search || "");
          if (p.has("citizen")) {
            p.delete("citizen");
            history.replaceState({}, "", `?${p.toString()}`);
          }

          state.method = next;
          writeUrlState(true);
          // Reload so we fetch the method-specific dataset file.
          location.reload();
        });

        qs("#concernSearch")?.addEventListener("input", onConcernSearchInputRaw);

        qs("#topicSearch")?.addEventListener("input", onTopicSearchInputRaw);

        qs("#topicLimit")?.addEventListener("change", () => {
          state.consumerTopicExpanded = false;
          renderTopicList();
        });

        qs("#stanceFilter")?.addEventListener("change", () => {
          markInputLatencySampleStart("stance_filter_change");
          scheduleRenderCompare("stance_filter_change");
        });

        qs("#partySort")?.addEventListener("change", () => {
          markInputLatencySampleStart("party_sort_change");
          scheduleRenderCompare("party_sort_change");
        });

        qs("#compare")?.addEventListener("click", (ev) => {
          const btn = ev.target && ev.target.closest ? ev.target.closest("[data-consumer-show-all-parties]") : null;
          if (!btn) return;
          ev.preventDefault();
          state.consumerShowAllParties = true;
          renderCompare();
        });

        window.addEventListener("popstate", () => {
          resetConsumerProgressiveDisclosure();
          state.activeConcernPackId = "";
          state.activeConcernId = "";
          state.activeTopicId = 0;
          state.activePartyId = 0;
          state.selectedConcernIds = [];
          state.viewMode = "detail";
          state.experienceMode = "consumer";
          state.method = "";
          state.presetLoadedFrom = "";
          state.presetLoadError = "";
          state.presetLoadErrorCode = "";
          state.presetCanonicalHash = "";
          state.presetRecoveredFrom = "";
          state.presetHashWasNormalized = false;
          state.hashPresetActive = false;
          readUrlState();
          ensureConcernState();
          renderSelectedConcernTags();
          renderConcernList();
          renderTopicList();
          renderCompare();
        });
      }

      wire();
      load();
    </script>
  </body>
</html>
