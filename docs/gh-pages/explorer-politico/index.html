<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Vota Con La Chola | Explorador Pol√≠tico Territorial</title>
    <link rel="icon" href="data:," />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" />
    <style>
      :root {
        --ink: #0f172a;
        --ink-soft: #334155;
        --bg-a: #eef2ff;
        --bg-b: #e5ecff;
        --panel: rgba(255, 255, 255, 0.93);
        --panel-2: rgba(244, 248, 255, 0.92);
        --line: rgba(37, 99, 235, 0.18);
        --shadow-strong: 0 24px 55px rgba(15, 23, 42, 0.2);
        --shadow-soft: 0 14px 34px rgba(15, 23, 42, 0.09);
        --radius: 22px;
        --radius-sm: 13px;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        width: 100%;
        max-width: 100%;
        overflow-x: hidden;
        min-height: 100%;
        color: var(--ink);
        font-family: "Inter", system-ui, -apple-system, sans-serif;
        background:
          radial-gradient(1000px 520px at 10% -8%, #dbeafe 0%, transparent 60%),
          radial-gradient(900px 420px at 90% 12%, #c7d2fe 0%, transparent 58%),
          linear-gradient(130deg, var(--bg-a), var(--bg-b));
      }

      button,
      input,
      select,
      option {
        font: inherit;
        color: var(--ink);
      }

      button::placeholder,
      input::placeholder,
      textarea::placeholder {
        color: rgba(15, 23, 42, 0.46);
      }

      button,
      button * {
        color: var(--ink);
      }

      .stadium {
        min-height: 100%;
        width: min(1600px, calc(100vw - 12px));
        margin: 0 auto;
        padding: clamp(8px, 1.4vw, 16px);
        display: grid;
        gap: 12px;
      }

      .topbar {
        border: 1px solid var(--line);
        border-radius: var(--radius);
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.92), rgba(255, 255, 255, 0.8));
        box-shadow: var(--shadow-soft);
        padding: 14px 16px;
      }

      .eyebrow {
        margin: 0;
        letter-spacing: 0.15em;
        color: #1d4ed8;
        font-size: 0.72rem;
        text-transform: uppercase;
        font-weight: 700;
      }

      .title {
        margin: 6px 0;
        font-family: "Bebas Neue", sans-serif;
        font-size: clamp(1.9rem, 4vw, 3rem);
        letter-spacing: 0.04em;
      }

      .version-chip {
        margin-left: 8px;
        font-family: Inter, system-ui, -apple-system, sans-serif;
        font-size: 0.68em;
        vertical-align: middle;
        font-weight: 700;
        color: #1f3a8a;
        opacity: 0.88;
      }

      .subtitle {
        margin: 0;
        color: var(--ink-soft);
        max-width: 75ch;
      }

      .toolbar {
        margin-top: 14px;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
        gap: 10px;
      }

      .toolbar .field,
      .toolbar .toggle {
        border: 1px solid var(--line);
        border-radius: 14px;
        background: var(--panel-2);
        padding: 10px;
        min-width: 0;
        overflow: hidden;
      }

      .toolbar .field label,
      .toolbar .toggle label {
        display: block;
        margin-bottom: 6px;
        color: #334155;
        font-size: 0.74rem;
        text-transform: uppercase;
        letter-spacing: 0.07em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .toolbar input,
      .toolbar select,
      .toolbar button {
        width: 100%;
        border: 1px solid transparent;
        border-radius: 11px;
        background: rgba(255, 255, 255, 0.98);
        color: var(--ink);
        padding: 9px 10px;
      }

      .toolbar button {
        background: linear-gradient(135deg, #5e72ff, #7f5cff);
        font-weight: 700;
        cursor: pointer;
        min-width: 0;
        overflow-wrap: anywhere;
        word-break: break-word;
        text-wrap: balance;
      }

      .select2-container .select2-selection--single {
        height: 40px;
        border: 1px solid transparent !important;
        border-radius: 11px !important;
        background: rgba(255, 255, 255, 0.98) !important;
        overflow: hidden;
        max-width: 100%;
      }

      .select2-container--default .select2-selection--single {
        border-color: transparent !important;
      }

      .select2-container--default .select2-selection--single .select2-selection__rendered {
        color: var(--ink);
        line-height: 38px !important;
        padding-left: 10px !important;
        padding-right: 34px !important;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .select2-container .select2-selection__arrow {
        height: 40px;
      }

      .select2-container--default .select2-results__option--highlighted[aria-selected] {
        background-color: #5e72ff !important;
        color: #ffffff;
      }

      .select2-dropdown {
        /* Select2 sets an inline width; do not force full-viewport width. */
        max-width: calc(100vw - 24px);
        box-sizing: border-box;
      }

      .select2-container--default .select2-results > .select2-results__options {
        max-height: 320px;
      }

      .select2-container {
        width: 100% !important;
        max-width: 100%;
        min-width: 0;
        box-sizing: border-box;
      }

      .select2-container--default .select2-results__option {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .select2-dropdown,
      .select2-container--default .select2-results > .select2-results__options {
        background: var(--panel);
      }

      .toolbar .toggle-row {
        display: flex;
        gap: 9px;
        flex-wrap: wrap;
      }

      .superheader {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 8px;
        margin-bottom: 8px;
        flex-wrap: wrap;
      }

      .superlink {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border: 1px solid #d0def8;
        background: #eff6ff;
        border-radius: 999px;
        padding: 6px 10px;
        color: #102a5c;
        text-decoration: none;
        font-size: 0.82rem;
        font-weight: 700;
      }

      .superlink svg {
        width: 16px;
        height: 16px;
        fill: currentColor;
        flex: 0 0 auto;
      }

      .toggle-row button {
        flex: 1 1 120px;
        min-width: 0;
      }

      .toggle-row button {
        padding: 9px 12px;
      }

      .toggle-row button.active {
        background: linear-gradient(135deg, #f9a826, #ff7a18);
        color: #111827;
      }

      .layout {
        display: grid;
        gap: 12px;
        grid-template-columns: 300px 1fr 420px;
        align-items: stretch;
      }

      .panel {
        min-width: 0;
        min-height: 0;
        border: 1px solid var(--line);
        border-radius: var(--radius);
        padding: 11px;
        background: var(--panel);
        box-shadow: var(--shadow-soft);
        display: flex;
        flex-direction: column;
      }

      .panel h2 {
        margin: 6px 6px 10px;
        font-size: 0.94rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: var(--ink);
      }

      .league-grid {
        display: grid;
        gap: 8px;
      }

      .league {
        position: relative;
        border-radius: 16px;
        border: 1px solid rgba(15, 23, 42, 0.1);
        background: rgba(255, 255, 255, 0.92);
        padding: 11px;
        cursor: pointer;
        transition: transform 120ms ease, box-shadow 120ms ease, border-color 120ms ease;
      }

      .league:hover {
        transform: translateY(-1px);
        border-color: rgba(37, 99, 235, 0.4);
        box-shadow: 0 14px 28px rgba(15, 23, 42, 0.16);
      }

      .league.active {
        border-color: rgba(37, 99, 235, 0.45);
        box-shadow: 0 14px 34px rgba(37, 99, 235, 0.16);
      }

      .league h3 {
        margin: 0;
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        font-size: 0.92rem;
      }

      .league .small {
        margin: 3px 0 0;
        color: #475569;
        font-size: 0.76rem;
      }

      .badge-wrap {
        display: grid;
        gap: 6px;
        margin-top: 8px;
      }

      .badge-wrap .pill {
        width: fit-content;
        border-radius: 999px;
        border: 1px solid rgba(15, 23, 42, 0.12);
        padding: 3px 8px;
        font-size: 0.7rem;
        background: rgba(241, 245, 255, 0.85);
      }

      .content-scroll {
        height: min(72vh, 900px);
        max-height: 900px;
        overflow: auto;
        padding: 2px 4px 8px;
      }

      .content-scroll.team-treemap {
        height: clamp(360px, 70vh, 900px);
        min-height: 360px;
        max-height: 900px;
        overflow: hidden;
      }

      .team-list {
        display: grid;
        gap: 8px;
      }

      .team-list.treemap {
        position: relative;
        display: block;
        height: 100%;
        min-height: 360px;
        max-height: 100%;
        overflow: hidden;
        padding: 4px;
        border: 1px solid rgba(15, 23, 42, 0.08);
        border-radius: 14px;
        background: #f8fbff;
      }

      .treemap-node {
        position: absolute;
        border: 1px solid rgba(15, 23, 42, 0.18);
        border-radius: 8px;
        padding: 6px;
        overflow: hidden;
        cursor: pointer;
        transition: transform 130ms ease, box-shadow 130ms ease;
        box-sizing: border-box;
        display: grid;
        gap: 4px;
        align-content: start;
        width: auto;
        min-height: 0;
      }

      .treemap-node:hover {
        z-index: 2;
        transform: translateY(-1px);
        box-shadow: 0 8px 24px rgba(15, 23, 42, 0.2);
      }

      .treemap-node .tm-label {
        font-size: 0.74rem;
        font-weight: 700;
        line-height: 1.08;
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
      }

      .treemap-node .tm-meta {
        font-size: 0.66rem;
        line-height: 1.12;
        opacity: 0.95;
        display: grid;
        gap: 2px;
      }

      .treemap-node .tm-meta .dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 4px;
      }

      .treemap-node .tm-stat-fill {
        height: 4px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.12);
        overflow: hidden;
        margin-top: auto;
      }

      .treemap-node .tm-stat-fill > span {
        display: block;
        height: 100%;
        background: rgba(15, 23, 42, 0.35);
      }

      .team-card {
        border-radius: 16px;
        padding: 10px;
        border: 1px solid rgba(15, 23, 42, 0.12);
        background: linear-gradient(140deg, #ffffff, #f3f8ff);
        display: grid;
        gap: 8px;
        cursor: pointer;
        transition: transform 130ms ease, border-color 130ms ease, box-shadow 130ms ease;
      }

      .team-card:hover {
        transform: translateY(-1px);
        box-shadow: 0 18px 34px rgba(15, 23, 42, 0.16);
        border-color: rgba(37, 99, 235, 0.2);
      }

      .team-card.selected {
        border-color: #22c55e;
        box-shadow: 0 18px 30px rgba(34, 197, 94, 0.2);
      }

      .team-top {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        min-width: 0;
      }

      .team-id {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .shield {
        width: 30px;
        height: 30px;
        border-radius: 10px;
        display: grid;
        place-items: center;
        font-weight: 800;
      }

      .team-name {
        margin: 0;
        font-size: 0.98rem;
        word-break: break-word;
        overflow-wrap: anywhere;
      }

      .team-meta {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }

      .team-meta .tag {
        border-radius: 999px;
        border: 1px solid rgba(15, 23, 42, 0.16);
        color: #334155;
        font-size: 0.68rem;
        padding: 3px 8px;
        text-transform: uppercase;
        letter-spacing: 0.03em;
      }

      .team-stats {
        display: grid;
        gap: 6px;
      }

      .stat-strip {
        height: 8px;
        border-radius: 999px;
        background: #e5eaf5;
        overflow: hidden;
      }

      .stat-fill {
        height: 100%;
        border-radius: inherit;
        background: linear-gradient(90deg, #4cdcff, #8b66ff);
      }

      .player,
      .history-item,
      .todo {
        border-radius: 13px;
        background: rgba(248, 250, 255, 0.9);
        border: 1px solid rgba(15, 23, 42, 0.1);
      }

      .player {
        padding: 8px;
        margin-top: 7px;
        display: grid;
        gap: 7px;
        cursor: pointer;
      }

      .player-level-list {
        display: grid;
        gap: 8px;
      }

      .player-level-block {
        display: grid;
        gap: 7px;
      }

      .player-level-title {
        margin: 6px 0 0;
        font-size: 0.82rem;
        color: #0f172a;
      }

      .player-level-row {
        display: flex;
        align-items: stretch;
        flex-wrap: wrap;
        gap: 7px;
      }

      .player-level-row .player {
        margin-top: 0;
        flex: 1 1 260px;
        max-width: 320px;
        min-width: min(100%, 260px);
      }

      .player-role-title {
        margin: 4px 0 0;
        font-size: 0.78rem;
        color: #334155;
      }

      .player:hover {
        border-color: rgba(37, 99, 235, 0.26);
      }

      .player-head {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 10px;
      }

      .player h4 {
        margin: 0;
        font-size: 0.92rem;
        word-break: break-word;
        overflow-wrap: anywhere;
      }

      .player .small {
        margin: 0;
        color: #475569;
        font-size: 0.74rem;
        word-break: break-word;
        overflow-wrap: anywhere;
      }

      .pill {
        border-radius: 999px;
        border: 1px solid rgba(15, 23, 42, 0.16);
        padding: 3px 7px;
        font-size: 0.72rem;
      }

      .pill.on {
        border-color: rgba(16, 185, 129, 0.6);
        color: #065f46;
      }

      .pill.off {
        border-color: rgba(245, 158, 11, 0.6);
        color: #92400e;
      }

      .timeline {
        display: grid;
        gap: 7px;
      }

      .history-item {
        padding: 8px;
        border-left: 3px solid #0ea5e9;
      }

      .history-item .line {
        margin: 2px 0 0;
        color: #4b5563;
        font-size: 0.77rem;
      }

      .hint {
        color: #64748b;
        margin-top: 6px;
        font-size: 0.8rem;
      }

      .overlay {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.32);
        display: none;
        place-items: center;
        z-index: 30;
        padding: 14px;
      }

      .overlay.show {
        display: grid;
      }

      .modal {
        width: min(760px, 100%);
        border-radius: 18px;
        border: 1px solid rgba(15, 23, 42, 0.15);
        background: linear-gradient(170deg, #ffffff, #f3f6ff);
        box-shadow: var(--shadow-strong);
        color: var(--ink);
        padding: 13px;
        position: relative;
      }

      .close {
        position: absolute;
        top: 8px;
        right: 8px;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        border: 1px solid rgba(15, 23, 42, 0.25);
        background: transparent;
        color: #0f172a;
        cursor: pointer;
      }

      .loading {
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 16px;
        padding: 11px;
        color: #334155;
        background: rgba(243, 246, 255, 0.84);
      }

      .todo {
        padding: 9px;
        margin-top: 9px;
      }

      .todo ul {
        margin: 8px 0 0;
        padding-left: 18px;
      }

      .todo li {
        margin: 4px 0;
        font-size: 0.8rem;
      }

      .todo li.done {
        color: #15803d;
      }

      .todo li.missing {
        color: #b45309;
      }

      .score {
        display: grid;
        gap: 8px;
      }

      .leaderboard-title {
        margin: 6px 6px 0;
        color: #1d4ed8;
        font-size: 0.73rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .vote-title {
        margin: 6px 6px 0;
        color: #1d4ed8;
        font-size: 0.73rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .vote-panel {
        display: grid;
        gap: 6px;
        margin-top: 8px;
      }

      .vote-card {
        border: 1px solid rgba(15, 23, 42, 0.14);
        border-radius: 12px;
        background: rgba(238, 244, 255, 0.88);
        padding: 8px;
        display: grid;
        gap: 6px;
      }

      .vote-card-head {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        align-items: baseline;
      }

      .vote-source {
        font-size: 0.74rem;
        color: #1e293b;
      }

      .vote-source a {
        color: inherit;
      }

      .vote-date {
        font-size: 0.67rem;
        color: #64748b;
      }

      .vote-topic {
        margin: 0;
        font-size: 0.8rem;
        line-height: 1.24;
        color: #0f172a;
      }

      .vote-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .vote-meta .vote-pill {
        border-radius: 999px;
        border: 1px solid rgba(15, 23, 42, 0.16);
        padding: 3px 8px;
        font-size: 0.68rem;
        background: rgba(255, 255, 255, 0.95);
      }

      .vote-groups {
        display: grid;
        gap: 4px;
      }

      .vote-group-row {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        font-size: 0.7rem;
        color: #334155;
      }

      .vote-group-name {
        font-weight: 700;
        color: #0f172a;
      }

      .vote-party {
        border-top: 1px dashed rgba(15, 23, 42, 0.18);
        margin-top: 2px;
        padding-top: 6px;
        font-size: 0.73rem;
        color: #334155;
      }

      .municipality-leaderboard {
        display: grid;
        gap: 6px;
      }

      .municipality-leaderboard .municipality-item {
        padding: 7px 9px;
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 12px;
        background: rgba(241, 245, 255, 0.86);
        display: grid;
        gap: 6px;
      }

      .municipality-leaderboard .municipality-head {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 8px;
      }

      .municipality-leaderboard .municipality-name {
        margin: 0;
        font-size: 0.76rem;
        color: #0f172a;
      }

      .municipality-leaderboard .municipality-metrics {
        margin: 0;
        font-size: 0.7rem;
        color: #475569;
      }

      .municipality-leaderboard .municipality-ratio {
        font-weight: 700;
        color: #2563eb;
      }

      .municipality-leaderboard .municipality-bar {
        height: 6px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.12);
        overflow: hidden;
      }

      .municipality-leaderboard .municipality-fill {
        height: 100%;
        background: linear-gradient(90deg, #2563eb, #06b6d4);
      }

      .score-item {
        padding: 8px;
        border-radius: 12px;
        border: 1px solid rgba(15, 23, 42, 0.14);
        background: rgba(241, 245, 255, 0.84);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .score-item strong {
        color: #1d4ed8;
      }

      .spark {
        animation: pulse 1.4s ease-in-out infinite;
      }

      @keyframes pulse {
        0%, 100% {
          transform: scale(1);
          opacity: 1;
        }

        50% {
          transform: scale(1.01);
          opacity: 0.9;
        }
      }

      @media (max-width: 1120px) {
        .layout {
          grid-template-columns: 1fr;
        }

        .toolbar {
          grid-template-columns: 1fr;
        }

        .content-scroll,
        .content-scroll.team-treemap {
          height: auto;
          max-height: none;
        }

        .team-list.treemap {
          min-height: 300px;
          max-height: none;
          overflow: auto;
        }
      }

      @media (min-width: 1121px) and (max-width: 1500px) {
        .layout {
          grid-template-columns: 270px 1fr;
        }

        .panel:last-child {
          grid-column: 1 / -1;
        }
      }

      @media (max-width: 620px) {
        .topbar {
          padding: 12px;
        }

        .title {
          font-size: clamp(1.65rem, 7vw, 2.2rem);
        }

        .toolbar {
          gap: 8px;
        }

        .toggle-row {
          display: grid;
          grid-template-columns: 1fr;
          gap: 8px;
        }

        .toggle-row button {
          width: 100%;
        }

        .player-level-title,
        .player-role-title {
          word-break: break-word;
        }

        .team-list.treemap,
        .content-scroll.team-treemap {
          min-height: 260px;
        }

        .modal {
          width: min(95vw, 720px);
        }
      }
    </style>
  </head>
  <body>
    <div class="stadium">
      <div class="superheader">
        <a class="superlink" href="../">‚Üê √çndice</a>
        <a
          class="superlink"
          href="https://github.com/gsusI/vota-con-la-chola"
          target="_blank"
          rel="noopener noreferrer"
          aria-label="Ver el c√≥digo en GitHub"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/>
            </svg>
            Ver el c√≥digo
          </a>
      </div>
      <header class="topbar">
        <p class="eyebrow">Explorer 2.0</p>
        <h1 class="title" id="app-title">Explorador pol√≠tico territorial</h1>
        <p class="subtitle">
          Navega por niveles territoriales, contrasta siglas y revisa el historial de cada representante.
        </p>
        <div class="toolbar">
          <div class="field">
            <label for="source-filter">Fuente de datos</label>
            <select id="source-filter"></select>
          </div>
          <div class="field">
            <label for="league-filter">Nivel territorial</label>
            <select id="league-filter"></select>
          </div>
          <div class="field">
            <label for="territory-filter">Territorio</label>
            <select id="territory-filter">
              <option value="">Todos los territorios</option>
            </select>
          </div>
          <div class="field">
            <label for="search-input">Buscar partido o pol√≠tico</label>
            <input id="search-input" type="search" placeholder="Ej: PP, S√°nchez, Madrid..." />
          </div>
          <div class="field">
            <label>Modo de vista</label>
            <div class="toggle-row">
              <button id="mode-individual" class="active" data-mode="exact">Individual</button>
              <button id="mode-aggregate" data-mode="aggregate">Agregado</button>
            </div>
          </div>
          <div class="field">
            <label>Estado</label>
            <div class="toggle-row">
              <button id="mode-active" class="active" data-state="active">S√≥lo activos</button>
              <button id="mode-all" data-state="all">Activos + hist√≥ricos</button>
            </div>
          </div>
          <div class="field">
            <label for="league-reset">Reiniciar nivel</label>
            <button id="league-reset">Limpiar filtros</button>
          </div>
          <div class="field">
            <label>Acciones</label>
            <button id="refresh-button">Actualizar vista</button>
          </div>
        </div>
      </header>

      <main class="layout">
        <section class="panel">
          <h2>Estructura territorial</h2>
          <div id="league-grid" class="league-grid"></div>
          <div class="score" id="scoreboard" style="margin-top: 8px"></div>
          <h3 class="leaderboard-title">Municipios (pol√≠ticos por 100k hab.)</h3>
          <div id="municipality-leaderboard" class="municipality-leaderboard"></div>
          <h3 class="vote-title">Votaciones recientes</h3>
          <div id="votes-loading" class="loading">Cargando votaciones...</div>
          <div id="vote-panel" class="vote-panel"></div>
          <div id="todo" class="todo"></div>
        </section>

        <section class="panel">
          <h2 id="teams-title">Partidos y candidaturas</h2>
          <div id="team-panel-scroll" class="content-scroll">
            <div id="league-loading" class="loading">Cargando estructura...</div>
            <div id="team-list" class="team-list" style="display: none"></div>
            <div id="team-detail" style="display: none"></div>
          </div>
        </section>

        <section class="panel">
          <h2>Detalle de pol√≠tico</h2>
          <div class="content-scroll">
            <div class="hint">Selecciona un partido para ver sus integrantes o un pol√≠tico para abrir su historial.</div>
            <div id="detail-view" class="loading">Selecciona un nivel y un partido para empezar.</div>
          </div>
        </section>
      </main>
    </div>

    <div class="overlay" id="history-overlay" aria-hidden="true">
      <section class="modal">
        <button class="close" id="history-close" aria-label="Cerrar">√ó</button>
        <div id="history-content"></div>
      </section>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.full.min.js"></script>
    <script>
      const LEVEL_DEFINITIONS = {
        all: {
          id: "all",
          label: "Todos los niveles",
          subtitle: "Vista global",
          badge: "üåê",
        },
        nacional: {
          id: "nacional",
          label: "Nacional",
          subtitle: "Congreso/Senado",
          badge: "üõ°Ô∏è",
        },
        autonomia: {
          id: "autonomia",
          label: "Auton√≥mico",
          subtitle: "Asambleas y parlamentos auton√≥micos",
          badge: "üè¥",
        },
        provincial: {
          id: "provincial",
          label: "Provincial",
          subtitle: "Diputaciones o instituciones provinciales",
          badge: "üß≠",
        },
        municipal: {
          id: "municipal",
          label: "Municipal",
          subtitle: "Ayuntamientos y similares",
          badge: "üèüÔ∏è",
        },
        otra: {
          id: "otra",
          label: "Otra",
          subtitle: "Sin nivel reconocido",
          badge: "üß©",
        },
      };

      const LEVEL_HIERARCHY = {
        nacional: ["nacional", "autonomia", "provincial", "municipal", "otra"],
        autonomia: ["autonomia", "provincial", "municipal", "otra"],
        provincial: ["provincial", "municipal", "otra"],
        municipal: ["municipal", "otra"],
        otra: ["otra"],
        all: ["nacional", "autonomia", "provincial", "municipal", "otra"],
      };

      const LEAGUE_HIERARCHY_RANK = {
        nacional: 0,
        autonomia: 1,
        provincial: 2,
        municipal: 3,
        otra: 4,
      };

      const ROLE_HIERARCHY_RULES = [
        {
          rank: 0,
          patterns: [
            /\balcald[ae]\b/,
            /\bgobernador[a]?\b/,
            /\bministr[oa]\b/,
            /\bpresident[ea]\b/,
            /\bpresidencia\b/,
            /\bsecretari[oa] general\b/,
            /\bconseller[a]?\b/,
          ],
        },
        {
          rank: 1,
          patterns: [
            /\bvice(?:president[ea]|alcald[ae]|gobernador[a]?)\b/,
            /\bsubalcald[ea]?\b/,
            /\bteniente(?: de)? alcalde\b/,
            /\bvicecomisionad[oa]?\b/,
            /\badjunto\b/,
            /\bauxiliar\b/,
          ],
        },
        {
          rank: 2,
          patterns: [
            /\bdiputad[oa]\b/,
            /\bsenad[oa]\b/,
            /\bconsejer[oa]\b/,
            /\bsecretari[oa]\b/,
            /\bdirector(?: general)?\b/,
            /\bportavoz\b/,
            /\bvocero\b/,
            /\binterventor\b/,
            /\btesorero\b/,
            /\bgerente\b/,
            /\bjefe de gabinete\b/,
            /\bcoordinador\b/,
            /\bdelegad[oa]\b/,
          ],
        },
        {
          rank: 3,
          patterns: [
            /\bconcej(?:a|o)\b/,
            /\bconcejal√≠a\b/,
            /\bconcejalia\b/,
            /\bedil\b/,
            /\bregidor[a]?\b/,
            /\bvocal\b/,
          ],
        },
        {
          rank: 4,
          patterns: [
            /\bmiembr[oa]\b/,
            /\bintegrante\b/,
            /\basesor\b/,
            /\btecnico\b/,
            /\bagregado\b/,
            /\bfuncionario\b/,
            /\bagente\b/,
            /\basistente\b/,
            /\bcolaborador\b/,
            /\bpersonal\b/,
          ],
        },
      ];

      const TERRITORY_LEVEL_ORDER = ["nacional", "autonomia", "provincial", "municipal", "otra"];

      const app = {
        source: "all",
        league: "all",
        searchTerm: "",
        territoryFilter: "",
        debug: new URLSearchParams(window.location.search).get("debug") === "1",
        verbose: new URLSearchParams(window.location.search).get("verbose") === "1",
        includeInactive: false,
        aggregateMode: false,
        selectedPartyId: null,
        selectedPlayer: null,
        rawRows: [],
        filteredRows: [],
        sources: [],
        sourceById: {},
        hasElectionContext: true,
      };

      let mandatesLoaded = false;
      let mandatesLoadPromise = null;
      let mandatesRequestCounter = 0;
      let rawDataVersion = 0;
      let voteSummaryLoadPromise = null;
      let voteSummaryCacheKey = "";
      let voteSummaryRows = [];
      let lastTerritoryRenderVersion = -1;
      let filterCacheKey = "";
      let filterDebugKey = "";
      let isSyncingLeagueSelect = false;
      let isSyncingSourceSelect = false;
      let isSyncingTerritorySelect = false;
      let isApplyingTerritoryFilter = false;

      const isDebugEnabled = () => app.debug || new URLSearchParams(window.location.search).get("debug") === "1";
      const debugLog = (...args) => {
        if (!isDebugEnabled()) {
          return;
        }
        console.debug("[explorer-politico:debug]", ...args);
      };

      const isVerboseEnabled = () => app.verbose || app.debug || new URLSearchParams(window.location.search).get("verbose") === "1";
      const verboseLog = (...args) => {
        if (!isVerboseEnabled()) {
          return;
        }
        console.log("[explorer-politico:verbose]", ...args);
      };

      const summarizeRowForDiagnostics = (row) => ({
        full_name: row.full_name,
        party_name: row.party_name,
        role_title: row.role_title,
        level: row.teamLeague,
        source_id: row.source_id,
        is_active: row.is_active,
        territory: row.territory_display_name,
        codes: [row.mandate_territory_code, row.institution_territory_code, row.person_territory_code].join("|"),
        names: [row.mandate_territory_name, row.institution_territory_name, row.person_territory_name].join(" | "),
      });

      const EXPLORER_POLITICO_VERSION = "1.1.12";
      const APP_QUERY = new URLSearchParams(window.location.search);
      const API_BASE_OVERRIDE = (APP_QUERY.get("api") || "").trim();
      const STATIC_DATA_DIR = "data";
      const STATIC_MANDATES_PATH = `${STATIC_DATA_DIR}/arena-mandates.json`;
      const STATIC_SOURCES_PATH = `${STATIC_DATA_DIR}/sources.json`;
      const MUNICIPALITY_LEADERBOARD_LIMIT = 10;
      const VOTE_SUMMARY_LIMIT = 6;

      const isLocalApiHost = (() => {
        const host = window.location.hostname;
        return host === "localhost" || host === "127.0.0.1" || host === "::1" || host === "0.0.0.0";
      })();

      const resolveApiPath = (path) => {
        const endpoint = String(path || "").trim();
        if (!endpoint) {
          return "";
        }
        const normalized = endpoint.startsWith("/") ? endpoint : `/${endpoint}`;
        if (API_BASE_OVERRIDE) {
          return `${API_BASE_OVERRIDE.replace(/\/$/, "")}${normalized}`;
        }
        if (isLocalApiHost) {
          return normalized;
        }
        return "";
      };

      const staticPayloadCache = {
        mandates: null,
        sources: null,
      };

      const readJson = async (url) => {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        return response.json();
      };

      const getStaticPayload = async (cacheKey, path) => {
        if (staticPayloadCache[cacheKey] !== null) {
          return staticPayloadCache[cacheKey];
        }
        const payload = await readJson(path);
        staticPayloadCache[cacheKey] = payload || {};
        return staticPayloadCache[cacheKey];
      };

      const fetchPayload = async ({apiPath, staticPath, staticCacheKey}) => {
        const apiPathResolved = resolveApiPath(apiPath);
        if (apiPathResolved) {
          try {
            return await readJson(apiPathResolved);
          } catch (error) {
            if (!staticPath) {
              throw error;
            }
            if (isVerboseEnabled()) {
              verboseLog("fetch api fallido, usando est√°tico", {
                apiPath,
                apiPathResolved,
                staticPath,
                error: error?.message || String(error),
              });
            }
          }
        }
        if (!staticPath) {
          throw new Error(`Sin API disponible para ${apiPath}`);
        }
        return getStaticPayload(staticCacheKey, staticPath);
      };

      const refs = {
        sourceFilter: document.getElementById("source-filter"),
        leagueSelect: document.getElementById("league-filter"),
        territoryFilter: document.getElementById("territory-filter"),
        appTitle: document.getElementById("app-title"),
        searchInput: document.getElementById("search-input"),
        leagueGrid: document.getElementById("league-grid"),
        scoreboard: document.getElementById("scoreboard"),
        municipalityLeaderboard: document.getElementById("municipality-leaderboard"),
        votesLoading: document.getElementById("votes-loading"),
        votePanel: document.getElementById("vote-panel"),
        todo: document.getElementById("todo"),
        leagueLoading: document.getElementById("league-loading"),
        teamPanelScroll: document.getElementById("team-panel-scroll"),
        teamList: document.getElementById("team-list"),
        teamDetail: document.getElementById("team-detail"),
        detailView: document.getElementById("detail-view"),
        teamsTitle: document.getElementById("teams-title"),
        modeExact: document.getElementById("mode-individual"),
        modeAggregate: document.getElementById("mode-aggregate"),
        modeActive: document.getElementById("mode-active"),
        modeAll: document.getElementById("mode-all"),
        leagueReset: document.getElementById("league-reset"),
        refreshButton: document.getElementById("refresh-button"),
        historyOverlay: document.getElementById("history-overlay"),
        historyContent: document.getElementById("history-content"),
        historyClose: document.getElementById("history-close"),
      };

      const safeText = (value) => {
        if (value === null || value === undefined) {
          return "";
        }
        return String(value);
      };

      const safeNumber = (value, fallback = 0) => {
        const n = Number(value);
        return Number.isFinite(n) ? n : fallback;
      };

      const normalize = (value) =>
        safeText(value)
          .toLowerCase()
          .normalize("NFKD")
          .replace(/[\u0300-\u036f]/g, "")
          .replace(/[^a-z0-9]+/g, " ")
          .trim();

      const personDisplayName = (person = {}) => {
        const fullName = safeText(person.full_name).trim();
        const givenName = safeText(person.given_name).trim();
        const familyName = safeText(person.family_name).trim();
        const combined = [givenName, familyName].filter(Boolean).join(" ").trim();
        const hasMultipleTokens = fullName.split(/\s+/).filter(Boolean).length > 1;

        if (fullName && (hasMultipleTokens || !combined)) {
          return fullName;
        }
        if (combined) {
          return combined;
        }
        return fullName || "Sin nombre";
      };

      const sourceInfoById = (sourceId = "") => {
        const key = safeText(sourceId).trim();
        return key ? app.sourceById[key] || null : null;
      };

      const sourceUrl = (sourceId = "") => {
        const source = sourceInfoById(sourceId);
        const url = safeText(source?.default_url || source?.url || source?.source_url);
        if (/^https?:\/\//i.test(url)) {
          return url;
        }
        return "";
      };

      const sourceName = (sourceId = "") => {
        const source = sourceInfoById(sourceId);
        const label = safeText(source?.name || sourceId);
        return label || "Sin fuente";
      };

      const sourceLink = (sourceId = "") => {
        const name = sourceName(sourceId);
        const url = sourceUrl(sourceId);
        const escapedName = name || "Sin fuente";
        if (!url) {
          return `<span>${escapedName}</span>`;
        }
        return `<a href="${url}" target="_blank" rel="noopener noreferrer">${escapedName}</a>`;
      };

      const normalizeTerritoryLevel = (value = "") => {
        const n = normalize(value);
        if (!n) {
          return "";
        }
        if (/(nacion|estatal|congreso|senado|diputados?|parlamento general)/.test(n)) {
          return "nacional";
        }
        if (/(autonom|ccaa|comunidad|catalunya|vasco|andaluc|arag|balear|cantabr|galici|canari|castill|extremadura|murci|valenc|madrid|aragon|melill|ceuta|foral|catalunya|canarias)/.test(n)) {
          return "autonomia";
        }
        if (/(provinc|diputaci|cabild|provincia|foral)/.test(n)) {
          return "provincial";
        }
        if (/(municip|ayunt|concejal|local|diputat|cort municipal|comune|alcald|ayuntamiento)/.test(n)) {
          return "municipal";
        }
        return "";
      };

      const isNumericOrCodeLike = (value = "") => {
        const n = safeText(value).trim().toLowerCase();
        if (!n) {
          return false;
        }
        if (/^([0-9]{2,}|es|e.?c\.?)$/.test(n)) {
          return true;
        }
        // ISO-ish territory codes (e.g. ES-GA, ES-C, ES-08). Treat as code, not a human label.
        return /^[a-z]{2}[-_\s][a-z0-9]{1,3}$/.test(n);
      };

      const normalizeTerritoryCodeToken = (value = "") => {
        const token = safeText(value).trim().toLowerCase().normalize("NFKD").replace(/[\u0300-\u036f]/g, "");
        if (!token) {
          return "";
        }
        return token.replace(/[^a-z0-9]+/g, "");
      };

      const cleanMunicipalityName = (value = "") => {
        let text = safeText(value).trim();
        if (!text) {
          return "";
        }

        const withPrefix = text
          .replace(/^(ayuntamiento|ayuntamiento de|ayuntamiento municipal|alcald√≠a|alcaldia|concejal√≠a|concejalia|concejo|concello|caba?mbo|cabildo|diputaci√≥n|diputacion|parlamento|senado|congreso)\s+(?:de|del|de la|de los)\s*/i, "")
          .replace(/^\s*(municipalidad|municipio)\s+(?:de|del|de la|de los)\s*/i, "")
          .trim();

        if (withPrefix && withPrefix !== text) {
          return withPrefix;
        }

        return "";
      };

      const updateUiVersion = () => {
        const versionLabel = `v${EXPLORER_POLITICO_VERSION}`;
        if (refs.appTitle) {
          refs.appTitle.innerHTML = `Explorador pol√≠tico territorial <span class="version-chip">${versionLabel}</span>`;
        }
        document.title = `Vota Con La Chola | Explorador Pol√≠tico Territorial ${versionLabel}`;
      };

      const normalizeTerritoryToken = (value = "") => {
        const token = normalize(value);
        if (!token) {
          return "";
        }
        if (token === "sin_nombre" || token === "sin_codigo") {
          return "";
        }
        return token;
      };

      const normalizeNumericToken = (value = "") => {
        const token = normalizeTerritoryToken(value);
        if (!token) {
          return "";
        }
        const asNumeric = token.replace(/[^a-z0-9]/g, "");
        if (!asNumeric) {
          return token;
        }
        if (/^\d+$/.test(asNumeric)) {
          return asNumeric.replace(/^0+/, "") || "0";
        }
        return token;
      };

      const parseTerritoryFilter = (value = "") => {
        const [rawLevel = "", rawName = "", rawCode = ""] = safeText(value).split("||");
        const parsedLevel = normalizeTerritoryLevel(rawLevel);
        const parsedName = normalizeTerritoryToken(rawName);
        const normalizedCodeFromValue = normalizeTerritoryCodeToken(rawCode);
        const parsedCode = normalizeTerritoryToken(rawCode) || (normalizedCodeFromValue && isNumericOrCodeLike(normalizedCodeFromValue) ? normalizedCodeFromValue : "");

        if (parsedName || parsedCode) {
          return {
            level: parsedLevel || normalizeTerritoryLevel(parsedName) || "",
            name: parsedName,
            code: parsedCode,
          };
        }

        const fallback = normalizeTerritoryToken(rawLevel);
        const compactLevel = normalizeTerritoryCodeToken(rawLevel);
        if (fallback) {
          if (isNumericOrCodeLike(rawLevel)) {
            return {
              level: parsedLevel || "",
              name: "",
              code: fallback,
            };
          }

          if (compactLevel && isNumericOrCodeLike(compactLevel)) {
            return {
              level: parsedLevel || "",
              name: "",
              code: compactLevel,
            };
          }

          if (!parsedLevel) {
            return {
              level: "",
              name: fallback,
              code: "",
            };
          }
        }

        return {
          level: "",
          name: "",
          code: "",
        };
      };

      const territoryMatchesToken = (rowValue, token) => {
        if (!token) {
          return false;
        }
        const normalized = normalize(rowValue);
        if (!normalized) {
          return false;
        }
        const normalizedToken = normalizeTerritoryToken(token);
        if (!normalizedToken) {
          return false;
        }
        if (normalized === normalizedToken || normalized.includes(normalizedToken) || normalizedToken.includes(normalized)) {
          return true;
        }
        const normalizedNumeric = normalizeNumericToken(normalized);
        const tokenNumeric = normalizeNumericToken(normalizedToken);
        if (normalizedNumeric && tokenNumeric) {
          return normalizedNumeric === tokenNumeric || normalizedNumeric.includes(tokenNumeric) || tokenNumeric.includes(normalizedNumeric);
        }
        return false;
      };

      const rowMatchesTerritoryFilter = (row, filter) => {
        const { level, name, code } = filter;
        if (!level && !name && !code) {
          return true;
        }

        const hasCodeFilter = Boolean(code);
        const hasNameFilter = Boolean(name);
        const rowLevel = normalizeTerritoryLevel(row.teamLeague);
        const levelMatch = !level || level === "otra" || rowLevel === level || normalizeTerritoryLevel(row.mandate_territory_level) === level || normalizeTerritoryLevel(row.institution_territory_level) === level || normalizeTerritoryLevel(row.person_territory_level) === level;

        const matchedName = name
          ? territoryMatchesToken(row.territory_display_name, name) ||
            territoryMatchesToken(row.mandate_territory_name, name) ||
            territoryMatchesToken(row.institution_territory_name, name) ||
            territoryMatchesToken(row.person_territory_name, name) ||
            territoryMatchesToken(cleanMunicipalityName(row.institution_name), name)
          : true;

        const matchedCode = code
          ? territoryMatchesToken(row.mandate_territory_code, code) ||
            territoryMatchesToken(row.institution_territory_code, code) ||
            territoryMatchesToken(row.person_territory_code, code)
          : true;

        if (hasCodeFilter && hasNameFilter) {
          if (isNumericOrCodeLike(code)) {
            return matchedCode;
          }
          return levelMatch && (matchedName || matchedCode);
        }

        if (hasCodeFilter) {
          return matchedCode;
        }

        if (hasNameFilter) {
          return matchedName && levelMatch;
        }

        return levelMatch;
      };

      const deduceTerritoryName = (row) => {
        const candidates = [
          row.mandate_territory_name,
          row.institution_territory_name,
          row.person_territory_name,
          row.mandate_territory_code,
          row.institution_territory_code,
          row.person_territory_code,
        ];

        for (const candidate of candidates) {
          const text = safeText(candidate).trim();
          if (!text) {
            continue;
          }
          if (!isNumericOrCodeLike(text)) {
            return text;
          }
        }

        const fromInstitution = cleanMunicipalityName(row.institution_name);
        if (fromInstitution) {
          return fromInstitution;
        }
        return candidates[0] || "Sin territorio";
      };

      const isMunicipalLevelText = (value = "") => {
        const normalized = normalize(value);
        return (
          /\bmunicipal\b/.test(normalized) ||
          /\bayunt/.test(normalized) ||
          /\bconcejal/.test(normalized) ||
          /\blocal\b/.test(normalized)
        );
      };

      const cleanMunicipalityCode = (value = "") => {
        const digits = safeText(value).replace(/\D+/g, "");
        return digits.length === 5 ? digits : "";
      };

      const getMunicipalityFromRow = (row) => {
        const explicitCode = cleanMunicipalityCode(row.municipality_code);
        if (explicitCode) {
          return {
            code: explicitCode,
            name: safeText(row.municipality_name).trim() || safeText(row.institution_territory_name) || "Sin municipio",
            population: safeNumber(row.municipality_population, null),
          };
        }

        const candidates = [
          {
            code: row.mandate_territory_code,
            name: row.mandate_territory_name,
            level: row.mandate_territory_level,
          },
          {
            code: row.institution_territory_code,
            name: row.institution_territory_name,
            level: row.institution_territory_level,
          },
          {
            code: row.person_territory_code,
            name: row.person_territory_name,
            level: row.person_territory_level,
          },
        ];

        const municipalCandidate = candidates.find(
          (candidate) => isMunicipalLevelText(candidate.level) && cleanMunicipalityCode(candidate.code)
        );
        if (municipalCandidate) {
          const code = cleanMunicipalityCode(municipalCandidate.code);
          return {
            code,
            name: safeText(municipalCandidate.name).trim() || safeText(municipalCandidate.code) || "Sin municipio",
            population: safeNumber(row.municipality_population, null),
          };
        }

        for (const candidate of candidates) {
          const code = cleanMunicipalityCode(candidate.code);
          if (!code) {
            continue;
          }
          return {
            code,
            name: safeText(candidate.name).trim() || safeText(candidate.code) || "Sin municipio",
            population: safeNumber(row.municipality_population, null),
          };
        }

        return null;
      };

      const slugTeam = (row) => {
        if (row.party_id == null) {
          return "__sin_partido__";
        }
        return String(row.party_id);
      };

      const leagueFromText = (value = "") => normalizeTerritoryLevel(value) || "otra";

      const rowLeague = (mandate) => {
        return (
          normalizeTerritoryLevel(mandate.mandate_territory_level) ||
          normalizeTerritoryLevel(mandate.institution_territory_level) ||
          normalizeTerritoryLevel(mandate.person_territory_level) ||
          leagueFromText(safeText(mandate.level) || safeText(mandate.institution_level))
        );
      };

      const leagueRank = (value = "") => LEAGUE_HIERARCHY_RANK[value] ?? LEAGUE_HIERARCHY_RANK.otra;

      const normalizeDate = (value) => {
        if (!value) {
          return "";
        }
        const asDate = new Date(value);
        if (Number.isNaN(asDate.getTime())) {
          return safeText(value);
        }
        return asDate.toLocaleDateString("es-ES", {
          year: "numeric",
          month: "short",
          day: "2-digit",
        });
      };

      const PARTY_PALETTE = [
        "#ff8a5b",
        "#8ad4ff",
        "#9d7bff",
        "#6cf3ab",
        "#ffc857",
        "#5ce1e6",
        "#ff5f9e",
        "#7dc4ff",
        "#b6f25a",
        "#ffa36a",
        "#7ff0c2",
        "#c98bff",
        "#5fd1ff",
        "#ff7fbd",
        "#8df9a2",
      ];

      const PARTY_IDENTITY_COLORS = {
        "psoe": "#e30613",
        "socialistas": "#e30613",
        "partido socialista": "#e30613",
        "partido socialista obrero espa√±ol": "#e30613",
        "socialdemocrata": "#e30613",
        "pp": "#0058a6",
        "partido popular": "#0058a6",
        "populares": "#0058a6",
        "vox": "#3a8f5f",
        "unidas podemos": "#752f7c",
        "unida podemos": "#752f7c",
        "podemos": "#612d8f",
        "unidad podia": "#612d8f",
        "sumar": "#5f2d83",
        "ciudadanos": "#ffcb05",
        "cs": "#ffcb05",
        "erc": "#f6b20d",
        "esquerra republicana": "#f6b20d",
        "esquerra republicana de catalunya": "#f6b20d",
        "junts per": "#2f6db0",
        "junts": "#2f6db0",
        "junts per catalunya": "#2f6db0",
        "pnc": "#ff6f00",
        "pnv": "#009a44",
        "eaj": "#009a44",
        "eaj pnv": "#009a44",
        "bildu": "#5db14a",
        "eh bildu": "#5db14a",
        "bng": "#ffd230",
        "bloque nacionalista galego": "#ffd230",
        "cc": "#f7a01e",
        "coalicion canaria": "#f7a01e",
        "otros": "#64748b",
      };

      const PARTY_IDENTITY_PATTERNS = [
        [/grupo parlamentario socialista/, "#e30613"],
        [/grupo socialista/, "#e30613"],
        [/grupo popular|grupo del popular/, "#0058a6"],
        [/grupo nacionalista vasco|gv pnv|grupo eaj|grupo eaj pnv/, "#009a44"],
        [/grupo republicano|grup republic/, "#f6b20d"],
        [/grupo de bildu|eh bildu|grupo bildu/, "#5db14a"],
        [/grupo de junts|grup junts|junts per catalunya/, "#2f6db0"],
        [/grupo de vox|grupo vox/, "#3a8f5f"],
        [/grupo de unidos podemos|grupo de pod|grupo de suma/, "#752f7c"],
        [/grupo de ciudadanos|grupo ciudadanos|ciudadanos/, "#ffcb05"],
        [/grupo de psoe|grupo del psoe/, "#e30613"],
        [/grupo de bng|bloque nacionalista galego/, "#ffd230"],
      ];

      const initSelect2 = () => {
        if (!window.jQuery || !window.jQuery.fn || !window.jQuery.fn.select2) {
          return false;
        }

        window.jQuery(refs.sourceFilter).select2({
          width: "100%",
          minimumResultsForSearch: 6,
          placeholder: "Selecciona una fuente",
          allowClear: false,
        });

        window.jQuery(refs.leagueSelect).select2({
          width: "100%",
          minimumResultsForSearch: 5,
          placeholder: "Selecciona un nivel",
          allowClear: false,
        });

        return true;
      };

      const initTerritorySelect2 = () => {
        if (!window.jQuery || !window.jQuery.fn || !window.jQuery.fn.select2 || !refs.territoryFilter) {
          return false;
        }

        const $territory = window.jQuery(refs.territoryFilter);
        if (!$territory.length) {
          return false;
        }
        if ($territory.data("select2")) {
          $territory.select2("destroy");
        }

        $territory.select2({
          width: "100%",
          minimumResultsForSearch: 0,
          placeholder: "Buscar municipio, provincia o autonom√≠a",
          matcher: (params, data) => {
            if (!params.term) {
              return data;
            }

            const term = normalize(params.term);
            if (!term) {
              return data;
            }

            const text = normalize(data?.text || "");
            const value = normalize(String(data?.id || ""));
            return text.includes(term) || value.includes(term) ? data : null;
          },
          allowClear: false,
        });

        if (isVerboseEnabled()) {
          verboseLog("select2 territorio inicializado", {
            options: $territory.find("option").length,
            value: refs.territoryFilter.value,
          });
        }

        $territory.off(".explorerTerritory");
        $territory.on("change.explorerTerritory select2:select.explorerTerritory select2:unselect.explorerTerritory", onTerritoryFilterChange);

        return true;
      };

      const syncLeagueSelectValue = () => {
        if (!refs.leagueSelect) {
          return;
        }

        refs.leagueSelect.value = app.league;
        if (!window.jQuery || !window.jQuery.fn || !window.jQuery.fn.select2) {
          return;
        }
        if (!window.jQuery(refs.leagueSelect).data("select2")) {
          return;
        }
        isSyncingLeagueSelect = true;
        window.jQuery(refs.leagueSelect).trigger("change.select2");
        isSyncingLeagueSelect = false;
      };

      const territoryOptionKey = (name, code, level) => {
        const keyName = normalize(name);
        const keyCode = normalize(code);
        return `${level || "otra"}||${keyName || "sin_nombre"}||${keyCode || "sin_codigo"}`;
      };

      const syncTerritorySelectValue = () => {
        if (!refs.territoryFilter) {
          return;
        }

        if (isVerboseEnabled()) {
          verboseLog("sincronizando select territorio desde estado", {
            value: app.territoryFilter,
            previous: refs.territoryFilter.value,
          });
        }
        refs.territoryFilter.value = app.territoryFilter || "";
        if (!window.jQuery || !window.jQuery.fn || !window.jQuery.fn.select2) {
          return;
        }
        if (!window.jQuery(refs.territoryFilter).data("select2")) {
          return;
        }
        isSyncingTerritorySelect = true;
        window.jQuery(refs.territoryFilter).trigger("change.select2");
        isSyncingTerritorySelect = false;
      };

      const syncSourceSelectValue = () => {
        if (!refs.sourceFilter) {
          return;
        }

        refs.sourceFilter.value = app.source;
        if (!window.jQuery || !window.jQuery.fn || !window.jQuery.fn.select2) {
          return;
        }
        if (!window.jQuery(refs.sourceFilter).data("select2")) {
          return;
        }
        isSyncingSourceSelect = true;
        window.jQuery(refs.sourceFilter).trigger("change.select2");
        isSyncingSourceSelect = false;
      };

      const PARTY_COLOR_CACHE = new Map();
      const PARTY_TEXT_COLOR_CACHE = new Map();

      const partyTextColor = (partyId = "", fallback = "") => {
        const key = normalize(`${partyId}`) || normalize(fallback) || "sin_partido";
        if (PARTY_TEXT_COLOR_CACHE.has(key)) {
          return PARTY_TEXT_COLOR_CACHE.get(key);
        }

        const color = partyColor(partyId, fallback);
        const hex = color.replace("#", "");
        const r = Number.parseInt(hex.slice(0, 2), 16) / 255;
        const g = Number.parseInt(hex.slice(2, 4), 16) / 255;
        const b = Number.parseInt(hex.slice(4, 6), 16) / 255;
        const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        const textColor = luminance < 0.6 ? "#f8fbff" : "#111827";
        PARTY_TEXT_COLOR_CACHE.set(key, textColor);
        return textColor;
      };

      const partyColor = (partyId = "", fallback = "") => {
        const safeKey = normalize(`${partyId}`) || normalize(fallback) || "sin_partido";
        if (safeKey === "sin_partido") {
          return "#4b5563";
        }

        const label = normalize(fallback);

        if (PARTY_IDENTITY_COLORS[safeKey]) {
          return PARTY_IDENTITY_COLORS[safeKey];
        }

        for (const [alias, color] of Object.entries(PARTY_IDENTITY_COLORS)) {
          if (safeKey === alias || safeKey.includes(alias)) {
            return color;
          }
          if (label && (label === alias || label.includes(alias))) {
            return color;
          }
        }

        for (const [pattern, color] of PARTY_IDENTITY_PATTERNS) {
          if (pattern.test(safeKey) || (label && pattern.test(label))) {
            return color;
          }
        }

        if (PARTY_COLOR_CACHE.has(safeKey)) {
          return PARTY_COLOR_CACHE.get(safeKey);
        }

        const seed = Math.abs(safeKey.split("").reduce((acc, ch, i) => {
          const code = ch.charCodeAt(i) || 0;
          return (acc * 31 + code + i) % PARTY_PALETTE.length;
        }, 17));
        const color = PARTY_PALETTE[seed % PARTY_PALETTE.length];
        PARTY_COLOR_CACHE.set(safeKey, color);
        return color;
      };

      const setModeButton = (active) => {
        refs.modeExact.classList.toggle("active", !active);
        refs.modeAggregate.classList.toggle("active", active);
        app.aggregateMode = active;
      };

      const setStateButton = (activeOnly) => {
        refs.modeActive.classList.toggle("active", activeOnly);
        refs.modeAll.classList.toggle("active", !activeOnly);
        app.includeInactive = !activeOnly;
      };

      const syncStateToUrl = () => {
        const p = new URLSearchParams(window.location.search);
        if (isVerboseEnabled()) {
          verboseLog("syncStateToUrl", {
            before: Object.fromEntries(p.entries()),
            after: {
              league: app.league,
              source: app.source,
              search: app.searchTerm,
              territory: app.territoryFilter,
              agg: app.aggregateMode ? "1" : "0",
              inc: app.includeInactive ? "1" : "0",
              debug: app.debug ? "1" : "0",
              verbose: app.verbose ? "1" : "0",
            },
          });
        }
        p.set("league", app.league);
        p.set("source", app.source);
        p.set("search", app.searchTerm);
        p.set("territory", app.territoryFilter);
        p.set("agg", app.aggregateMode ? "1" : "0");
        p.set("inc", app.includeInactive ? "1" : "0");
        if (app.debug) {
          p.set("debug", "1");
        } else {
          p.delete("debug");
        }
        if (app.verbose) {
          p.set("verbose", "1");
          window.localStorage.setItem("explorerSportsVerbose", "1");
        } else {
          p.delete("verbose");
          window.localStorage.removeItem("explorerSportsVerbose");
        }
        if (app.selectedPartyId) {
          p.set("team", app.selectedPartyId);
        } else {
          p.delete("team");
        }
        window.history.replaceState({}, "", `${window.location.pathname}?${p.toString()}`);
      };

      const hydrateRows = (rows) => {
        const base = rows.map((r) => ({
          mandate_id: r.mandate_id,
          source_id: safeText(r.source_id),
          person_id: safeText(r.person_id),
          full_name: safeText(r.full_name),
          given_name: safeText(r.given_name),
          family_name: safeText(r.family_name),
          role_title: safeText(r.role_title),
          level: safeText(r.level),
          mandate_territory_code: safeText(r.mandate_territory_code),
          mandate_territory_name: safeText(r.mandate_territory_name),
          mandate_territory_level: safeText(r.mandate_territory_level),
          person_territory_code: safeText(r.person_territory_code),
          person_territory_name: safeText(r.person_territory_name),
          person_territory_level: safeText(r.person_territory_level),
          institution_id: safeText(r.institution_id),
          institution_name: safeText(r.institution_name),
          institution_level: safeText(r.institution_level),
          institution_territory_code: safeText(r.institution_territory_code),
          institution_territory_name: safeText(r.institution_territory_name),
          institution_territory_level: safeText(r.institution_territory_level),
          party_id: r.party_id == null ? null : String(r.party_id),
          party_name: safeText(r.party_name) || "Sin partido",
          party_acronym: safeText(r.party_acronym),
          municipality_code: safeText(r.municipality_code),
          municipality_name: safeText(r.municipality_name),
          municipality_population: r.municipality_population,
          is_active: Number(r.is_active) === 1,
          start_date: safeText(r.start_date),
          end_date: safeText(r.end_date),
        }));

        return base.map((row) => {
          const municipalityName = safeText(row.municipality_name).trim();
          const municipalityCode = safeText(row.municipality_code).trim();
          const municipalityPopulation = safeNumber(row.municipality_population, null);

          const hydrated = {
            ...row,
            municipality_code: municipalityCode,
            municipality_name: municipalityName || safeText(row.institution_territory_name),
            municipality_population: municipalityPopulation,
            teamLeague: rowLeague(row),
          };
          hydrated.territory_display_name = deduceTerritoryName(hydrated);
          return hydrated;
        });
      };

      const expandMandatePayloadRows = (payload = {}) => {
        const columns = Array.isArray(payload?.columns) ? payload.columns : null;
        const rows = Array.isArray(payload?.rows) ? payload.rows : [];
        if (!columns || columns.length === 0) {
          return rows;
        }
        if (rows.length === 0) {
          return rows;
        }
        if (!Array.isArray(rows[0])) {
          return rows;
        }
        const expanded = [];
        for (const row of rows) {
          const obj = {};
          for (let i = 0; i < columns.length; i += 1) {
            obj[String(columns[i])] = row[i];
          }
          expanded.push(obj);
        }
        return expanded;
      };

      const fetchSources = async () => {
        const payload = await fetchPayload({
          apiPath: "/api/graph?limit=1&include_inactive=1",
          staticPath: STATIC_SOURCES_PATH,
          staticCacheKey: "sources",
        });
        const sources = payload?.meta?.sources || payload?.sources || [];
        app.sources = Array.isArray(sources) ? sources : [];
        app.sourceById = {};
        for (const source of app.sources) {
          const key = safeText(source?.source_id);
          if (key) {
            app.sourceById[key] = source;
          }
        }
      };

      const resolveVoteChoiceLabel = (choice = "") => {
        const normalized = normalize(choice);
        if (normalized === "yes") {
          return "S√≠";
        }
        if (normalized === "no") {
          return "No";
        }
        if (normalized === "abstain") {
          return "Abstenci√≥n";
        }
        if (normalized === "no_vote") {
          return "No vota";
        }
        return safeText(choice) || "Sin voto";
      };

      const escapeHtml = (value) => {
        return safeText(value)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      };

      const renderVoteGroup = (group = {}) => {
        const yes = safeNumber(group.yes || 0, 0);
        const no = safeNumber(group.no || 0, 0);
        const abstain = safeNumber(group.abstain || 0, 0);
        const noVote = safeNumber(group.no_vote || 0, 0);
        const other = safeNumber(group.other || 0, 0);
        const total = yes + no + abstain + noVote + other;
        const groupName = escapeHtml(safeText(group.group_code || "Sin grupo"));
        return `
          <div class="vote-group-row">
            <span class="vote-group-name">${groupName}</span>
            <span>${total} votos</span>
          </div>
          <div class="vote-meta">
            <span class="vote-pill">${resolveVoteChoiceLabel("yes")}: ${yes}</span>
            <span class="vote-pill">${resolveVoteChoiceLabel("no")}: ${no}</span>
            <span class="vote-pill">${resolveVoteChoiceLabel("abstain")}: ${abstain}</span>
            <span class="vote-pill">${resolveVoteChoiceLabel("no_vote")}: ${noVote}</span>
            ${other > 0 ? `<span class="vote-pill">${resolveVoteChoiceLabel("other")}: ${other}</span>` : ""}
          </div>
        `;
      };

      const renderVoteTotals = (totals = {}) => {
        const yes = safeNumber(totals.yes || 0, 0);
        const no = safeNumber(totals.no || 0, 0);
        const abstain = safeNumber(totals.abstain || 0, 0);
        const noVote = safeNumber(totals.no_vote || 0, 0);
        return `
          <div class="vote-meta">
            <span class="vote-pill">${resolveVoteChoiceLabel("yes")}: ${yes}</span>
            <span class="vote-pill">${resolveVoteChoiceLabel("no")}: ${no}</span>
            <span class="vote-pill">${resolveVoteChoiceLabel("abstain")}: ${abstain}</span>
            <span class="vote-pill">${resolveVoteChoiceLabel("no_vote")}: ${noVote}</span>
          </div>
        `;
      };

      const renderVotesPanel = async () => {
        if (!refs.votePanel || !refs.votesLoading) {
          return;
        }

        const selectedPartyName = (() => {
          if (!app.selectedPartyId) {
            return "Todos los partidos";
          }
          if (app.selectedPartyId === "__sin_partido__") {
            return "Sin partido";
          }
          if (app.selectedPartyId === "__otros__") {
            return "Otros";
          }
          return app.selectedPartyId;
          })();

        refs.votesLoading.style.display = "block";
        refs.votePanel.style.display = "none";

        try {
          if (isVerboseEnabled()) {
            verboseLog("renderVotesPanel:inicio", {
              source: app.source,
              party: app.selectedPartyId || "all",
              search: app.searchTerm || "",
              includeInactive: app.includeInactive,
            });
          }
          const rows = await fetchVoteSummary();
          const html = rows
            .slice(0, VOTE_SUMMARY_LIMIT)
            .map((row) => {
              const sourceId = safeText(row.source_id);
              const sourceLabel = sourceId ? sourceLink(sourceId) : escapeHtml(safeText(row.source_name || "Sin fuente"));
              const subgroup = safeText(row.subgroup_title || row.subgroup_text);
              const subject = escapeHtml(safeText(row.title) || safeText(row.expediente_text) || "Votaci√≥n sin t√≠tulo");
              const rowsMeta = row.group_breakdown || [];
              const hasPartyParticipation = Boolean(row.party_participation && row.party_participation.total > 0);
              const rowsDate = normalizeDate(safeText(row.vote_date) || safeText(row.created_at));
              return `
                <article class="vote-card">
                  <div class="vote-card-head">
                    <h4 style="margin:0; font-size:0.83rem">${subject}</h4>
                    <span class="vote-date">${rowsDate || "Sin fecha"}</span>
                  </div>
                  <p class="vote-source">Fuente: ${sourceLabel}</p>
                  ${subgroup ? `<p class="small">${escapeHtml(subgroup)}</p>` : ""}
                  ${renderVoteTotals(row.totals || {})}
                  ${rowsMeta.length ? `<div class="vote-groups">${rowsMeta.slice(0, 4).map(renderVoteGroup).join("")}</div>` : ""}
                  ${
                    hasPartyParticipation
                      ? `<p class="vote-party">${resolveVoteChoiceLabel("yes")}: ${row.party_participation.yes}, ${resolveVoteChoiceLabel("no")}: ${row.party_participation.no}, ${resolveVoteChoiceLabel("abstain")}: ${row.party_participation.abstain}, ${resolveVoteChoiceLabel("no_vote")}: ${row.party_participation.no_vote} (${selectedPartyName})</p>`
                      : ""
                  }
                </article>
              `;
            })
            .join("");

          refs.votesLoading.style.display = "none";
          refs.votePanel.style.display = "block";
          if (!html) {
            refs.votePanel.innerHTML = "<p class='hint'>No hay votaciones recientes para esta vista.</p>";
            return;
          }

          refs.votePanel.innerHTML = html;
          if (isVerboseEnabled()) {
            verboseLog("renderVotesPanel:fin", {
              renderedRows: rows.length,
              limit: VOTE_SUMMARY_LIMIT,
              partyFilter: app.selectedPartyId || "all",
            });
          }
          if (isDebugEnabled()) {
            debugLog("votaciones renderizadas", {
              rows: rows.length,
              selectedParty: app.selectedPartyId || "",
              search: app.searchTerm || "",
            });
          }
        } catch (error) {
          refs.votesLoading.style.display = "none";
          refs.votePanel.style.display = "block";
          refs.votePanel.innerHTML = `<p class="loading">Error cargando votaciones: ${escapeHtml(error?.message || String(error))}</p>`;
          if (isVerboseEnabled()) {
            verboseLog("renderVotesPanel:error", {
              message: error?.message || String(error),
              source: app.source,
              party: app.selectedPartyId || "all",
            });
          }
        }
      };

      const fetchVoteSummary = async ({ force = false } = {}) => {
        const requestedParty = app.selectedPartyId || "";
        const requestedSource = app.source === "all" ? "" : app.source;
        const cacheKey = JSON.stringify({
          source: requestedSource,
          party: requestedParty,
          search: safeText(app.searchTerm).trim().toLowerCase(),
          limit: VOTE_SUMMARY_LIMIT,
          includeInactive: app.includeInactive,
        });

        if (!force && voteSummaryCacheKey === cacheKey && voteSummaryRows.length > 0) {
          return voteSummaryRows;
        }

        if (voteSummaryLoadPromise) {
          return voteSummaryLoadPromise;
        }

        if (force) {
          voteSummaryRows = [];
          voteSummaryCacheKey = "";
        }

        voteSummaryLoadPromise = (async () => {
          const endpoint = new URL("/api/votes/summary", window.location.origin);
          endpoint.searchParams.set("limit", String(VOTE_SUMMARY_LIMIT));
          endpoint.searchParams.set("offset", "0");
          if (requestedSource) {
            endpoint.searchParams.set("source_id", requestedSource);
          }
          if (requestedParty && requestedParty !== "all") {
            endpoint.searchParams.set("party_id", requestedParty);
          }
          if (app.searchTerm) {
            endpoint.searchParams.set("q", app.searchTerm);
          }
          if (isVerboseEnabled()) {
            verboseLog("fetch /api/votes/summary", {
              source: requestedSource || "all",
              party: requestedParty || "all",
              query: app.searchTerm,
              includeInactive: app.includeInactive,
              limit: VOTE_SUMMARY_LIMIT,
            });
          }
          if (isDebugEnabled()) {
            debugLog("fetch votes summary", {
              requestedParty,
              requestedSource,
              query: app.searchTerm,
              cacheKey,
            });
          }

          const apiEndpoint = resolveApiPath(`${endpoint.pathname}${endpoint.search}`);
          if (!apiEndpoint) {
            throw new Error("API de votaciones no disponible.");
          }

          const response = await fetch(apiEndpoint);
          const payload = await response.json();
          if (!response.ok) {
            throw new Error(payload?.error || `HTTP ${response.status}`);
          }

          const events = Array.isArray(payload?.events) ? payload.events : [];
          voteSummaryRows = events;
          voteSummaryCacheKey = cacheKey;
          return events;
        })().finally(() => {
          voteSummaryLoadPromise = null;
        });

        return voteSummaryLoadPromise;
      };

      const fetchElectionMeta = async () => {
        try {
          const payload = await fetchPayload({ apiPath: "/api/explorer/schema" });
          const tableNames = (payload?.tables || []).map((t) => String(t.name || "").toLowerCase());
          const hasElection = tableNames.some((name) => name.includes("eleccion") || name.includes("election"));
          app.hasElectionContext = hasElection;
        } catch (error) {
          app.hasElectionContext = false;
          if (isVerboseEnabled()) {
            verboseLog("fetchElectionMeta fallback est√°tico", {
              apiPath: "/api/explorer/schema",
              error: error?.message || String(error),
            });
          }
        }
      };

      const fetchAllMandates = async ({ force = false } = {}) => {
        const requestStamp = `mandates-${++mandatesRequestCounter}-${Date.now()}`;
        if (isVerboseEnabled()) {
          verboseLog("fetchAllMandates:entrada", {
            requestStamp,
            force,
            hasData: app.rawRows.length,
            mandatesLoaded,
            cacheKey: filterCacheKey,
          });
        }

        if (mandatesLoadPromise) {
          verboseLog("fetchAllMandates:pendiente reutilizado", { requestStamp });
          return mandatesLoadPromise;
        }

        if (!force && mandatesLoaded) {
          verboseLog("fetchAllMandates:skip", { requestStamp, reason: "cache_hit" });
          return;
        }

        if (force) {
          mandatesLoaded = false;
          app.rawRows = [];
          filterCacheKey = "";
        }

      mandatesLoadPromise = (async () => {
          const requestStart = performance.now();

          const loadPayload = async ({ useAll = false, limit, offset } = {}) => {
            const url = new URL("/api/arena/mandates", window.location.origin);
            const pageTag = `${requestStamp}:${useAll ? "all" : `chunk-${limit || 0}-${offset || 0}`}`;
            if (useAll) {
              url.searchParams.set("all", "1");
              url.searchParams.set("include_total", "0");
            } else {
              url.searchParams.set("limit", String(limit));
              url.searchParams.set("offset", String(offset));
            }
            url.searchParams.set("include_inactive", "1");
            if (isDebugEnabled()) {
              url.searchParams.set("debug", "1");
            }
            if (isVerboseEnabled()) {
              url.searchParams.set("verbose", "1");
              verboseLog("fetchAllMandates request", {
                requestStamp,
                pageTag,
                useAll,
                limit,
                offset,
                verbose: app.verbose,
                debugMode: app.debug,
                includeInactive: true,
                includeTotal: useAll ? 0 : 1,
                territoryFilter: app.territoryFilter,
                url: url.toString(),
              });
            }

            const start = performance.now();
            let response;
            let payload;
            const apiPath = `${url.pathname}${url.search}`;
            const apiEndpoint = resolveApiPath(apiPath);

            if (apiEndpoint) {
              try {
                response = await fetch(apiEndpoint);
                payload = await response.json();
              } catch (error) {
                if (isVerboseEnabled()) {
                  verboseLog("fetchAllMandates request excepcion", {
                    requestStamp,
                    pageTag,
                    url: apiEndpoint,
                    error: error?.message || String(error),
                  });
                }
                response = null;
              }
            } else {
              response = null;
            }

            if (!apiEndpoint || !response || !response.ok) {
              const staticPayload = await getStaticPayload("mandates", STATIC_MANDATES_PATH);
              const staticRows = Array.isArray(staticPayload?.rows) ? staticPayload.rows : [];
              const staticColumns = Array.isArray(staticPayload?.columns) ? staticPayload.columns : null;
              const staticLimit = Number(limit || 0);
              const staticOffset = Number(offset || 0);
              payload = {
                meta: {
                  total: staticRows.length,
                  limit: staticLimit,
                  offset: staticOffset,
                  returned: useAll ? staticRows.length : Math.min(staticLimit, Math.max(0, staticRows.length - staticOffset)),
                  include_inactive: true,
                },
                columns: staticColumns,
                rows: useAll ? staticRows : staticRows.slice(staticOffset, staticOffset + staticLimit),
              };
              response = { ok: true, status: "static", toString: () => staticPayload };
            } else if (isVerboseEnabled() && response.status >= 400) {
              verboseLog("fetchAllMandates response no-ok", {
                requestStamp,
                pageTag,
                status: response.status,
                ok: response.ok,
                error: payload?.error || "sin_error",
              });
            }
            if (isVerboseEnabled()) {
              const previewRows = expandMandatePayloadRows(payload || {});
              const sample = (previewRows || []).slice(0, 2).map((row) => ({
                full_name: row.full_name,
                party: row.party_name,
                role_title: row.role_title,
                level: row.level,
                territory: row.mandate_territory_name,
                code: row.mandate_territory_code,
              }));
              verboseLog("fetchAllMandates response", {
                requestStamp,
                pageTag,
                requested: { useAll, limit, offset, include_inactive: 1 },
                response: {
                  ok: response.ok,
                  status: response.status,
                  total: payload?.meta?.total,
                  returned: payload?.meta?.returned,
                  sample,
                },
                elapsedMs: Math.round(performance.now() - start),
              });
            }
            if (isDebugEnabled()) {
              debugLog("fetch /api/arena/mandates", {
                requested: { useAll, limit, offset, include_inactive: 1, debug: true },
                response: {
                  ok: response.ok,
                  status: response.status,
                  total: payload?.meta?.total,
                  returned: payload?.meta?.returned,
                  sample: payload?.meta,
                },
              });
            }
            if (!response.ok) {
              throw new Error(payload?.error || "Error cargando mandatos");
            }
            return payload || {};
          };

          const allPayload = await loadPayload({ useAll: true });
          const allRows = expandMandatePayloadRows(allPayload || {});
          const allTotal = Number(allPayload.meta?.total || allRows.length || 0);
          if (isVerboseEnabled()) {
            verboseLog("fetchAllMandates /all", {
              requestStamp,
              returnedRows: allRows.length,
              expectedTotal: allTotal,
            });
          }
            if (allRows.length > 0 && allRows.length >= allTotal) {
            app.rawRows = hydrateRows(allRows);
            rawDataVersion += 1;
            mandatesLoaded = true;
            filterCacheKey = "";
            verboseLog("mandatos cargados (all)", {
              rawRows: app.rawRows.length,
              totalHint: allTotal,
              requestStamp,
              firstRow: app.rawRows[0]
                ? {
                    full_name: app.rawRows[0].full_name,
                    role_title: app.rawRows[0].role_title,
                    party_name: app.rawRows[0].party_name,
                    territory: app.rawRows[0].territory_display_name,
                  }
                : null,
            });
            debugLog("mandatos cargados (all)", {
              rawRows: app.rawRows.length,
              totalHint: allTotal,
              sampleRows: app.rawRows.slice(0, 3).map((row) => ({
                full_name: row.full_name,
                role_title: row.role_title,
                party_name: row.party_name,
                territory: row.territory_display_name,
              })),
            });
            return;
          }

          const chunk = 5000;
          const firstPayload = await loadPayload({ useAll: false, limit: chunk, offset: 0 });
          const collected = [...expandMandatePayloadRows(firstPayload || {})];
          const total = Number(firstPayload.meta?.total || collected.length || 0);

          if (collected.length >= total || total <= 0) {
            app.rawRows = hydrateRows(collected);
            rawDataVersion += 1;
            mandatesLoaded = true;
            filterCacheKey = "";
            verboseLog("mandatos cargados (chunked single page)", {
              rawRows: app.rawRows.length,
              expectedTotal: total,
              requestStamp,
              firstRow: app.rawRows[0]
                ? {
                    full_name: app.rawRows[0].full_name,
                    role_title: app.rawRows[0].role_title,
                    party_name: app.rawRows[0].party_name,
                    territory: app.rawRows[0].territory_display_name,
                  }
                : null,
            });
            debugLog("mandatos cargados (chunked single page)", {
              rawRows: app.rawRows.length,
              expectedTotal: total,
            });
            return;
          }

          let offset = chunk;
          while (collected.length < total && collected.length < 60_000) {
            const payload = await loadPayload({ useAll: false, limit: chunk, offset });
            const rows = expandMandatePayloadRows(payload || {});
            if (rows.length === 0) {
              break;
            }
            collected.push(...rows);
            if (isVerboseEnabled()) {
              verboseLog("fetchAllMandates chunk", {
                requestStamp,
                offset,
                collected: collected.length,
                total,
                lastChunk: rows.length,
              });
            }
            if (collected.length >= total) {
              break;
            }
            offset += chunk;
          }

          app.rawRows = hydrateRows(collected);
          rawDataVersion += 1;
          mandatesLoaded = true;
          filterCacheKey = "";
          debugLog("mandatos cargados (chunked multi-page)", {
            rawRows: app.rawRows.length,
            expectedTotal: total,
            chunks: Math.ceil(collected.length / chunk),
            requestStamp,
          });
          verboseLog("mandatos cargados (chunked multi-page)", {
            rawRows: app.rawRows.length,
            expectedTotal: total,
            chunks: Math.ceil(collected.length / chunk),
            requestStamp,
            firstRow: app.rawRows[0]
              ? {
                  full_name: app.rawRows[0].full_name,
                  role_title: app.rawRows[0].role_title,
                  party_name: app.rawRows[0].party_name,
                  territory: app.rawRows[0].territory_display_name,
                }
              : null,
          });
          verboseLog("fetchAllMandates finalizado", {
            requestStamp,
            elapsedMs: Math.round(performance.now() - requestStart),
            loadedRows: app.rawRows.length,
            cacheKey: filterCacheKey,
          });
        })();

        try {
          return await mandatesLoadPromise;
        } finally {
          mandatesLoadPromise = null;
        }
      };

      const getActiveLevels = () => {
        if (app.league === "all") {
          return new Set(["nacional", "autonomia", "provincial", "municipal", "otra"]);
        }
        if (!app.aggregateMode) {
          return new Set([app.league]);
        }
        return new Set(LEVEL_HIERARCHY[app.league] || [app.league]);
      };

      const filterRows = () => {
        const parsedTerritoryFilter = parseTerritoryFilter(app.territoryFilter);
        const cacheKey = JSON.stringify({
          includeInactive: app.includeInactive,
          league: app.league,
          aggregateMode: app.aggregateMode,
          source: app.source,
          q: normalize(app.searchTerm),
          territory: parsedTerritoryFilter,
        });

        if (filterCacheKey === cacheKey) {
          return app.filteredRows;
        }

        const q = normalize(app.searchTerm);
        const acceptedLevels = getActiveLevels();
        const wantsTerritoryFilter = Boolean(parsedTerritoryFilter.level || parsedTerritoryFilter.name || parsedTerritoryFilter.code);
        const verbose = isVerboseEnabled();

        if (verbose) {
          verboseLog("filterRows:inicio", {
            request: {
              q,
              rawRows: app.rawRows.length,
              parsedTerritoryFilter,
              wantsTerritoryFilter,
              league: app.league,
              source: app.source,
              aggregateMode: app.aggregateMode,
              includeInactive: app.includeInactive,
            },
          });
        }

        const diagnostics = {
          inactive: 0,
          level: 0,
          source: 0,
          query: 0,
          territory: 0,
          matched: 0,
          territoryMatches: [],
          territoryMisses: [],
        };

        app.filteredRows = app.rawRows.filter((row) => {
          const hasActive = app.includeInactive || row.is_active;
          const levelMatch = acceptedLevels.has(row.teamLeague);
          const sourceMatch = app.source === "all" || row.source_id === app.source;
          const queryMatch =
            !q ||
            normalize(row.party_name).includes(q) ||
            normalize(row.party_acronym).includes(q) ||
            normalize(personDisplayName(row)).includes(q) ||
            normalize(row.role_title).includes(q) ||
            normalize(row.institution_name).includes(q) ||
            normalize(row.territory_display_name).includes(q) ||
            normalize(row.mandate_territory_name).includes(q) ||
            normalize(row.institution_territory_name).includes(q) ||
            normalize(row.person_territory_name).includes(q);
          const territoryMatch = !wantsTerritoryFilter || rowMatchesTerritoryFilter(row, parsedTerritoryFilter);

          const result = hasActive && levelMatch && sourceMatch && queryMatch && territoryMatch;

          if (!result && verbose) {
            if (!hasActive) {
              diagnostics.inactive += 1;
            }
            if (!levelMatch) {
              diagnostics.level += 1;
            }
            if (!sourceMatch) {
              diagnostics.source += 1;
            }
            if (!queryMatch) {
              diagnostics.query += 1;
            }
            if (!territoryMatch) {
              diagnostics.territory += 1;
              if (diagnostics.territoryMisses.length < 8) {
                diagnostics.territoryMisses.push(summarizeRowForDiagnostics(row));
              }
            }
          }

          if (result && verbose && diagnostics.territoryMatches.length < 8) {
            diagnostics.territoryMatches.push(summarizeRowForDiagnostics(row));
          }

          if (result) {
            diagnostics.matched += 1;
          }

          return result;
        });

        filterCacheKey = cacheKey;

        const debugState = JSON.stringify({
          rawRows: app.rawRows.length,
          filteredRows: app.filteredRows.length,
          territoryFilter: parsedTerritoryFilter,
          league: app.league,
          source: app.source,
          aggregateMode: app.aggregateMode,
          includeInactive: app.includeInactive,
          q,
          wantsTerritoryFilter,
        });
        if (verbose) {
          verboseLog("filterRows:resumen", {
            cacheKey,
            rawRows: app.rawRows.length,
            filteredRows: app.filteredRows.length,
            droppedRows: app.rawRows.length - app.filteredRows.length,
            parsedTerritoryFilter,
            wantsTerritoryFilter,
            reasonCounts: {
              inactive: diagnostics.inactive,
              level: diagnostics.level,
              source: diagnostics.source,
              query: diagnostics.query,
              territory: diagnostics.territory,
            },
            sampleMatches: diagnostics.territoryMatches.slice(0, 4),
          });
          if (diagnostics.territory > 0) {
            verboseLog("filterRows:territorio sin match", {
              wantsTerritoryFilter,
              parsedTerritoryFilter,
              totalNoTerritoryMatch: diagnostics.territory,
              sample: diagnostics.territoryMisses.slice(0, 4),
            });
          }
        }
        if (debugState !== filterDebugKey) {
          filterDebugKey = debugState;
          if (isDebugEnabled()) {
            const sample = app.filteredRows.slice(0, 5).map((row) => ({
              full_name: row.full_name,
              level: row.teamLeague,
              party: row.party_name,
              territory: row.territory_display_name,
              codeSet: [row.mandate_territory_code, row.institution_territory_code, row.person_territory_code].join(","),
              matchTerritory: rowMatchesTerritoryFilter(row, parsedTerritoryFilter),
            }));
            debugLog("filterRows", {
              parsedTerritoryFilter,
              sampleMatches: sample,
              total: app.filteredRows.length,
            });
            if (app.filteredRows.length === 0 && wantsTerritoryFilter) {
              const rawSample = app.rawRows.slice(0, 6).map((row) => ({
                full_name: row.full_name,
                level: row.teamLeague,
                league: row.level,
                party: row.party_name,
                territory: row.territory_display_name,
                rawCodes: [row.mandate_territory_code, row.institution_territory_code, row.person_territory_code].join(","),
                rawNames: [row.mandate_territory_name, row.institution_territory_name, row.person_territory_name].join(" | "),
                matchTerritory: rowMatchesTerritoryFilter(row, parsedTerritoryFilter),
              }));
              debugLog("filterRows sin resultados", {
                parsedTerritoryFilter,
                sampleRawRows: rawSample,
              });
            }
          }
        }
        return app.filteredRows;
      };

      const applyTerritoryFromSelect = (reason = "") => {
        if (isSyncingTerritorySelect || isApplyingTerritoryFilter) {
          verboseLog("territorio ignorado (sync)", {
            reason,
            syncingSelect: isSyncingTerritorySelect,
            applying: isApplyingTerritoryFilter,
          });
          return;
        }

        isApplyingTerritoryFilter = true;
        try {
          const selected = refs.territoryFilter ? refs.territoryFilter.value : "";
          verboseLog("territorio cambio detectado", {
            reason,
            selected,
            previous: app.territoryFilter,
            optionsCount: refs.territoryFilter ? refs.territoryFilter.options.length : 0,
            wasSelectedIndex: refs.territoryFilter ? refs.territoryFilter.selectedIndex : -1,
          });
          app.territoryFilter = selected || "";
          app.selectedPartyId = null;
          const parsed = parseTerritoryFilter(app.territoryFilter);
          const wantsFilter = Boolean(parsed.level || parsed.name || parsed.code);
          const previewRows = filterRows();
          const payload = {
            reason,
            raw: app.territoryFilter,
            parsed,
            wantsFilter,
            filteredRows: previewRows.length,
            rawRows: app.rawRows.length,
            league: app.league,
            source: app.source,
          };
          verboseLog("[explorer-politico] territorio aplicado", payload);
          if (isVerboseEnabled()) {
            const selectedText = refs.territoryFilter?.options
              ? safeText(refs.territoryFilter.options[refs.territoryFilter.selectedIndex]?.text)
              : "";
            verboseLog("territorio aplicado detalle", {
              raw: app.territoryFilter,
              displayText: selectedText,
              parse: parsed,
              wantsFilter,
              filteredRows: previewRows.length,
              source: "client-side-filter",
            });
            verboseLog("territorio aplicado: sin nueva petici√≥n API", {
              reason,
              mode: "filtro-local",
              nextRender: true,
            });
          }
          if (isDebugEnabled()) {
            debugLog("territorio actualizado desde UI", payload);
          }
          syncStateToUrl();
          render();
        } finally {
          isApplyingTerritoryFilter = false;
        }
      };

      const onTerritoryFilterChange = (event = null) => {
        if (isVerboseEnabled()) {
          const selected = refs.territoryFilter ? refs.territoryFilter.value : "";
          verboseLog("evento territorio recibido", {
            type: event?.type || "change",
            value: selected,
            isData: Boolean(event?.params?.data),
            selectedText: event?.params?.data?.text || "",
            reasonFromAttr: event?.type,
            syncingTerritory: isSyncingTerritorySelect,
            applyingTerritory: isApplyingTerritoryFilter,
          });
        }
        applyTerritoryFromSelect(event?.type || "select");
      };

      const renderTerritorySelect = () => {
	        if (!refs.territoryFilter) {
	          return false;
	        }
	
	        const seen = new Set();
	        const territories = new Map();
	        const displayToKeys = new Map();
	        const displayBlankKey = new Map();

        const territoryLabel = (value, institutionName = "") => {
          const direct = safeText(value).trim();
          if (direct && !isNumericOrCodeLike(direct)) {
            return direct;
          }
          const cleanedInstitution = cleanMunicipalityName(institutionName);
          return cleanedInstitution || direct || "Sin territorio";
        };

	        const addTerritory = (name, code, level) => {
	          const key = territoryOptionKey(name, code, level);
	          const normalizedLevel = normalizeTerritoryLevel(level);
	          const n = safeText(name).trim();
	          const c = safeText(code).trim();
	          if (!n && !c) {
	            return;
	          }
	
	          const lvl = normalizedLevel || "otra";
	          const displayKey = `${lvl}||${normalize(n || c) || "sin_nombre"}`;
	
	          // If we have a label but no stable code, don't create duplicates of the same label.
	          // If later we see the same label with a real code, replace the blank-code entry.
	          if (!c && displayToKeys.has(displayKey)) {
	            return;
	          }
	          if (c && displayBlankKey.has(displayKey)) {
	            const blankKey = displayBlankKey.get(displayKey);
	            if (blankKey) {
	              territories.delete(blankKey);
	              const keySet = displayToKeys.get(displayKey);
	              if (keySet) {
	                keySet.delete(blankKey);
	                if (keySet.size === 0) {
	                  displayToKeys.delete(displayKey);
	                }
	              }
	            }
	            displayBlankKey.delete(displayKey);
	          }
	
	          if (seen.has(key)) {
	            return;
	          }
	          seen.add(key);
	          if (!displayToKeys.has(displayKey)) {
	            displayToKeys.set(displayKey, new Set());
	          }
	          displayToKeys.get(displayKey).add(key);
	          if (!c) {
	            displayBlankKey.set(displayKey, key);
	          }
	          territories.set(key, {
	            key,
	            name: n || (c ? `C√≥digo ${c}` : "Sin territorio"),
	            code: c || "Sin c√≥digo",
	            level: lvl,
	          });
	        };

        for (const row of app.rawRows) {
          addTerritory(
            territoryLabel(row.mandate_territory_name || row.mandate_territory_code, row.institution_name),
            row.mandate_territory_code,
            normalizeTerritoryLevel(row.mandate_territory_level) || row.teamLeague
          );
          addTerritory(
            territoryLabel(row.institution_territory_name || row.institution_territory_code, row.institution_name),
            row.institution_territory_code,
            normalizeTerritoryLevel(row.institution_territory_level) || row.teamLeague
          );
          addTerritory(
            territoryLabel(row.person_territory_name || row.person_territory_code, row.institution_name),
            row.person_territory_code,
            normalizeTerritoryLevel(row.person_territory_level) || row.teamLeague
          );
        }

	        const needsCodeSuffix = new Set();
	        displayToKeys.forEach((keys) => {
	          if (keys.size > 1) {
	            keys.forEach((key) => needsCodeSuffix.add(key));
	          }
	        });
	
	        const options = Array.from(territories.values()).sort((a, b) =>
	          a.name.localeCompare(b.name, "es")
	        );
        const was = app.territoryFilter;
        if (isVerboseEnabled()) {
          verboseLog("territorios renderizados", {
            total: options.length,
            selectedBefore: was,
            selectedAfter: app.territoryFilter,
            preview: options.slice(0, 5).map((entry) => ({
              key: entry.key,
              level: entry.level,
              name: entry.name,
              code: entry.code,
            })),
          });
        }
        const selectedExists = app.territoryFilter ? options.some((entry) => entry.key === app.territoryFilter) : true;
        if (!selectedExists) {
          app.territoryFilter = "";
        }

	        refs.territoryFilter.innerHTML = `
	          <option value="">Todos los territorios</option>
	          ${options
		            .map(
		              (entry) =>
		                `<option value="${entry.key}" ${app.territoryFilter === entry.key ? "selected" : ""}>${entry.name}${needsCodeSuffix.has(entry.key) && entry.code && entry.code !== "Sin c√≥digo" ? " ¬∑ " + entry.code : ""} (${LEVEL_DEFINITIONS[entry.level]?.label || entry.level})</option>`
		            )
		            .join("")}
		        `;
        initTerritorySelect2();
        syncTerritorySelectValue();

        return was && was !== app.territoryFilter;
      };

      const computeTeams = () => {
        const rows = filterRows();
        const teams = new Map();

        for (const row of rows) {
          const teamKey = slugTeam(row);
          const teamName = row.party_name || "Sin partido";

          if (!teams.has(teamKey)) {
            teams.set(teamKey, {
              party_id: teamKey,
              party_name: teamName,
              party_acronym: row.party_acronym,
              players: new Map(),
              mandateCount: 0,
            });
          }

          const team = teams.get(teamKey);
          team.mandateCount += 1;

          const playerKey = row.person_id || `person-${personDisplayName(row)}`;
          if (!team.players.has(playerKey)) {
            team.players.set(playerKey, {
              person_id: row.person_id,
              full_name: row.full_name,
              family_name: row.family_name,
              given_name: row.given_name,
              mandates: [],
            });
          }
          team.players.get(playerKey).mandates.push(row);
        }

        const resolved = Array.from(teams.values())
          .map((team) => {
            const players = Array.from(team.players.values())
              .map((player) => {
                const sorted = player.mandates
                  .slice()
                  .sort((a, b) => Number(b.is_active) - Number(a.is_active) || String(b.start_date).localeCompare(String(a.start_date)));
                const active = sorted.filter((m) => m.is_active);
                const latest = sorted[0];
                const latestLeague = latest ? rowLeague(latest) : "otra";
                const latestLeagueRank = leagueRank(latestLeague);

                return {
                  ...player,
                  mandates: sorted,
                  activeCount: active.length,
                  latest,
                  latestLeagueRank,
                };
              })
              .sort((a, b) => {
                const aActive = a.activeCount > 0 ? 1 : 0;
                const bActive = b.activeCount > 0 ? 1 : 0;
                if (aActive !== bActive) {
                  return bActive - aActive;
                }
                if (a.latestLeagueRank !== b.latestLeagueRank) {
                  return a.latestLeagueRank - b.latestLeagueRank;
                }
                if ((a.latest?.start_date || "") !== (b.latest?.start_date || "")) {
                  return String(b.latest?.start_date || "").localeCompare(String(a.latest?.start_date || ""));
                }
                return personDisplayName(a).localeCompare(personDisplayName(b), "es");
              });

            const activePlayers = players.filter((p) => p.activeCount > 0);

            return {
              ...team,
              players,
              activePlayersCount: activePlayers.length,
              totalPlayers: players.length,
              totalMandates: team.mandateCount || 0,
            };
          });

        const aggregated = [];
        const otherParties = {
          party_id: "__otros__",
          party_name: "Otros",
          party_acronym: "Otros",
          players: new Map(),
          activePlayersCount: 0,
          totalPlayers: 0,
          totalMandates: 0,
        };

        for (const team of resolved) {
          if (team.party_id !== "__sin_partido__" && team.totalPlayers === 1) {
            for (const player of team.players.values()) {
              const otherKey = player.person_id || `person-${personDisplayName(player)}`;
              if (!otherParties.players.has(otherKey)) {
                otherParties.players.set(otherKey, player);
              }
            }
            otherParties.activePlayersCount += team.activePlayersCount;
            otherParties.totalPlayers += team.totalPlayers;
            otherParties.totalMandates += team.totalMandates;
            continue;
          }

          aggregated.push(team);
        }

        if (otherParties.totalPlayers > 0) {
          aggregated.push(otherParties);
        }

        return aggregated
          .sort((a, b) => b.activePlayersCount - a.activePlayersCount || b.totalPlayers - a.totalPlayers)
          .filter((team) => team.party_name.toLowerCase().includes(normalize(app.searchTerm)) ||
            normalize(team.party_acronym).includes(normalize(app.searchTerm)) ||
            team.party_id === "__sin_partido__");
      };

      const buildTreemap = (items, width, height) => {
        const safe = items
          .map((item) => ({
            ...item,
            weight: Math.max(1, Number(item.totalPlayers || item.activePlayersCount || 0)),
            title:
              item.party_id === "__sin_partido__"
                ? "Sin partido"
                : `${item.party_name}${item.party_acronym ? ` (${item.party_acronym})` : ""}`,
          }))
          .sort((a, b) => b.weight - a.weight || b.totalMandates - a.totalMandates);

        const totalWeight = safe.reduce((sum, item) => sum + item.weight, 0);
        if (!safe.length || !totalWeight || width <= 0 || height <= 0) {
          return [];
        }

        const totalArea = width * height;
        const scale = totalArea / totalWeight;
        const normalized = safe.map((item) => ({
          ...item,
          area: Math.max(1, item.weight * scale),
        }));

        const nodes = [];
        const areaToRow = (row) => row.reduce((sum, item) => sum + item.area, 0);
        const worstRatio = (row, side) => {
          if (!row.length || !side) {
            return Infinity;
          }
          const rowArea = areaToRow(row);
          if (!rowArea) {
            return Infinity;
          }
          const maxArea = Math.max(...row.map((item) => item.area));
          const minArea = Math.min(...row.map((item) => item.area));
          if (!maxArea || !minArea) {
            return Infinity;
          }
          const s2 = rowArea * rowArea;
          return Math.max((side * side * maxArea) / s2, s2 / (side * side * minArea));
        };

        const layoutRow = (row, x, y, w, h, horizontal) => {
          if (!row.length) {
            return 0;
          }
          const rowArea = areaToRow(row);
          if (horizontal) {
            const rowHeight = Math.max(1e-3, rowArea / Math.max(1, w));
            let cursorX = x;
            let remainingW = w;
            for (let i = 0; i < row.length; i++) {
              const item = row[i];
              const isLast = i === row.length - 1;
              const itemW = isLast ? remainingW : Math.max(1, (item.area / rowArea) * w);
              nodes.push({
                ...item,
                x: cursorX,
                y,
                w: itemW,
                h: rowHeight,
              });
              cursorX += itemW;
              remainingW -= itemW;
            }
            return rowHeight;
          }

          const rowWidth = Math.max(1e-3, rowArea / Math.max(1, h));
          let cursorY = y;
          let remainingH = h;
          for (let i = 0; i < row.length; i++) {
            const item = row[i];
            const isLast = i === row.length - 1;
            const itemH = isLast ? remainingH : Math.max(1, (item.area / rowArea) * h);
            nodes.push({
              ...item,
              x,
              y: cursorY,
              w: rowWidth,
              h: itemH,
            });
            cursorY += itemH;
            remainingH -= itemH;
          }
          return rowWidth;
        };

        const squarify = (items, x, y, w, h) => {
          if (!items.length || w <= 1 || h <= 1) {
            return;
          }
          if (items.length === 1) {
            nodes.push({
              ...items[0],
              x,
              y,
              w: Math.max(1, w),
              h: Math.max(1, h),
            });
            return;
          }

          const horizontal = w >= h;
          const side = horizontal ? w : h;
          const remaining = [...items];
          const row = [];

          while (remaining.length) {
            const candidate = remaining[0];
            const newRow = [...row, candidate];
            if (!row.length || worstRatio(newRow, side) <= worstRatio(row, side)) {
              row.push(candidate);
              remaining.shift();
              if (!remaining.length) {
                break;
              }
            } else {
              break;
            }
          }

          if (!row.length) {
            row.push(remaining.shift());
          }

          const consumed = layoutRow(row, x, y, w, h, horizontal);
          if (!remaining.length) {
            return;
          }
          const safeConsumed = Math.min(Math.max(0, consumed), horizontal ? h : w);

          if (horizontal) {
            squarify(remaining, x, y + safeConsumed, w, h - safeConsumed);
          } else {
            squarify(remaining, x + safeConsumed, y, w - safeConsumed, h);
          }
        };

        squarify(normalized, 0, 0, width, height);

        return nodes;
      };

      const renderPartyTreemap = (teams) => {
        refs.teamList.classList.add("treemap");
        refs.teamList.innerHTML = "";
        refs.teamList.style.position = "relative";
        const width = Math.max(1, Math.floor(refs.teamList.clientWidth - 8));
        const height = Math.max(1, Math.floor((refs.teamList.clientHeight || 0) - 8));
        const nodes = buildTreemap(teams, width, height);

        if (nodes.length === 0) {
          refs.teamList.innerHTML = "<p class='hint'>Sin partidos para esta combinaci√≥n.</p>";
          return;
        }

        for (const node of nodes) {
          const tone = partyColor(node.party_id, node.party_name);
          const activeRatio = node.totalPlayers ? Math.round((node.activePlayersCount / node.totalPlayers) * 100) : 0;
          const readableColor = partyTextColor(node.party_id, node.party_name);
          const compact = node.w < 120 || node.h < 52;
          const label = compact ? `${node.party_acronym || node.party_name.slice(0, 3)}` : node.title;
          const meta = compact
            ? `${node.totalPlayers} ¬∑ ${node.activePlayersCount} act.`
            : `${node.totalPlayers} integrantes ¬∑ ${node.activePlayersCount} activos`;

          const element = document.createElement("button");
          element.type = "button";
          element.className = "treemap-node";
          element.style.left = `${Math.max(0, Math.floor(node.x || 0))}px`;
          element.style.top = `${Math.max(0, Math.floor(node.y || 0))}px`;
          element.style.width = `${Math.max(1, Math.ceil(node.w || 0))}px`;
          element.style.height = `${Math.max(1, Math.ceil(node.h || 0))}px`;
          element.style.borderLeft = `5px solid ${tone}`;
          element.style.background = compact ? "rgba(255, 255, 255, 0.95)" : `linear-gradient(160deg, rgba(255,255,255,0.95), ${tone}55)`;
          element.style.color = readableColor;

          element.innerHTML = `
            <div class="tm-label" title="${node.party_name || ""}">${label}</div>
            <div class="tm-meta">
              <span><span class="dot" style="background:${tone}"></span>${meta}</span>
              <span><span class="dot" style="background:${tone}"></span>Mandatos: ${node.totalMandates}</span>
            </div>
            <div class="tm-stat-fill"><span style="width:${activeRatio}%; background:${tone};"></span></div>
          `;

          element.onclick = () => {
            app.selectedPartyId = node.party_id;
            syncStateToUrl();
            void render();
          };
          refs.teamList.appendChild(element);
        }

      };

      const renderLeagues = () => {
        const rows = filterRows();
        const counts = {
          all: { teams: 0, players: 0 },
          nacional: { teams: 0, players: 0 },
          autonomia: { teams: 0, players: 0 },
          provincial: { teams: 0, players: 0 },
          municipal: { teams: 0, players: 0 },
          otra: { teams: 0, players: 0 },
        };

        const seenTeam = {
          all: new Set(),
          nacional: new Set(),
          autonomia: new Set(),
          provincial: new Set(),
          municipal: new Set(),
          otra: new Set(),
        };

        for (const row of rows) {
          const key = slugTeam(row);
          const league = row.teamLeague;
          const teams = seenTeam[league] || new Set();
          teams.add(key);
          seenTeam[league] = teams;
          seenTeam.all.add(key);
          counts.all.players += 1;
          counts[league].players += 1;
        }

        Object.keys(counts).forEach((league) => {
          const teamSet = seenTeam[league] || new Set();
          counts[league].teams = teamSet.size;
        });

        refs.leagueGrid.innerHTML = "";
        Object.entries(LEVEL_DEFINITIONS).forEach(([id, def]) => {
          const card = document.createElement("button");
          card.type = "button";
          card.className = "league" + (app.league === id ? " active" : "");
          card.setAttribute("data-league", id);
          card.onclick = () => {
            app.league = id;
            app.selectedPartyId = null;
            syncStateToUrl();
            render();
          };

          card.innerHTML = `
            <h3>
              <span>${def.badge} ${def.label}</span>
              <span>${counts[id].teams}</span>
            </h3>
            <p class="small">${def.subtitle}</p>
            <div class="badge-wrap">
            <span class="pill">Partidos: ${counts[id].teams}</span>
              <span class="pill">Mandatos: ${counts[id].players}</span>
            </div>
          `;
          refs.leagueGrid.appendChild(card);
        });
      };

      const renderScoreboard = () => {
        const filtered = filterRows();
        const active = filtered.filter((row) => row.is_active).length;
        const parties = new Set(filtered.map((r) => slugTeam(r))).size;
        const players = new Set(filtered.map((r) => r.person_id)).size;

        refs.scoreboard.innerHTML = `
          <div class="score-item"><span>Mandatos visibles</span><strong>${filtered.length}</strong></div>
          <div class="score-item"><span>Pol√≠ticos √∫nicos</span><strong>${players}</strong></div>
            <div class="score-item"><span>Partidos activos</span><strong>${parties}</strong></div>
            <div class="score-item"><span>Pol√≠ticos en activo</span><strong>${active}</strong></div>
        `;
      };

      const renderMunicipalityLeaderboard = () => {
        if (!refs.municipalityLeaderboard) {
          return;
        }

        const rows = filterRows();
        const buckets = new Map();

        for (const row of rows) {
          const municipality = getMunicipalityFromRow(row);
          if (!municipality) {
            continue;
          }
          const personId = safeText(row.person_id);
          if (!personId) {
            continue;
          }
          if (!buckets.has(municipality.code)) {
            buckets.set(municipality.code, {
              code: municipality.code,
              name: municipality.name || municipality.code,
              population: Number.isFinite(municipality.population) ? municipality.population : null,
              people: new Set(),
            });
          }
          const bucket = buckets.get(municipality.code);
          bucket.people.add(personId);
        }

        const toDensity = (entry) => {
          if (!entry.population || entry.population <= 0) {
            return 0;
          }
          return (entry.people.size / entry.population) * 100000;
        };

        const entries = Array.from(buckets.values())
          .map((entry) => ({
            ...entry,
            politicians: entry.people.size,
            density: toDensity(entry),
          }))
          .sort((a, b) => {
            if (a.population !== b.population) {
              if (a.population === null) {
                return 1;
              }
              if (b.population === null) {
                return -1;
              }
              if (b.density !== a.density) {
                return b.density - a.density;
              }
            }
            return b.politicians - a.politicians || a.name.localeCompare(b.name, "es");
          })
          .slice(0, MUNICIPALITY_LEADERBOARD_LIMIT);

        if (entries.length === 0) {
          refs.municipalityLeaderboard.innerHTML = `<p class=\"hint\">Sin municipios para esta vista.</p>`;
          return;
        }

        const maxDensity = Math.max(
          0.000001,
          ...entries.map((entry) => (Number.isFinite(entry.density) ? entry.density : 0))
        );

        refs.municipalityLeaderboard.innerHTML = entries
          .map((entry) => {
            const populationLabel = entry.population ? `${entry.population.toLocaleString("es-ES")} hab.` : "Poblaci√≥n no disponible";
            const ratioLabel = entry.population ? `${entry.density.toFixed(1)} /100k` : "sin ratio";
            const barWidth = `${Math.min(100, Math.round((entry.density / maxDensity) * 100))}%`;
            return `<div class="municipality-item">
              <div class="municipality-head">
                <p class="municipality-name">${entry.name}</p>
                <span class="municipality-ratio">${ratioLabel}</span>
              </div>
              <p class="municipality-metrics">Personas: ${entry.politicians} ¬∑ ${populationLabel}</p>
              <div class="municipality-bar">
                <div class="municipality-fill" style="width:${barWidth}"></div>
              </div>
            </div>`;
          })
          .join("");
      };

      const renderTodo = () => {
        const items = [
          {
            label: "Conectar cada mandato a una convocatoria de elecci√≥n concreta (convocatoria->jornada)",
            done: app.hasElectionContext,
          },
          {
            label: "Jerarqu√≠a territorial real por niveles (estado -> auton√≥mico -> provincial -> municipal)",
            done: false,
          },
          {
            label: "Agregar ranking de partidos por influencia territorial en el tiempo",
            done: false,
          },
          {
            label: "Exportar historial pol√≠tico por partido y periodo de estudio",
            done: false,
          },
        ];

        const html = items
          .map(
            (item) => `
              <li class="${item.done ? "done" : "missing"}">${item.done ? "‚úÖ" : "‚è±"} ${item.label}</li>`
          )
          .join("");

        refs.todo.innerHTML = `
          <h3>üß≠ Hoja de ruta</h3>
          <ul>${html}</ul>
        `;
      };

      const roleHierarchyRank = (roleTitle = "") => {
        const role = normalize(roleTitle);
        if (!role) {
          return 999;
        }

        if (/\bteniente(?: de)? alcalde\b/.test(role) || /\bvicealcald[ae]\b/.test(role)) {
          return 1;
        }

        for (const rule of ROLE_HIERARCHY_RULES) {
          for (const pattern of rule.patterns) {
            if (pattern.test(role)) {
              return rule.rank;
            }
          }
        }

        return 6;
      };

      const roleHierarchyLabel = (roleRank = 6) => {
        if (roleRank <= 0) {
          return "Alcalde / Presidencia";
        }
        if (roleRank === 1) {
          return "Teniente de Alcalde / Vice";
        }
        if (roleRank === 2) {
          return "Direcci√≥n / Secretar√≠a";
        }
        if (roleRank === 3) {
          return "Concejal";
        }
        if (roleRank === 4) {
          return "Otros cargos";
        }
        return "Sin clasificar";
      };

      const playerHierarchyMeta = (player) => {
        const current = player.latest || {};
        const level = normalizeTerritoryLevel(
          rowLeague(current) ||
            current.mandate_territory_level ||
            current.institution_territory_level ||
            current.person_territory_level
        );

        return {
          level: level || "otra",
          levelRank: leagueRank(level || "otra"),
          roleRank: roleHierarchyRank(current.role_title || ""),
          territoryName: current.institution_territory_name || current.person_territory_name || current.mandate_territory_name || "Sin territorio",
          roleTitle: current.role_title || "Sin rol",
          institutionName: current.institution_name || "Instituci√≥n",
          startDate: current.start_date || "",
          endDate: current.end_date || "",
          activeClass: player.activeCount > 0 ? "on" : "off",
          activeLabel: player.activeCount > 0 ? "Activo" : "Hist√≥rico",
          current,
        };
      };

      const levelLabel = (level) => LEVEL_DEFINITIONS[level]?.label || "Sin nivel";

      const renderPlayerList = (team) => {
        const search = normalize(app.searchTerm);
        const players = team.players.filter((player) => {
          if (!search) {
            return true;
          }
          return (
            normalize(personDisplayName(player)).includes(search) ||
            normalize(player.latest?.role_title || "").includes(search) ||
            normalize(player.latest?.institution_name || "").includes(search)
          );
        });

        const teamName = team.party_id === "__sin_partido__" ? "Sin partido" : team.party_name;
        const color = partyColor(team.party_id, teamName);
        const playerItems = players
          .map((player) => {
            const meta = playerHierarchyMeta(player);
            return {
              ...player,
              ...meta,
            };
          })
          .sort((a, b) => {
            if ((a.activeClass === "on") !== (b.activeClass === "on")) {
              return a.activeClass === "on" ? -1 : 1;
            }
            if (a.levelRank !== b.levelRank) {
              return a.levelRank - b.levelRank;
            }
            if (a.roleRank !== b.roleRank) {
              return a.roleRank - b.roleRank;
            }
            if ((a.startDate || "") !== (b.startDate || "")) {
              return String(b.startDate || "").localeCompare(String(a.startDate || ""));
            }
            return personDisplayName(a).localeCompare(personDisplayName(b), "es");
          });
        const groups = new Map(
          TERRITORY_LEVEL_ORDER.map((level) => [
            level,
            {
              levelCount: 0,
              roleBuckets: new Map(),
            },
          ])
        );
        const orderedPlayers = [];

        for (const player of playerItems) {
          const key = player.level || "otra";
          const bucket = groups.get(key) || { levelCount: 0, roleBuckets: new Map() };
          const roleBucket = bucket.roleBuckets.get(player.roleRank) || [];
          roleBucket.push(player);
          bucket.levelCount += 1;
          bucket.roleBuckets.set(player.roleRank, roleBucket);
          groups.set(key, bucket);
          orderedPlayers.push(player);
        }

        const visibleTerritories = new Set(
          orderedPlayers.map((player) => {
            const current = player.current || {};
            return current.institution_territory_name || current.person_territory_name || current.mandate_territory_name || "Sin territorio";
          })
        );

        refs.teamDetail.innerHTML = `
          <div style="display: flex; flex-direction: column; align-items: flex-start; gap: 8px;">
            <button id="back-to-leagues" style="border-radius: 999px;border: 1px solid var(--line);background: rgba(255,255,255,0.96);padding: 8px 12px;">‚Üê Volver</button>
            <div>
              <h3 style="margin: 0">${teamName}</h3>
              <p class="small">${team.totalPlayers} integrantes ¬∑ ${team.activePlayersCount} en activo</p>
              <p class="small">Filtro: ${LEVEL_DEFINITIONS[app.league]?.label || "Todas"} (${app.aggregateMode ? "agregado" : "individual"})</p>
            </div>
          </div>
          <div class="score-item" style="margin-top: 8px;">
            <span>Territorios distintos</span>
            <strong>${visibleTerritories.size}</strong>
          </div>
          <div class="hint">Selecciona un pol√≠tico para abrir su historial completo.</div>
          <div id="players"></div>
        `;

        refs.teamDetail.querySelector("#back-to-leagues").onclick = () => {
          app.selectedPartyId = null;
          syncStateToUrl();
          void render();
        };

        const container = refs.teamDetail.querySelector("#players");
        if (orderedPlayers.length === 0) {
          container.innerHTML = `<p class="hint">No hay pol√≠ticos con ese filtro.</p>`;
          return;
        }

        container.className = "player-level-list";
        for (const level of TERRITORY_LEVEL_ORDER) {
          const levelGroup = groups.get(level);
          if (!levelGroup || !levelGroup.levelCount) {
            continue;
          }
          const block = document.createElement("div");
          block.className = "player-level-block";

          const title = document.createElement("h4");
          title.className = "player-level-title";
          title.textContent = `${levelLabel(level)} ¬∑ ${levelGroup.levelCount}`;
          block.appendChild(title);

          const roleRanks = Array.from(levelGroup.roleBuckets.keys()).sort((a, b) => a - b);
          for (const roleRank of roleRanks) {
            const playersAtRole = (levelGroup.roleBuckets.get(roleRank) || []).slice().sort((a, b) => {
              if (a.activeClass !== b.activeClass) {
                return a.activeClass === "on" ? -1 : 1;
              }
              if ((a.startDate || "") !== (b.startDate || "")) {
                return String(b.startDate || "").localeCompare(String(a.startDate || ""));
              }
              return personDisplayName(a).localeCompare(personDisplayName(b), "es");
            });

            const roleTitle = document.createElement("h5");
            roleTitle.className = "player-role-title";
            roleTitle.textContent = `${roleHierarchyLabel(roleRank)} ¬∑ ${playersAtRole.length}`;
            block.appendChild(roleTitle);

            const row = document.createElement("div");
            row.className = "player-level-row";

            for (const player of playersAtRole) {
              const card = document.createElement("button");
              card.className = "player";
              card.type = "button";
              card.style.borderLeft = `4px solid ${color}`;
              card.innerHTML = `
                <div class="player-head">
                  <h4>${personDisplayName(player)}</h4>
                  <span class="pill ${player.activeClass}">${player.activeLabel}</span>
                </div>
                <p class="small">${player.roleTitle}</p>
                <p class="small">${player.institutionName} ¬∑ ${player.territoryName}</p>
                <p class="small">Desde ${normalizeDate(player.startDate)} a ${normalizeDate(player.endDate) || "hoy"}</p>
              `;
              card.onclick = () => openPlayerModal(player.person_id);
              row.appendChild(card);
            }

            block.appendChild(row);
          }

          container.appendChild(block);
        }

        refs.teamDetail.scrollTo({ top: 0, behavior: "smooth" });
      };

      const renderTeamList = () => {
        const teams = computeTeams();
        const isTreemapView = app.league === "all" && !app.selectedPartyId;

        if (refs.teamPanelScroll) {
          refs.teamPanelScroll.classList.toggle("team-treemap", isTreemapView);
        }

        if (!app.selectedPartyId) {
          refs.teamsTitle.textContent = `Partidos del nivel: ${LEVEL_DEFINITIONS[app.league]?.label || "Seleccionado"}`;
          refs.teamList.style.display = "block";
          refs.teamDetail.style.display = "none";
          refs.teamList.classList.remove("treemap");
          refs.teamList.style.position = "";
          refs.teamList.style.overflow = "";
          refs.teamList.style.height = "";
          refs.teamList.innerHTML = "";

          if (teams.length === 0) {
            refs.teamList.innerHTML = "<p class='hint'>Sin partidos para esta combinaci√≥n.</p>";
            return;
          }

          if (isTreemapView) {
            renderPartyTreemap(teams);
            return;
          }

          for (const team of teams) {
            const tone = partyColor(team.party_id, team.party_name);
            const visiblePlayers = team.totalPlayers;
            const barWidth = Math.max(12, Math.min(100, (team.activePlayersCount / Math.max(1, visiblePlayers)) * 100));
            const name = team.party_id === "__sin_partido__" ? "Sin partido" : `${team.party_name}${team.party_acronym ? ` (${team.party_acronym})` : ""}`;
            const teamIdLabel = team.party_id === "__sin_partido__" ? "NA" : team.party_id === "__otros__" ? "OTROS" : team.party_id;
            const card = document.createElement("button");
            card.type = "button";
            card.className = "team-card";
            card.style.borderLeft = `5px solid ${tone}`;
            card.innerHTML = `
              <div class="team-top">
                <div class="team-id">
                <span class="shield" style="background:${tone}; color:${partyTextColor(team.party_id, team.party_name)};">${name.slice(0, 2).toUpperCase() || "SP"}</span>
                  <div>
                    <p class="team-name">${name}</p>
                  </div>
                </div>
                <span class="pill">ID ${teamIdLabel}</span>
              </div>
              <div class="team-meta">
                <span class="tag">${visiblePlayers} integrantes</span>
                <span class="tag">${team.activePlayersCount} activos</span>
                <span class="tag">${team.totalMandates} mandatos</span>
              </div>
              <div class="team-stats">
                <div class="stat-strip"><div class="stat-fill" style="width:${barWidth}%;"></div></div>
                <p class="small">Ratio de activos: ${team.totalPlayers ? Math.round((team.activePlayersCount / team.totalPlayers) * 100) : 0}%</p>
              </div>
            `;
            card.onclick = () => {
              app.selectedPartyId = team.party_id;
              syncStateToUrl();
              void render();
            };
            refs.teamList.appendChild(card);
          }
          return;
        }

        const selected = teams.find((team) => team.party_id === app.selectedPartyId);
        refs.teamList.classList.remove("treemap");
        refs.teamList.style.position = "";
        refs.teamList.style.overflow = "";
        refs.teamList.style.height = "";
        if (!selected) {
          app.selectedPartyId = null;
          renderTeamList();
          return;
        }

        refs.teamList.style.display = "none";
        refs.teamDetail.style.display = "block";
        renderPlayerList(selected);
      };

      const renderTeamDetail = () => {
        renderTeamList();
      };

      const scheduleTreemapRerender = () => {
        if (app.league !== "all" || app.selectedPartyId) {
          return;
        }
        if (typeof requestAnimationFrame === "undefined") {
          renderTeamList();
          return;
        }
        if (window.__politicoTreemapRaf) {
          cancelAnimationFrame(window.__politicoTreemapRaf);
        }
        window.__politicoTreemapRaf = requestAnimationFrame(() => {
          window.__politicoTreemapRaf = null;
          if (app.league === "all" && !app.selectedPartyId) {
            renderTeamList();
          }
        });
      };

      const openPlayerModal = async (personId) => {
        if (!personId) {
          return;
        }

        refs.historyContent.innerHTML = `<p class="loading">Cargando historial...`;
        refs.historyOverlay.classList.add("show");

        try {
          const payload = await (async () => {
            const apiEndpoint = resolveApiPath(`/api/person/${personId}`);
            if (apiEndpoint) {
              const response = await fetch(apiEndpoint);
              const personPayload = await response.json();
              if (response.ok && !personPayload.error) {
                return personPayload;
              }
            }
            // Static (GitHub Pages): derive from already-loaded mandates snapshot.
            const mandates = (app.rawRows || []).filter((row) => Number(row.person_id) === Number(personId));
            if (!mandates.length) {
              return {};
            }
            const head = mandates[0] || {};
            const person = {
              person_id: Number(personId),
              full_name: head.full_name || "",
              given_name: head.given_name || "",
              family_name: head.family_name || "",
              birth_date: head.birth_date || null,
              gender: head.gender || null,
              territory_code: head.person_territory_code || head.territory_code || null,
            };
            const mappedMandates = mandates
              .map((m) => ({
                mandate_id: m.mandate_id,
                source_id: m.source_id,
                role_title: m.role_title,
                level: m.level,
                mandate_territory_code: m.mandate_territory_code,
                start_date: m.start_date,
                end_date: m.end_date,
                is_active: m.is_active,
                institution_name: m.institution_name,
                party_id: m.party_id,
                party_name: m.party_name,
                party_acronym: m.party_acronym,
              }))
              .sort((a, b) => {
                const aActive = Number(a.is_active) === 1 ? 1 : 0;
                const bActive = Number(b.is_active) === 1 ? 1 : 0;
                if (aActive !== bActive) return bActive - aActive;
                const aStart = safeText(a.start_date);
                const bStart = safeText(b.start_date);
                if (aStart !== bStart) return bStart.localeCompare(aStart);
                return Number(b.mandate_id || 0) - Number(a.mandate_id || 0);
              });
            return { person, mandates: mappedMandates };
          })();

          const person = payload?.person || {};
          let mandates = Array.isArray(payload?.mandates) ? payload.mandates : [];

          if (!person.full_name && !person.given_name && !person.family_name && mandates.length === 0) {
            throw new Error("No encontrado");
          }

          mandates = mandates.map((m) => ({
            ...m,
            is_active: Number(m.is_active) === 1,
          }));

          const currentMandate = mandates.find((m) => m.is_active) || mandates[0] || {};
          const sourceIds = Array.from(new Set((mandates || []).map((m) => safeText(m.source_id).trim()).filter(Boolean)));
          const sourceLinks = sourceIds
            .map(
              (sourceId) =>
                `<p class="line">Fuente: ${sourceLink(sourceId)}${sourceId ? ` <span style="color: var(--muted);">(${sourceId})</span>` : ""}</p>`
            )
            .join("");
          const historyRows = mandates
            .map(
              (m) => `
                <div class="history-item" style="border-left-color: ${partyColor(m.party_id, m.party_name)};">
                  <strong>${m.role_title || "Cargo"}</strong> (${m.level || "nivel"})
                  <p class="line">${m.institution_name || "Instituci√≥n"} ¬∑ ${m.party_name || "Sin partido"}</p>
                  <p class="line">Fuente: ${sourceLink(m.source_id)}${safeText(m.source_id) ? ` (${safeText(m.source_id)})` : ""}</p>
                  <p class="line">${normalizeDate(m.start_date)} - ${normalizeDate(m.end_date) || "hoy"}</p>
                </div>
              `
            )
            .join("");
          const currentColor = partyColor(currentMandate.party_id, currentMandate.party_name);

          refs.historyContent.innerHTML = `
            <h2 style="margin-top: 0">${personDisplayName(person) || "Sin nombre"}</h2>
            <p class="small">${person.birth_date ? `Nacimiento: ${normalizeDate(person.birth_date)}` : ""}</p>
            <p class="small">G√©nero: ${person.gender || "Sin dato"} ¬∑ Territorio: ${person.territory_code || "N/A"}</p>
            <h3 style="margin: 8px 0 8px">Fuentes asociadas</h3>
            <div class="timeline">${sourceLinks || "<p class='hint'>Sin fuente asociada.</p>"}</div>
            <h3 style="margin: 8px 0 8px">Cargo actual</h3>
            <div class="history-item" style="margin-bottom: 8px; border-left-color: ${currentColor};">
              <strong>${currentMandate.role_title || "Sin mandato activo"}</strong>
              <p class="line">${currentMandate.institution_name || ""}</p>
              <p class="line">${currentMandate.party_name || ""} ¬∑ ${currentMandate.level || ""}</p>
            </div>
            <h3 style="margin: 8px 0 8px">Historial de mandatos</h3>
            <div class="timeline">${historyRows || "<p class='hint'>Sin historial visible</p>"}</div>
          `;
        } catch (error) {
          refs.historyContent.innerHTML = `<p class="loading">${error.message}</p>`;
        }
      };

      const closePlayerModal = () => {
        refs.historyOverlay.classList.remove("show");
      };

      const render = async ({ forceReload = false } = {}) => {
        const renderStamp = `render-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
        const shouldLoad = forceReload || app.rawRows.length === 0;
        if (isVerboseEnabled()) {
          verboseLog("render:inicio", {
            renderStamp,
            forceReload,
            shouldLoad,
            rawRowsBefore: app.rawRows.length,
            territoryFilter: app.territoryFilter,
            selectedPartyId: app.selectedPartyId,
            cacheKey: filterCacheKey,
          });
        }
        if (shouldLoad) {
          refs.leagueLoading.classList.remove("hidden");
          refs.leagueLoading.textContent = "Actualizando vista pol√≠tica...";
        } else {
          refs.leagueLoading.classList.add("hidden");
          refs.leagueLoading.style.display = "none";
        }

        try {
          if (isDebugEnabled()) {
            debugLog("render start", {
              forceReload,
              debug: app.debug,
              rawRows: app.rawRows.length,
              territoryFilter: app.territoryFilter,
              league: app.league,
              source: app.source,
              includeInactive: app.includeInactive,
            });
          }
          if (isVerboseEnabled()) {
            verboseLog("render:datos_listos", {
              renderStamp,
              rawRowsBeforeFilter: app.rawRows.length,
              territoryFilter: app.territoryFilter,
            });
          }
          await fetchAllMandates({ force: forceReload });
          if (isVerboseEnabled()) {
            verboseLog("render:post_fetch", {
              renderStamp,
              rawRowsAfterFetch: app.rawRows.length,
            });
          }
          let territoryReset = false;
          if (forceReload || lastTerritoryRenderVersion !== rawDataVersion) {
            territoryReset = renderTerritorySelect();
            lastTerritoryRenderVersion = rawDataVersion;
          }
          renderLeagueSelect();
          renderLeagues();
          renderScoreboard();
          renderMunicipalityLeaderboard();
          renderTodo();
          if (territoryReset) {
            syncStateToUrl();
          }
          if (app.selectedPartyId) {
            renderTeamDetail();
          } else {
            renderTeamList();
          }
          renderDetailPanel();
          await renderVotesPanel();
          if (isVerboseEnabled()) {
            const finalRows = filterRows();
            verboseLog("render:fin", {
              renderStamp,
              rawRows: app.rawRows.length,
              filteredRows: finalRows.length,
              partyViews: finalRows.length ? new Set(finalRows.map((row) => row.party_id)).size : 0,
            });
          }
          refs.leagueLoading.style.display = "none";
        } catch (error) {
          refs.leagueLoading.textContent = `Error: ${error.message}`;
          if (isVerboseEnabled()) {
            verboseLog("render:error", {
              renderStamp,
              message: error.message,
              stack: error.stack || "",
            });
          }
        }
      };

      const renderDetailPanel = () => {
        if (!app.selectedPartyId) {
          const rows = filterRows();
          if (rows.length === 0) {
            refs.detailView.innerHTML = "<p class='hint'>Sin informaci√≥n para mostrar. Prueba cambiando el nivel o el estado.</p>";
            return;
          }
          const lead = rows.slice(0, 4);
          refs.detailView.innerHTML = `
            <h3 style="margin-top: 0">Resumen pol√≠tico</h3>
            <p class="small">Selecciona un nivel y un partido para ver m√°s detalle.
            Si quieres revisar a un pol√≠tico, pulsa uno en la lista.</p>
            <div class="timeline">${lead
              .map(
                (row) => `
                  <div class="history-item" style="border-left-color: ${partyColor(row.party_id, row.party_name)};">
                    <strong>${personDisplayName(row)}</strong>
                    <p class="line">${row.role_title} ¬∑ ${row.institution_name} ¬∑ ${row.party_name}</p>
                  </div>
                `
              )
              .join("")}
            </div>
          `;
          return;
        }

        refs.detailView.innerHTML = `<p class='hint'>Panel activo. Pulsa sobre un pol√≠tico para ver su historial completo.</p>`;
      };

      const applyUrlState = () => {
        const p = new URLSearchParams(window.location.search);
        const debugValue = p.get("debug") || "";
        const verboseValue = p.get("verbose") || "";
        app.debug = debugValue === "1";
        app.verbose = verboseValue === "1" || window.localStorage.getItem("explorerSportsVerbose") === "1";
        app.league = p.get("league") || "all";
        app.searchTerm = p.get("search") || "";
        app.source = p.get("source") || "all";
        app.territoryFilter = p.get("territory") || "";
        // Backward-compatible: accept `party_id` as an alias for `team` (party focus links from citizen app).
        app.selectedPartyId = p.get("team") || p.get("party_id") || null;
        app.aggregateMode = p.get("agg") === "1";
        app.includeInactive = p.get("inc") === "1";

        if (app.debug) {
          window.localStorage.setItem("explorerSportsDebug", "1");
          debugLog("estado inicial aplicado desde URL", {
            league: app.league,
            source: app.source,
            territory: app.territoryFilter,
            agg: app.aggregateMode,
            inc: app.includeInactive,
            search: app.searchTerm,
          });
        } else if (debugValue === "0") {
          window.localStorage.removeItem("explorerSportsDebug");
        }
        if (app.verbose) {
          window.localStorage.setItem("explorerSportsVerbose", "1");
          verboseLog("estado inicial aplicado en modo verbose", {
            verbose: app.verbose,
            debug: app.debug,
            league: app.league,
            source: app.source,
            territory: app.territoryFilter,
            agg: app.aggregateMode,
            inc: app.includeInactive,
            search: app.searchTerm,
          });
        } else if (verboseValue === "0") {
          window.localStorage.removeItem("explorerSportsVerbose");
        }
        if (isVerboseEnabled()) {
          verboseLog("applyUrlState", {
            debugValue,
            verboseValue,
            league: app.league,
            source: app.source,
            territory: app.territoryFilter,
            leagueFilter: app.league,
            sourceFilter: app.source,
            agg: app.aggregateMode,
            inc: app.includeInactive,
            search: app.searchTerm,
            team: app.selectedPartyId,
          });
        }

        setModeButton(app.aggregateMode);
        setStateButton(!app.includeInactive);
        refs.searchInput.value = app.searchTerm;
        syncSourceSelectValue();
        syncLeagueSelectValue();
        syncTerritorySelectValue();
      };

      const renderSources = () => {
        const current = app.source;
        const options = [{ source_id: "all", name: "Todas las fuentes", scope: "" }, ...app.sources];
        refs.sourceFilter.innerHTML = options
          .map(
            (source) =>
              `<option value="${source.source_id}" ${source.source_id === current ? "selected" : ""}>${source.name || source.source_id}</option>`
          )
          .join("");
        syncSourceSelectValue();
      };

      const renderLeagueSelect = () => {
        if (!refs.leagueSelect) {
          return;
        }

        refs.leagueSelect.innerHTML = Object.entries(LEVEL_DEFINITIONS)
          .map(([id, def]) => `<option value="${id}" ${app.league === id ? "selected" : ""}>${def.label}</option>`)
          .join("");
        syncLeagueSelectValue();
      };

      const wireEvents = () => {
        if (isVerboseEnabled()) {
          verboseLog("wireEvents", {
            sourceSelect: !!refs.sourceFilter,
            leagueSelect: !!refs.leagueSelect,
            territorySelect: !!refs.territoryFilter,
          });
        }
        refs.sourceFilter.addEventListener("change", () => {
          if (isSyncingSourceSelect) {
            return;
          }
          app.source = refs.sourceFilter.value;
          app.selectedPartyId = null;
          syncStateToUrl();
          render();
        });

        refs.leagueSelect.addEventListener("change", () => {
          if (isSyncingLeagueSelect) {
            return;
          }
          app.league = refs.leagueSelect.value || "all";
          app.selectedPartyId = null;
          syncStateToUrl();
          render();
        });
        refs.territoryFilter.addEventListener("change", onTerritoryFilterChange);

        refs.searchInput.addEventListener("input", (event) => {
          app.searchTerm = event.target.value || "";
          syncStateToUrl();
          renderTeamList();
          renderScoreboard();
          renderMunicipalityLeaderboard();
          renderLeagues();
          renderDetailPanel();
          void renderVotesPanel();
        });

        refs.modeExact.addEventListener("click", () => {
          setModeButton(false);
          app.aggregateMode = false;
          syncStateToUrl();
          render();
        });

        refs.modeAggregate.addEventListener("click", () => {
          setModeButton(true);
          app.aggregateMode = true;
          syncStateToUrl();
          render();
        });

        refs.modeActive.addEventListener("click", () => {
          setStateButton(true);
          app.includeInactive = false;
          syncStateToUrl();
          render();
        });

        refs.modeAll.addEventListener("click", () => {
          setStateButton(false);
          app.includeInactive = true;
          syncStateToUrl();
          render();
        });

        refs.leagueReset.addEventListener("click", () => {
          app.league = "all";
          app.territoryFilter = "";
          app.selectedPartyId = null;
          syncStateToUrl();
          render();
        });

        refs.refreshButton.addEventListener("click", () => render({ forceReload: true }));
        refs.historyClose.addEventListener("click", closePlayerModal);
        refs.historyOverlay.addEventListener("click", (event) => {
          if (event.target === refs.historyOverlay) {
            closePlayerModal();
          }
        });

        window.addEventListener("popstate", () => {
          applyUrlState();
          render();
        });
        window.addEventListener("resize", scheduleTreemapRerender);
      };

      const init = async () => {
        applyUrlState();
        updateUiVersion();
        wireEvents();
        refs.leagueLoading.textContent = "Inicializando...";

        try {
          await Promise.all([fetchSources(), fetchElectionMeta()]);
          renderSources();
          renderLeagueSelect();
          initSelect2();
          renderLeagues();
          await render({ forceReload: true });
        } catch (error) {
          const msg = error?.message || String(error);
          const isStatic = !isLocalApiHost && !API_BASE_OVERRIDE;
          if (isStatic && String(msg).includes("HTTP 404")) {
            refs.leagueLoading.textContent = "Modo snapshot (limitado)";
            refs.detailView.innerHTML =
              "<div style='padding:14px'>" +
              "<div style='font-weight:800'>Este explorador necesita un backend</div>" +
              "<div class='muted' style='margin-top:6px'>En GitHub Pages no publicamos el snapshot completo porque es demasiado grande.</div>" +
              "<div class='muted' style='margin-top:6px'>Ejecuta <span class='mono'>just explorer</span> y abre <span class='mono'>http://127.0.0.1:9010/explorer-politico</span>.</div>" +
              "</div>";
            return;
          }
          refs.leagueLoading.textContent = `Error iniciando: ${msg}`;
          refs.detailView.textContent = "No se pudo iniciar la UI.";
        }
      };

      init();
    </script>
  </body>
</html>
